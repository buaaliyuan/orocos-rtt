<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>Inside the Orocos Core Library Manual</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2006</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	<emphasis>Core Library</emphasis> of &orocos;, the <emphasis>Open
	RObot COntrol Software</emphasis> project. The CoreLib provides
	infrastructural support for the functional and application components
	of the &orocos; framework.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>28 Feb 2006</date>
	<authorinitials>ps</authorinitials>
	<revremark>First version split off main manual.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <section>
    <title>Introduction</title>
    <para>
      This document contains some bits about the design of the CoreLib.
    </para>
  </section>
  <section>
    <title>Multi-Threading</title>
    <section id="core-priority-inversions">
      <title>Priority Inversions</title>
      <para>
	A Priority inversion is the term used to indicate a scheduling situation
	in which a high priority thread is blocked on a resource which is held
	by a low priority thread, while a medium priority thread is running,
	preventing the low priority thread to free the resource for the high
	priority thread. 
      </para>
      <para>
	The result is an inverted priority because a medium priority thread
	is running while the high priority thread should be runnen, hence, 
	the medium priority thread has, in practice, a higher priority than
	the high priority thread.
      </para>
      <para>
	There are roughly said two solution to this problem. 1. Do 
	not block on resources from high priority threads. 2. Use priority
	inheritance, where a thread gets the priority of the highest priority
	thread being blocked on a resource it holds. Once it releases the
	resource, its priority goes back to normal and the high priority thread
	can resume.
      </para>
      <para>
	In essence, Orocos does not know of priority inversions and does not
	know if the underlying Operating System properly solves this common
	situation. Furthermore, it can be prooven that there are situations 
	where priority inheritance does not work.
	Therefore, we try to provide as much as possible lock-free
	implementations of inter-thread messaging. <xref linkend="core-priority-inversion-table"/>
	lists the know uses of Orocos which <emphasis>might</emphasis> lead
	to priority inversion. 
      </para>
      <table id="core-priority-inversion-table">
	<title>Classes Possibly Subject to Priority Inversion</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Class/method</entry>
	      <entry>Rationale</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><classname>ORO_CoreLib::DataObjectLocked</classname></entry>
	      <entry>
		<para>Uses Mutex for serialising concurrent access. Alternative
		Lock-free implementations are possible.</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::PeriodicTask</classname>::start(), 
	      <classname>ORO_CoreLib::PeriodicTask</classname>::stop()</entry>
	      <entry>
		<para>( Applies to <classname>ORO_CoreLib::PriorityTask</classname>, 
		<classname>ORO_CoreLib::NonRealtimeActivity</classname>, 
		<classname>ORO_CoreLib::PreemptibleActivity</classname> and
		<classname>ORO_CoreLib::NonPreemptibleActivity</classname>).
		Uses Mutex for serialising concurrent access.
		Alternative implementation are incorrect,
		since stop() guarantees that finalize() will
		be called <emphasis>after</emphasis> the last step(), hence a
		mutex/semaphore is used such that it
		will block until the step() returns and then call finalize().
		</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::Logger</classname></entry>
	      <entry>
		<para>Uses Mutex for serialising concurrent access.
		  No Alternative implementation is possible, Std C++ IO
		  <emphasis>must</emphasis> be serialised.</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
      <para><xref linkend="core-lock-free-table"/> shows communication infrastructure
	in Orocos which is especially designed to be lock-free and which is thus 
	not subject to priority inversions. It is our aim to shrink the former
	table and grow the latter in Orocos' development lifetime.</para>
      <table id="core-lock-free-table">
	<title>Classes Not Subject to Priority Inversion</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>Class/method</entry>
	      <entry>Rationale</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry><classname>ORO_CoreLib::DataObjectLockFree</classname></entry>
	      <entry>
		<para>Uses a single writer, multiple reader Lock-free implementation.
		  A read only returns the last written value.
		  Used by the ControlKernel application to communicate data between
		  Components.</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::AtomicQueue</classname></entry>
	      <entry>
		<para>Uses Compare And Swap (CAS) to store object pointers
		in an atomic queue. Used by the Processor class to queue incomming Commands.</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::BufferLockFree</classname></entry>
	      <entry>
		<para>Uses a many writers, multiple readers Lock-free CAS implementation.
		  A read returns the oldest written value in a FIFO way.
		</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::ListLockFree</classname></entry>
	      <entry>
		<para>Uses a many writers, multiple readers Lock-free CAS implementation
		of a single linked list. A special member function 'apply' must be used
		to manipulate the objects within the list.
		</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::Event</classname>::emit()</entry>
	      <entry>
		<para>Uses the ListLockFree above for keeping track of subscribers.
		Concurrent invocations of emit() will lead to concurrent execution
		of the subscriber's callback functions.</para>
	      </entry>
	    </row>
	    <row>
	      <entry><classname>ORO_CoreLib::Handle</classname>::connect() and <classname>ORO_CoreLib::Handle</classname>::disconnect()</entry>
	      <entry>
		<para>(Dis)Connection of an event handle is hard real-time and lock-free
		because of the lock-free event implementation.</para>
	      </entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </section>
  </section>
  <section>
    <title>DataSources</title>
    <para>
      A <classname>ORO_CoreLib::DataSource</classname> is the fundamental
      data exchange entity within Orocos. It's interface is that of an
      'expression': it can be evaluate()'d, its result can be get() and
      an <classname>ORO_CoreLib::AssignableDataSource</classname> can
      even be set(). The <classname>ORO_CoreLib::DataObject</classname> types
      are implementations of DataSources, but many more kinds exists which
      are used by the Scripting engine and the task infrastructure.
    </para>
    <para>
      The <classname>ORO_CoreLib::DataSourceBase</classname> interface is the most
      basic interface for exchanging data ( value types ) between
      objects. They are reference counted ('smart pointers'), such
      that ownership across many objects must not be managed.
      The DataObjectInterface implements the DataSource interface,
      and thus all Orocos DataObject types are DataSources.
    </para>
    <para>
      The <classname>ORO_CoreLib::DataObjectInterface</classname> has multiple
      implementations, depending on the specific data access locking
      needs:
	<itemizedlist>
	  <listitem>
	    <para>
	      <emphasis role="strong"><classname>ORO_CoreLib::DataObject</classname></emphasis>. This is
	      the most simple DataObject implementation. The
	      <function>Get()</function> and
	      <function>Set()</function> methods directly map onto the
	      contents and can always be inlined by the compiler. It
	      offers no thread safety, but maximum efficiency for
	      copying data.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis role="strong"><classname>ORO_CoreLib::DataObjectLocked</classname></emphasis>.
	      This is a thread safe DataObject whose
	      <function>Set()</function> and
	      <function>Get()</function> methods are guarded by a
	      single mutex. The second thread accessing this object
	      will always block, which is not always appropriate in a
	      realtime system.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis
		role="strong"><classname>ORO_CoreLib::DataObjectPrioritySet</classname></emphasis>. This
	      is a more complex DataObject which gives always priority
	      to the thread calling <function>Set()</function>, which
	      will never block. The thread accessing
	      <function>Get()</function> will block if the
	      <function>Set()</function> thread is accessing the
	      contents. It is mainly used for sharing data between two
	      kernels, running at different priorities.
	    </para>
	    <note>
	      <para>
		This DataObject will only work if the
		<function>Set()</function> thread has the highest
		priority. When the inverse is true, data corruption
		will occur. It is obvious that this DataObject can
		only be used if both threads have static priorities
		(which is the case for all threads in the &orocos;
		framework).
	      </para>
	    </note>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis
		role="strong"><classname>ORO_CoreLib::DataObjectPriorityGet</classname></emphasis>. The
	      inverse of <function>DataObjectPrioritySet</function>.
	      The thread accessing <function>Get()</function> will
	      never block.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      <emphasis role="strong"><classname>ORO_CoreLib::DataObjectLockFree</classname></emphasis>.
	      This DataObject implements a non blocking reader/writer
	      buffer which always returns the last written value to
	      the reader. If the reader is preempted with a write and
	      a read, the last read will return a newer value, while
	      the first read continues to read the uncorrupted old
	      value.  The depth of this buffer must be readers+3, for
	      the algorithm to succeed in doing every write. Apart
	      from memory consumption, it is one of the best
	      thread-safe DataObject implementations.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
  </section>
  <section>
    <title>The Orocos Type System : Toolkits</title>
    <para>
      Most applications define their own classes or structs to exchange
      data between objects. It is possible to tell Orocos about these
      user defined types such that they can be displayed, stored to XML,
      used in the scripting engine or even transfered over a network
      connection.
    </para>

    <section>
      <title>The Real-Time Toolkit</title>
      <para>
	Orocos uses the 'Toolkit' principle to make it aware of user
	types. Orocos' Real-Time Toolkit already provides support for
	the C++ types <classname>int</classname>,<classname>unsigned
	int</classname>,<classname>double</classname>,
	<classname>char</classname>,<classname>bool</classname>,<classname>float</classname>,
	<classname>std::vector&lt;double&gt;</classname> and
	<classname>std::string</classname>.
      </para>
      <para>
	A toolkit can be imported into the application by writing:
	<programlisting>  #include &lt;corelib/RealTimeToolkit.hpp>
  // ...
  RTT::Toolkit::Import( RTT::RealTimeToolkit );	</programlisting>
	This is however done automatically, unless you disabled that
	option in the configuration system. After this line is executed,
	Orocos is able to display, transfer over a network or recognise
	these types in scripts.
      </para>
    </section>
    <section>
      <title>Telling Orocos about your data</title>
      <para>
	Say that you have an application which transfers data
	in a struct <classname>ControlData</classname> :
	<programlisting>  struct ControlData {
    double x, y, z;
    int sample_nbr;
  }</programlisting>
        How can you tell Orocos how to handle this type ? A helper
	class is provided which you can extend to fit your needs,
	<classname>ORO_CoreLib::TemplateTypeInfo</classname>.
	<programlisting>  #include &lt;corelib/TemplateTypeInfo.hpp>
  // ...
  struct ControlDataTypeInfo
    : public ORO_CoreLib::TemplateTypeInfo&lt;ControlData>
  {
     ControlDataTypeInfo
        : ORO_CoreLib::TemplateTypeInfo&lt;ControlData>("ControlData")
     {}
  };

  // Tell Orocos the name and type of this struct:
  ORO_CoreLib::TypeInfoRepository::Instance()->addType( new ControlDataTypeInfo() );
	</programlisting>
	From now on, Orocos knows the 'ControlData' type name and allows
	you to create a scripting variable of that type. It does however
	not know yet how to display it or write it to an XML file.
      </para>
      <section>
	<title>Displaying</title>
	<para>
	  In order to tell Orocos how to display your type, you
	  may overload the <function>TemplateTypeInfo::write</function> fuction
	  or define <function>operator&lt;&lt;()</function> for your type:
	</para>
	<programlisting>  #include &lt;corelib/TemplateTypeInfo.hpp>
  #include &lt;ostream>

  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ControlData&amp; cd) {
     return os &lt;&lt; '('&lt;&lt; cd.x &lt;&lt; cd.y &lt;&lt; cd.z &lt;&lt; '): ' &lt;&lt; cd.sample_nbr;
  }
  // ...
  // 'true' argument: <emphasis> it has operator&lt;&lt;</emphasis>
  struct ControlDataTypeInfo
    : public ORO_CoreLib::TemplateTypeInfo&lt;ControlData,<emphasis>true</emphasis>>
  {
     ControlDataTypeInfo
        : ORO_CoreLib::TemplateTypeInfo&lt;ControlData,<emphasis>true</emphasis>>("ControlData")
     {}
  };

  // Tell Orocos the name and type of this struct
  ORO_CoreLib::Types::Instance()->addType( new ControlDataTypeInfo() );
	</programlisting>
	<para>
	  If you use the above line of code to add the type, Orocos will be
	  able to display it as well, for example in the TaskBrowser or
	  in the ReportingComponent.
	</para>
      </section>
      <section>
	<title>Writing to XML</title>
	<para>
	  In order to inform Orocos of the structure of your data type,
	  it must be given a 'decompose' function: Of which primitive types
	  does the struct consists ? Representing structured data is what
	  Orocos <classname>ORO_CoreLib::Property</classname> objects do.
	  Here is how to tell Orocos how the "ControlData" is structured:
	</para>
	<programlisting>  // ...
  struct ControlDataTypeInfo
    : public TemplateTypeInfo&lt;ControlData,true>
  {
     // ... other functions omitted

     virtual bool decomposeTypeImpl(const ControlData&amp; in, PropertyBag&amp; targetbag ) const {
         targetbag.setType("ControlData");
         targetbag.add( new Property&lt;double>("X", "X value of my Data", in.x ) );
         targetbag.add( new Property&lt;double>("Y", "Y value of my Data", in.y ) );
         targetbag.add( new Property&lt;double>("Z", "Z value of my Data", in.z ) );
         targetbag.add( new Property&lt;int>("Sample", "The sample number of the Data", in.sample_nbr ) );
         return true;
     }
  }</programlisting>
        <para>
	  That was easy ! For each member of your struct, add a
	  <classname>ORO_CoreLib::Property</classname> of the correct
	  type to the targetbag and you're done !
	  <function>setType()</function> can be used lateron to
	  determine the version or type of your XML representation.  Next,
	  if Orocos tries to write an XML file with ControlData in it,
	  it will look like:
	</para>
	<programlisting>
<![CDATA[  <struct name="MyData" type="ControlData">
    <simple name="X" type="double">
       <description>X value of my Data</description>
       <value>0.12</value>
    </simple>
    <simple name="Y" type="double">
       <description>Y value of my Data</description>
       <value>1.23</value>
    </simple>
    <simple name="Z" type="double">
       <description>Z value of my Data</description>
       <value>3.21</value>
    </simple>
    <simple name="Sample" type="short">
       <description>The sample number of the Data</description>
       <value>3123</value>
    </simple>
  </struct>]]>
	</programlisting>
      </section>
      <section>
	<title>Reading from XML</title>
	<para>
	  Orocos does not know yet how to convert an XML format back
	  to the ControlData object. This operation is called 'composition'
	  and is fairly simple as well:
	  Here is how to tell Orocos how the "ControlData" is read:
	</para>
	<programlisting>  // ...
  struct ControlDataTypeInfo
    : public TemplateTypeInfo&lt;ControlData,true>
  {

     // ... other functions omitted

     virtual bool composeTypeImpl(const PropertyBag&amp; bag, ControlData&amp; out ) const 
     {
        if ( bag.getType() == std::string("ControlData") ) // check the type
        {  
          Property&lt;double>* x = targetbag.getProperty&lt;double>("X");
          Property&lt;double>* y = targetbag.getProperty&lt;double>("Y");
          Property&lt;double>* z = targetbag.getProperty&lt;double>("Z");
          Property&lt;int>* t = targetbag.getProperty&lt;int>("Sample");

	  if ( !x || !y || !z || !t )
	     return false;

          out.x = x->get();
          out.y = y->get();
          out.z = z->get();
          out.sample_nbr = t->get();
          return true;
        }
        return false; // unknown type !
     }
  }</programlisting>
        <para>
	  First the properties are located in the bag, it should look just
	  like we stored them. If not, return false, otherwise, read the
	  values and store them in the out variable.
	</para>
      </section>
      <section>
	<title>Network transfer (CORBA)</title>
	<para>
	  In order to transfer your data between components over a
	  network, Orocos requires that you provide the conversion
	  from your type to a CORBA::Any type and back, quite similar
	  to the 'composition' and 'decomposition' of your data.
	  Look at the <classname>ORO_CoreLib::TemplateTypeInfo</classname>
	  interface for the functions you need to implement.
	</para>
	<para>
	  The first step is describing your struct in IDL and generate
	  the 'client' headers with 'Any' support. Next you
	  create such a struct, fill it with your data type's data
	  and next 'stream' it to an Any. The other way around is
	  required as well.
	</para>
	<para>
	  In addition, you will need the CORBA support of Orocos
	  enabled in your build configuration.
	</para>
      </section>
      <section>
	<title>Advanced types</title>
	<para>
	  In order to add more complex types, take a look at the
	  code of the RealTimeToolkit and the GeometryToolkit of Orocos.
	</para>
      </section>
    </section>
    <section>
      <title>Building your own Toolkit</title>
      <para>
	The number of types may grow in your application to such
	a number or diversity that it may be convenient to 
	build your own toolkit and import them when appropriate.
	Non-Orocos libraries benefit from this system as well because
	they can introduce their data types into Orocos.
      </para>
      <para>
	Each toolkit must inherit from the <classname>ORO_CoreLib::ToolkitPlugin</classname>
	class and implement three functions: <function>loadTypes()</function>,
	<function>loadOperators()</function> and <function>getName()</function>.
      </para>
      <para>
	The name of a toolkit must be unique. Each toolkit will be loaded
	no more than once. The loadTypes function contains all 
	'TemplateTypeInfo' constructs to tell Orocos about the types
	of your toolkit. The loadOperators function contains all
	operations that can be performed on your data such as addition ('+'),
	indexing ('[i]'), construction ('vector(1.0,2.0,3.0)'),
	comparison ('==') etc.
      </para>
      <para>
	Mimick the code of the
	<classname>ORO_CoreLib::RealTimeToolkit</classname> and
	<classname>ORO_CoreLib::GeometryToolkit</classname> to build
	your own.
      </para>
      <section id="overloading-operators">
	<title>Loading Operators</title>
	<para>
	  Operator are stored in the class <classname>ORO_CoreLib::OperatorRepository</classname>
	  in <filename>Operators.hpp</filename>.  The list of
	  supported operators is set by the toolkit and added to the OperatorRepository
	  It looks something like this:
	  <programlisting>
bool loadOperators() {
  OperatorRepository::shared_ptr or = OperatorRepository::Instance();
  // boolean stuff:
  or->add( newUnaryOperator( &quot;!&quot;, std::logical_not&lt;bool&gt;() ) );
  or->add( newBinaryOperator( &quot;&amp;&amp;&quot;, std::logical_and&lt;bool&gt;() ) );
  or->add( newBinaryOperator( &quot;||&quot;, std::logical_or&lt;bool&gt;() ) );
  or->add( newBinaryOperator( &quot;==&quot;, std::equal_to&lt;bool&gt;() ) );
  or->add( newBinaryOperator( &quot;!=&quot;, std::not_equal_to&lt;bool&gt;() ) );
  return true;
} </programlisting>
	  Adding your own should not be terribly hard.  The hardest
	  part is that as the second argument to newUnaryOperator,
	  newBinaryOperator or newTernaryOperator, you need to specify
	  a STL Adaptable Functor, and even though the STL provides
	  many predefined one's, it does not provide all possible
	  combinations, and you might end up having to write your
	  own.  The STL does not at all provide any "ternary
	  operators", so if you need one of those, you'll definitely
	  have to write it yourself.
	</para>
	<para>
	  Note that this section is only about adding overloads for
	  existing operators, if you want to add new operators to
	  the scripting engine, the parsers need to be extended as well.
	</para>
      </section>
    </section>
  </section>
</article>
