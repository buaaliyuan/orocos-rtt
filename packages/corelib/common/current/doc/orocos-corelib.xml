<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>The Orocos Core Library Manual</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002-2006</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the principles of the
	<emphasis>Core Library</emphasis> of &orocos;, the <emphasis>Open
	RObot COntrol Software</emphasis> project. The CoreLib provides
	infrastructural support for the functional and application components
	of the &orocos; framework.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>22 Aug 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.9</revnumber>
	<date>11 Nov 2002</date>
	<authorinitials>ps</authorinitials>
	<revremark>lots of updates</revremark>
      </revision>
      <revision>
	<revnumber>0.11</revnumber>
	<date>29 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Stripped Devices and OS parts</revremark>
      </revision>
      <revision>
	<revnumber>0.12</revnumber>
	<date>2 Apr 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>StateMachine updates</revremark>
      </revision>
      <revision>
	<revnumber>0.13</revnumber>
	<date>18 May 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>Change in the StateMachine interface</revremark>
      </revision>
      <revision>
	<revnumber>0.14</revnumber>
	<date>2 June 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>Clarified some parts based on feedback</revremark>
      </revision>
      <revision>
	<revnumber>0.18</revnumber>
	<date>10 Dec 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>New Event Implementation and Simulation Thread. Reordering and cleanup of Sections.</revremark>
      </revision>
      <revision>
	<revnumber>0.18.1</revnumber>
	<date>5 Jan 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added Logging Framework.</revremark>
      </revision>
      <revision>
	<revnumber>0.20.0</revnumber>
	<date>31 Jan 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added DataObject section within Buffer section. Added NonPeriodicActivity.</revremark>
      </revision>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>15 Feb 2006</date>
	<authorinitials>ps</authorinitials>
	<revremark>Removed Fifo section. Split off developer specific info.</revremark>
      </revision>
      <revision>
	<revnumber>0.24.0</revnumber>
	<date>13 April 2006</date>
	<authorinitials>ps</authorinitials>
	<revremark>'Tasks' replaced by 'Activities'.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <section>
    <title>Introduction</title>
    <para>
      This Chapter describes the semantics of the services
      available in the &orocos; CoreLib Package.
    </para>
    <para>
      The CoreLib provides:
      <itemizedlist>
	<listitem><para>Thread-safe C++ implementations for periodic, non periodic and event driven activities</para></listitem>
	<listitem><para>Synchronous/Asynchronous Events</para></listitem>
	<listitem><para>Time measurement</para></listitem>
	<listitem><para>Application logging and reporting</para></listitem>
	<listitem><para>Properties and XML configuration</para></listitem>
	<listitem><para>Lock-free data exchange primitives such as fifo buffers or shared data.</para></listitem>
      </itemizedlist> 
      and additionally provides interfaces which are common for all realtime services.
      The CoreLib provides a hard realtime <emphasis>infrastructure</emphasis>:
    </para>
    <blockquote>
      <para>
	<emphasis> The goal of the infrastructure is to keep
	applications deterministic, by avoiding the classical pitfalls
	of letting application programmers freely use threads and
	mutexes as bare tools. Practice has indeed showed that most
	programmers do not succeed in strictly decoupling the
	functional and algorithmic parts of their code from the
	OS-specific primitives used to execute them.</emphasis>
      </para>
    </blockquote>
    <para>
      Of course, the realtime performance depends not only on
      the underlying operating system 
      <emphasis>but also on the hardware.</emphasis> Hardware devices are abstracted
      in the Orocos Device Interface package.
    </para>
    <para>
      The following sections will first introduce the reader to creating
      Activities, which execute functions in a thread, in the system. Furtheron, they are extended
      with Events. The following sections explain usefull classes which
      are used throughout the framework such as the TimeService,
      Properties and the object NameServer.
    </para>
  </section>
  <section>
    <title>Periodic and non Periodic Activities</title>
    <note>
      <para>In older Orocos versions, 'Activities' were named 'Tasks'.</para>
    </note>
    <para>
      An Activity executes a function when a 'trigger' occurs. Although, 
      ultimately, an activity is executed by a thread, it does not map
      one-to-one on a thread. A thread may execute ('serialise') multiple
      activities. This section gives an introduction to defining periodic activities,
      which are triggered periodically, non periodic activities, which are triggered
      by the user, and event driven activities, which are run when an Orocos event occurs.
    </para>
    <section>
      <title>Standard Periodic Activities</title>
      <para>
	For convenience, Orocos provides implementations
	for three types of periodic activities ( which only differ in
	periodicity and priority ) but allows to extend to more for
	your specific needs.
	A basic periodic control application needs for example, a high
	priority periodic thread and a low priority periodic
	thread. The high priority thread is used for all periodic
	activities that need to be executed atomically. No action in
	this thread will ever be preempted by another thread. The low
	priority realtime thread is used for all periodic activities
	which may be preempted but still have hard deadlines. It can
	always be preempted by the high priority thread. There is also
	a non realtime (periodic) thread which gives no deadline
	guarantees.  
      </para>
      <para>
	Orocos provides, by default, two hard realtime periodic
	activties and a non realtime periodic activity to execute your
	functions. The
	<classname>ORO_CoreLib::NonPreemptibleActivity</classname> has the
	highest priority, the
	<classname>ORO_CoreLib::PreemptibleActivity</classname> has a
	lower priority and the
	<classname>ORO_CoreLib::NonRealTimeActivity</classname> has an
	even lower priority is not realtime at all (but still
	periodic). Each instance of the same type run in the same thread.
	In complexer control applications, one can create additional
	threads by using the <classname>ORO_CoreLib::PeriodicActivity</classname>.
	If these activities are used, Orocos will create a thread and
	start/stop them automatically, otherwise, these threads
	are not created.
      </para>
      <important>
	<para>
	  You must configure the priority and periodicity of the
	  three predefined threads in the configtool program.
	</para>
      </important>
    </section>
    <section>
      <title>Creating a Periodic Activity</title>
      <para>
	If you want to execute functionality in one of the Orocos threads, you need to 
	create a Activity of a certain type, depending on the thread type. The table
	below summarises which Activity type there is per thread.
	<table>
	  <title>Thread and Activity summary</title>
	  <!-- one of (graphic mediaobject tgroup) -->
	  <tgroup cols="2">
	    <thead>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>Thread (created by Orocos)</entry>
		<entry>Activity (created by User)</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><classname>ORO_CoreLib::TimerThread</classname></entry>
		<entry><classname>ORO_CoreLib::PeriodicActivity</classname></entry>
		<!-- one of (entrytbl entry) -->
	      </row>
	      <row>
		<entry><classname>ORO_CoreLib::ZeroTimeThread</classname></entry>
		<entry><classname>ORO_CoreLib::NonPreemptibleActivity</classname></entry>
		<!-- one of (entrytbl entry) -->
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::ZeroLatencyThread</classname></entry>
		<entry><classname>ORO_CoreLib::PreemptibleActivity</classname></entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::NonRealTimeThread</classname></entry>
		<entry><classname>ORO_CoreLib::NonRealTimeActivity</classname></entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::SimulationThread</classname></entry>
		<entry><classname>ORO_CoreLib::SimulationActivity</classname></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table></para>
      <para>
	There are two ways to run a function in a periodic activity. By :
	<itemizedlist>
	  <listitem>
	    <para>
	      Implementing the
	      <classname>ORO_CoreLib::RunnableInterface</classname> in
	      another class ( functions initialize(), step() or
	      loop()/breakLoop() and finalize() ). The
	      RunnableInterface object (i.e. run_impl) can be assigned
	      to a activity using <synopsis> activity.run(
	      &amp;run_impl )</synopsis> or at construction time of an
	      Activity : <synopsis> PeriodicActivity activity(priority,
	      period, &amp;run_impl );</synopsis>.
	    </para>
	    <para>
	      <programlisting>  #include &lt;corelib/RunnableInterface.hpp>
  #include &lt;corelib/PeriodicActivity.hpp>

  class MyPeriodicActivity
	: public <classname>ORO_CoreLib::RunnableInterface</classname>
  {
  public:
    // ...
    bool initialize() {
       // your init stuff
       myperiod = this->getActivity()->getPeriod();
       isperiodic = this->getActivity()->isPeriodic();
       
       // ...
       return true; // if all went well
    }

    // executed when isPeriodic() == true
    void step() {
       // periodic actions
    }

    // executed when isPeriodic() == false
    void loop() {
       // 'blocking' version of step(). Implement also breakLoop()
    }

    void finalize() {
       // cleanup
    }
  };

  // ...
  MyPeriodicActivity run_impl_1;
  MyPeriodicActivity run_impl_2;

  <classname>ORO_CoreLib::PeriodicActivity</classname> activity( 15, 0.01 ); // priority=15, period=100Hz
  activity.run( &amp;run_impl_1 );
  activity.start(); // calls 'step()'

  <classname>ORO_CoreLib::NonPeriodicActivity</classname> npactivity(12); // priority=12, no period.
  npactivity.run( &amp;run_impl_2);
  activity.start(); // calls 'loop()'

  // etc...  </programlisting>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Inheriting from an Activity class and overriding the initialize(), step()
	      and finalize() methods.
	      <programlisting>
  class MyOtherPeriodicActivity
      : public <classname>ORO_CoreLib::PeriodicActivity</classname>
  {
  public :
    MyOtherPeriodicActivity()
      : <classname>ORO_CoreLib::PeriodicActivity</classname>( 15, 0.01 ) // priority=15, period=100Hz
    {
    }

    bool initialize() {
       // your init stuff
       double myperiod = this->getPeriod();
       // ...
       return true; // if all went well
    }

    void step() {
       // periodic actions
    }

    void finalize() {
       // cleanup
    }
	// ...
  };

  // When started, will call your step
  MyOtherPeriodicActivity activity;
  activity.start();  </programlisting>
	    </para>
	  </listitem>
	</itemizedlist>
	The Activity will detect if it must run an external RunnableInterface. If none
	was given, it will call its own virtual methods.
      </para>
    </section>
    <section>
      <title>Periodic Activity Ordering</title>
      <para>
	The standard periodic Activities (NonPreemptibleActivity,
	PreemptibleActivity and NonRealTimeActivity) are executed
	<emphasis>in the order as they are started</emphasis>.  The
	periodic thread responsible for the Activity will execute all
	activities one after the other, respecting the periodicity of
	the periodic activity. This means that a Activity with a lower
	periodicity of the thread (e.g. 10 times lower) will only be
	called a fraction of the time (thus every 10th period), still
	respecting the ordering.
      </para>
      <para>
	<figure><title>Execution sequence diagram</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="execution-sequence" />
	    </imageobject>
	    <!--
	    <caption><para>
	  </para></caption>
	    -->
	  </mediaobject>
	</figure>
      </para>
      <para>
	A PeriodicActivity instance is only serialised with another instance
	if the priorities and periodicities match. Otherwise, a new thread
	is created.
      </para>
    </section>
    <section>
      <title>Example Periodic Activity Creation</title>
      <example>
	<title>Example Periodic Activity Creation</title>
	<para>
	  This example shows how all kinds of activities can be created. When a activity
	  is started it will add itself to the correct thread.
	</para>
	<programlisting>#include "corelib/NonPreemptibleActivity.hpp"
#include "corelib/PreemptibleActivity.hpp"
#include "corelib/NonRealTimeActivity.hpp"
#include "corelib/PeriodicActivity.hpp"

using namespace ORO_CoreLib;

ORO_main( int argc, char** argv)
{
  // Define your activities

  // ...

  // The threads are created by Orocos.
  // Both activities run in the same thread:
  <classname>ORO_CoreLib::NonPreemptibleActivity</classname> fast_activity1(0.001, &amp;vel_loop);
  <classname>ORO_CoreLib::NonPreemptibleActivity</classname> fast_activity2(0.001, &amp;vel_loop2);

  <classname>ORO_CoreLib::PreemptibleActivity</classname> slow_activity(0.01, &amp;pos_loop);
  <classname>ORO_CoreLib::NonRealTimeActivity</classname> nrt_activity( 0.1, &amp;display_server );

  // This activity is run in its own thread.
  <classname>ORO_CoreLib::PeriodicActivity</classname> own_activity( 9, 0.05, &amp;kine_loop );

  // All is transparant from here on.
  fast_activity1->start();
  fast_activity2->start(); // is always run directly after fast_activity1 !
  slow_activity->start();
  own_activity->start();
  nrt_activity->start();

  // ...

  fast_activity1->stop();
  fast_activity2->stop();
  slow_activity->stop();
  own_activity->stop();
  nrt_activity->stop();

  return 0;
}</programlisting>
      </example>
    </section>
    <section>
      <title>Standard Periodic Threads Overview</title>
      <para>
	The high priority thread is the
	<classname>ORO_CoreLib::ZeroTimeThread</classname>. It will execute all
	<classname>ORO_CoreLib::NonPreemptibleActivity</classname> Activities
	synchronically. You can create your own not preemptable activity by
	inheriting from this class. Its name is derived from the fact
	that some activities need to be executed in an infinite small
	amount of time to work correctly. Control loops are an example
	of this. To come as close as possible to this (impossible)
	constraint, we make sure that the activity is never preempted by
	another activity and thus is executed 'atomically'.
      </para>
      <para>
	The low priority activities are executed by the
	<classname>ORO_CoreLib::ZeroLatencyThread</classname> class. It will
	execute all <classname>ORO_CoreLib::PreemptibleActivity</classname> Activities
	sequentially, when no non-preemptible activities are executed.
	Every <classname>ORO_CoreLib::PreemptibleActivity</classname> can be preempted
	by a <classname>ORO_CoreLib::NonPreemptibleActivity</classname> but not by
	another <classname>ORO_CoreLib::PreemptibleActivity</classname>. The
	ZeroLatencyThread has this name because the zero time
	constraint is dropped, but replaced by the constraint that no
	latency may occur and thus, execution is still realtime.
	Again, to satisfy this constraint, only deterministic time
	operations may be done in this thread.
      </para>
      <para>
	For not realtime executions, as there are userspace
	communication, memory allocations,... we use the
	NonRealTimeThread. Roughly put, you can do
	<emphasis>anything</emphasis> in this thread, as long as it
	takes finite time. This is the lowest priority thread in the
	system and it should never lock a resource of the realtime
	thread. Activities being executed in the NonRealTimeThread are
	called <classname>ORO_CoreLib::NonRealTimeActivity</classname>.
      </para>
      <para>
	The last standard thread type Orocos provides is the 
	<classname>ORO_CoreLib::SimulationThread</classname> which runs
	<classname>ORO_CoreLib::SimulationActivity</classname>s. It is special in
	that it executes all its activities as fast as possible
	( thus without periodic sleeps ) and adjusting the
	system's clock between each <emphasis>step()</emphasis>.
	The latter allows correct timing measurement in the
	activities running in a SimulationThread. The SimulationThread
	runs by default not-realtime, but this can be changed by
	calling the <function>SimulationThread::Instance()->makeHardRealtime()</function>
	function.
      </para>
    </section>
    <section id="activity-non-periodic">
      <title>Non Periodic Activities</title>
      <para>
	Non periodic activities are run in <emphasis>non
	periodic</emphasis> threads, or possibly
	<emphasis>after</emphasis> all periodic activities of a
	certain periodic thread. The latter to avoid excessive jitter
	in periodic activity execution.
      </para>
      <para>
	If you want to create an activity which reads file-IO, or displays
	information or does any other possibly blocking operation, the
	<classname>ORO_CoreLib::NonPeriodicActivity</classname> implementation can be
	used. When it is <function>start()</function>'ed, its loop()
	method will be called exactly once and then it will wait,
	after which it can be start()'ed again.  Analogous to periodic
	activities, the user can implement
	<function>initialize()</function>, <function>loop()</function>
	and <function>finalize()</function> functions in a
	<classname>ORO_CoreLib::RunnableInterface</classname> which will be used by
	the activity for executing the user's functions. Alternatively,
	you can reimplement said functions in a derived class of
	NonPeriodicActivity. The activity's loop() will be executed in its own
	thread, thus creating a NonPeriodicActivity means creating a new
	thread :
      </para>
      <programlisting>  int priority = 5;
  
  <classname>ORO_CoreLib::RunnableInterface</classname>* blocking_activity = ...
  <classname>ORO_CoreLib::NonPeriodicActivity</classname> activity( priority, blocking_activity );
  activity.start(); // calls blocking_activity->initialize()

  // now blocking_activity->loop() is called in a thread with priority 5.  
  // assume loop() finished...

  activity.start();  // executes again blocking_activity->loop()

  // calls blocking_activity->breakLoop() if loop() is still executing,
  // when loop() returned, calls blocking_activity->finalize() :
  activity.stop(); </programlisting>
      <para>
	The NonPeriodicActivity differs from the
	<classname>PeriodicActivity</classname> in the way start() and stop()
	work. Only the first invocation of start() will invoke initialize().
	Then loop() is executed once. Since the activity may be blocked in the user's loop()
	function, the user must reimplement the
	<function>RunnableInterface::breakLoop()</function>
	function. This funcion must do whatever necessary to let the
	user's loop() function return (mostly set a flag).  It must return true on
	success, false if it was unable to let the loop() function
	return (the latter is the default implementation's return
	value).  <function>stop()</function> then waits until loop()
	returns or aborts if <function>breakLoop()</function> returns
	false. When successful, stop() executes the finalize() function.
      </para>
    </section>
    <section>
      <title>Custom or Slave Activities</title>
      <para>
	If non of the above activity schemes fit you, you can always fall back on
	the <classname>ORO_CoreLib::SlaveActivity</classname>, which lets the user
	control when the activity is executed. A special function <function>bool trigger()</function>
	is implemented which will execute <function>RunnableInterface::step()</function>
	or <function>RunnableInterface::loop()</function> when called by the user.
	Three versions of the <classname>SlaveActivity</classname> can be constructed:
	<programlisting>  #include &lt;corelib/SlaveActivity.hpp>

  // <emphasis>With master</emphasis>
  // a 'master', any ActivityInterface (even SlaveActivity):
  <classname>ORO_CoreLib::PeriodicActivity</classname> master_one(9, 0.001 );
  // a 'slave', takes over properties (period,...) of 'master_one':
  <classname>ORO_CoreLib::SlaveActivity</classname> slave_one( &amp;master_one );

  slave_one.start();   // fail: master not running.
  slave_one.trigger(); // fail: slave not running.

  master_one.start();  // start the master.
  slave_one.start();   // ok: master is running.
  slave_one.trigger(); // ok: calls step(), repeat...
  
  // <emphasis>Without master</emphasis>
  // a 'slave' without explicit master, with period of 1KHz.
  <classname>ORO_CoreLib::SlaveActivity</classname> slave_two( 0.001 );
  // a 'slave' without explicit master, not periodic.
  <classname>ORO_CoreLib::SlaveActivity</classname> slave_three();

  slave_two.start();   // ok: start periodic without master
  slave_two.trigger(); // ok, calls 'step()', repeat...
  slave_two.stop();

  slave_three.start();   // start not periodic.
  slave_three.trigger(); // ok, calls 'loop()', may block !
  // <emphasis>if loop() blocks, trigger() blocks as well.</emphasis>
	</programlisting>
      </para>
      <para>
	Note that although there may be a master, it is still the
	user's responsibility to call <function>trigger()</function>.
      </para>
    </section>
    <section>
      <title>Event Driven Activities</title>
      <para>
	An alternative way to use non periodic activities is to use
	the <classname>ORO_CoreLib::EventDrivenActivity</classname>,
	which can be bound to an <classname>ORO_CoreLib::Event</classname> (see <xref linkend="corelib-events" /> )
	and each time the Event is emitted, the step() method will be invoked
	asynchronously in a given thread.
	This will happen from the moment the activity's start method is called
	until the stop method is called. The following example shows
	how such a activity can be run asynchronously.
	<programlisting>  #include &lt;corelib/EventDrivenActivity.hpp>

  //...
  <classname>ORO_CoreLib::Event</classname>&lt;void(void)> activity_event;
  <classname>ORO_CoreLib::EventDrivenActivity</classname> activity( &amp;activity_event, <classname>ORO_CoreLib::ZeroTimeThread</classname>::Instance(), &amp;run_obj);

  activity_event.emit(); // nothing happens

  activity.start();      // initialize()s activity
  activity_event.emit(); // activity's step() will be executed once in ZeroTimeThread

  activity.stop();       // finalize()s activity</programlisting>
      </para>
    </section>
    <section>
      <title>Accessing the Threads from Activities</title>
      <para>
	Each Orocos Activity (periodic, non periodic and event driven)
	type has a <function>thread()</function> method in its
	interface which gives a non-zero pointer to a
	<classname>ORO_OS::ThreadInterface</classname> object which provides
	general thread information such as the priority and periodicity and allows to
	control the realtimeness of the thread which runs this activity. A
	non periodic activity's thread will return a period of zero.
      </para>
      <para>
	A <classname>ORO_CoreLib::RunnableInterface</classname> can get the same information
	through the <function>this->getActivity()->thread()</function> method calls.
      </para>
      <para>
	<example>
	<title>Example Periodic Thread Interaction</title>
	<para>
	    This example shows how to manipulate a thread.
	</para>
	<programlisting>#include "corelib/ActivityInterface.hpp"

using namespace ORO_CoreLib;

ORO_main( int argc, char** argv)
{
  // ... create any kind of Activity like above.

  <classname>ORO_CoreLib::ActivityInterface</classname>* act = ...

  // stop the thread and all its activities:
  act->thread()->stop();
  // change the period:
  act->thread()->setPeriod( 0.01 );
  act->thread()->start();
  // Optional :
  act->thread()->makeHardRealtime();

  // Now the activity can be started as well:
  act->start();

  // act is running...

  return 0;
}</programlisting>
      </example>
      </para>
    </section>
    <section>
      <title>Simulation</title>
      <para>
	The SimulationThread is available to do as fast as possible 
	execution of SimulationActivity objects. Its priority and
	simulated periodicity can be changed with the configuration tool, or
	before its started.
      </para>
	<programlisting>#include "corelib/SimulationActivity.hpp"

using namespace ORO_CoreLib;

ORO_main( int argc, char** argv)
{
  // Define your activities

  // ...

  // Manually start the simulation thread
  // 0.001 : The (virtual) period :  no activity can run 'faster' than this.
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->periodSet( 0.001 );
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->start();

  // Optional, might hang your program :
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->makeHardRealtime();

  // fast_sim_activity will measure 0.001s elapses between each step(),
  // slow_sim_activity will measure 0.01s elapses in time between each step()
  <classname>ORO_CoreLib::SimulationActivity</classname> fast_sim_activity(0.001, &amp;vel_loop);
  <classname>ORO_CoreLib::SimulationActivity</classname> slow_sim_activity(0.01, &amp;pos_loop);

  // All is transparant from here on.
  fast_sim_activity->start();
  slow_sim_activity->start();

  // ...

  fast_sim_activity->stop();
  slow_sim_activity->stop();

  return 0;
}</programlisting>
      <warning>
	<para>
	  If other threads are running in the same program executable,
	  they will also 'notice' the fast system time changes if the SimulationThread
	  is started. It is thus advisable not to mix SimulationThreads with
	  other threads. Also, any thread with lower priority than the 
	  SimulationThread will never run.
	</para>
      </warning>
    </section>
  </section>
  <section id="corelib-events">
    <title>Events</title>
    <para>
      An <classname>ORO_CoreLib::Event</classname> is an object to
      which one can connect callback functions. When the Event is
      raised, the connected functions are called one after the
      other. An Event can carry data and deliver it to the function's
      arguments. Orocos allows two possibilities of calling the
      function : synchronous and asynchronous. The former means that
      when the emit() method is called, all synchronous handlers are
      called in the same thread. The latter means that the data is
      stored and the callback function is called in another
      thread. The thread which will execute the deferred callback is
      chosen at connection or setup time.
    </para>
    <figure><title>Event Handling</title>
    <mediaobject>
      <imageobject>
	<imagedata fileref="EventSerialisationActivity" />
      </imageobject>
      <caption><para>Activity A1 runs in PeriodicThread (a) while Activity A2
      runs in PeriodicThread (b). At some time, A1 registers a
      synchonous and asynchronous callback function ( reaction ) with
      activity A2's Event. When A2 emits the Event, the
      synchronous Event callback is executed first ( within Thread (b)
      ), while the asynchronous ( deferred ) callback is queued and
      executed after A1 has run, in Thread (a).  </para></caption>
    </mediaobject>
    </figure>
    <para>
      The Orocos Event system in versions 0.18.x and 0.20.x
      use the <ulink url="http://www.boost.org/">boost::signals</ulink> library.
      Later versions (from 0.22.0 on) use a specially crafted signals implementation
      which allows hard real-time connection of handlers.
    </para>
    <para>
      The Orocos Event extends the signal with asynchronous event handling. 
      Any kind of function can be connected to the event as long as it has the
      same signature as the Event. The 'raise' or 'fire' method of an Orocos Event is
      called <methodname>emit()</methodname> (fire() and operator() are present as well).
    </para>
    <section>
      <title>Event Basics</title>
      <example id="core-event-example">
      <title>Using Events</title>
      <para>
	This example shows how a synchronous and asynchronous handler
	are connected to an Event.
      </para>
      <programlisting>#include &lt;corelib/Event.hpp>

using boost::bind;

class SafetyStopRobot
{
public:
    void handle_now() {
        // Synchronous Handler code
    std::cout &lt;&lt; " Putting the robot in a safe state fast !" &lt;&lt; std::endl;
    }
};

Class NotifyUser
{
public:
    void handle_later() {
	    //Asynchronous Completer code
	    std::cout &lt;&lt; "The program stopped the robot !"&lt;&lt;std::endl;
    }
};

...
SafetyStopRobot safety;
NotifyUser      notify;

// The &lt;..> means the callback functions must be of type "void foo(void)"
<classname>ORO_CoreLib::Event</classname>&lt;void(void)> emergencyStop;
<classname>ORO_CoreLib::Handle</classname> emergencyHandle;

// boost::bind is a way to connect the method of an object instance to
// an event.
std::cout &lt;&lt; "Register apropriate handlers to the Emergency Stop Event\n";
emergencyHandle = 
   emergencyStop.connect( bind( &amp;SafetyStopRobot::handle_now, &amp;safety),
	                  bind( &amp;NotifyUser::handle_later, &amp;notify) );

std::cout &lt;&lt; "Emit the event\n";
emergencyStop.emit();

// Disconnecting the callbacks...
emergencyHandle.disconnect();

// Add only synchronous callback :
emergencyHandle = 
   emergencyStop.connect( bind( &amp;SafetyStopRobot::handle_now, &amp;safety) );

std::cout &lt;&lt; "Doing a quiet safety stop..."&lt;&lt;std::endl;
emergencyStop.emit(); // User not notified</programlisting>
      <screen>
	  Register apropriate handlers to the Emergency Stop Event
	  Emit the event
	   Putting the robot in a safe state fast !
	  The program stopped the robot !
	  Doing a quiet safety stop...
	   Putting the robot in a safe state fast !
      </screen>
      <para>
	If you want to find out how boost::bind works, see the Boost
	<ulink url="http://www.boost.org/libs/bind/bind.html">bind manual</ulink>.
	You must use bind if you want to call C++ class member functions to 
	'bind' the member function to an object :
	<programlisting>  ClassName object;
  boost::bind( &amp;ClassName::FunctionName, &amp;object)	</programlisting>
	Where ClassName::FunctionName must have the same signature as the Event.
	When the Event is <function>emit( args )</function>'ed,
	<programlisting>
  object->FunctionName( args )</programlisting>
	is executed by the Event.
      </para>
      <para>When you want to call free ( C ) functions, you do not need bind :
	<programlisting>  Event&lt;void(void)> event;
  void foo() { ... }
  event.connect( &amp;foo );</programlisting>
      </para>
    </example>
    <para>
      Whether your <function>handle()</function> and <function>complete()</function>
      methods contain deterministic code or not is up to you. It depends on the choice of the
      Event type and in which thread it is executed. A good rule of thumb is to make
      all Synchronous handling/completing deterministic time and do all the rest in 
      the Asynchronous part, which will be executed by the
      another thread.
    </para>
    <para>
      You must choose the type of <classname>ORO_CoreLib::Event</classname> upon
      construction. This can no longer be changed once the
      <classname>ORO_CoreLib::Event</classname> is created. The type is the
      same for the synchronous and asynchronous methods. If the type changes,
      the emit() method must given other arguments. For example :
      <example>
	<title>Event Types</title>
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(void)> e_1;
  e_1.emit();

  <classname>ORO_CoreLib::Event</classname>&lt;void(int)>  e_2;
  e_2.emit( 3 );

  <classname>ORO_CoreLib::Event</classname>&lt;void(double,double,double)>  positionEvent;
  positionEvent.emit( x, y, z);</programlisting>
      </example>
    </para>
    <para>
      Furthermore, you need to setup the connect call differently if the Event
      carries one or more arguments :
      <programlisting>  SomeClass someclass;

  Event&lt;void(int, float)&gt; event;

  // notice that for each Event argument, you need to supply _1, _2, _3, etc...
  event.connect( boost::bind( &amp;SomeClass::foo, someclass, _1, _2 ) );

  event.emit( 1, 2.0 );</programlisting>
    </para>
    <important>
    <para>
      The return type for synchronous and asynchronous callbacks is ignored
      and can not be recovered from emit(), which always returns void.
    </para>
    </important>
    </section>
    <section>
      <title><function>setup()</function> and the <classname>ORO_CoreLib::Handle</classname> object</title>
      <para>
	Event connections can be managed by using a Handle which both <function>connect()</function>
	and <function>setup()</function> return :
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(int, float)&gt; event;
  <classname>ORO_CoreLib::Handle</classname> eh;

  // store the connection in 'eh'
  eh = event.connect( ... );
  assert( eh.connected() );

  // disconnect the function(s) :
  eh.disconnect();
  assert( !eh.connected() );

  // reconnect the function(s) :
  eh.connect();
  // connected again !
	</programlisting>
	Handle objects can be copied and will all show the same status.
	To have a connection setup, but not connected, one can write :
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(int, float)&gt; event;
  <classname>ORO_CoreLib::Handle</classname> eh;

  // setup : store the connection in 'eh'
  eh = event.setup( ... );
  assert( !eh.connected() );

  // now connect the function(s) :
  eh.connect();
  assert( eh.connected() );  // connected !
	</programlisting>
	If you do not store the connection of setup(), the connection will never
	be established and no memory is leaked. If you do not use 'eh' to connect
	and destroy this object, the connection is also cleaned up. If you use
	'eh' to connect and then destroy 'eh', you can never terminate the connection,
	except by destroying the Event itself.
      </para>
    </section>
    <section>
      <title>Choosing the Asynchronous Thread</title>
      <para>
	The Event implementation provides one thread for
	asynchronous execution. The Orocos Activities package provides
	four additional threads for executing the asynchronous
	callbacks.
      </para>
      <note>
	<para>
	  For brevity, we will not use boost::bind in the following
	  examples and only use 'free' ( <emphasis>C</emphasis> ) functions as callbacks.
	  Asynchronous callbacks are bound in the same way as synchronous
	  callbacks ( <xref linkend="core-event-example"/> ) :
	  <programlisting>  void syn_func( int, double ) { /* .. */ }
  void asyn_func( int, double )  { /* .. */ }</programlisting>
	</para>
      </note>
      <para>
	In the example above, there was aparantly no thread choosen.
	The default thread which executes asynchronous callbacks
	is called the <classname>ORO_CoreLib::CompletionProcessor</classname>. This is a non realtime
	thread, which means that the reaction time is not bounded.
	If you want to execute the callback in another thread,
	an additional argument can be given in the
	<methodname>connect</methodname> or <methodname>setup</methodname> method :
	<programlisting>
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::ZeroLatencyThread</classname>::Instance() );</programlisting>
	The above lists how the ZeroLatencyThread will execute the
	asyn_func if event is emit()'ed. It will do this after it has processed
	all its activities. The other Orocos threads can do this likewise :
	<programlisting>  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::ZeroTimeThread</classname>::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::NonRealTimeThread</classname>::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::CompletionProcessor</classname>::Instance() ); <emphasis>// Default</emphasis>
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::PriorityThread</classname>&lt;N&gt;::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, &amp;nonperiodic_activity );	</programlisting>
	If you would write above listings in a real program, on <function>
	  event.emit()</function>, the syn_func will be called directly
	five times. The asyn_func will be called in each thread once, possibly
	preempting itself.
      </para>
      <para>
	It is also possible to only have the asyn_func called. In this
	case the synopsis is :
	<programlisting>  event.connect( &amp;asyn_func, ZeroLatencyThread::Instance() );
	</programlisting>
	to distinguish from a synchronous callback connection. In this case
	there is no default, so if you wish to use the CompletionProcessor,
	you must specify it explicitly.
	<programlisting>  event.connect( &amp;asyn_func, CompletionProcessor::Instance() );
	</programlisting>
      </para>
      <para>
	For convenience, the Orocos Activity threads can also be choosen in another way
	by specifying the Activity :
	<programlisting>  NonPreemptibleActivity my_activity;
  event.connect(&amp;syn_func, &amp;asyn_func, &amp;my_activity );	</programlisting>
	or even :
	<programlisting>  RunnableInterface* my_function = ... ;
  // put my_function in a activity;
  event.connect(&amp;syn_func, &amp;asyn_func, my_function->getActivity() );</programlisting>
	The above says that the asyn_func function should be executed
	after the my_function's activity execution period.
	This is a very powerfull way of synchronising function calls
	in different threads. One should be aware that a Activity is
	not always executed with every period of the Thread, meaning
	that the asyn_func could be called before the activity is run,
	or even multiple times in between a activity run.
      </para>
      <note>
	<para>Asynchronous event handlers can have no more than
	6 arguments in the current implementation, but more
	can be easily added.</para>
      </note>
    </section>
    <section>
      <title>Private EventProcessors for Periodic Activities</title>
      <para>
	Asynchronous handlers are called in an <classname>ORO_CoreLib::EventProcessor</classname>.
	Each Orocos thread has such an EventProcessor to handle
	the deferred callbacks of all its activities. A Periodic activity
	can also have its a private EventProcessor which handles
	only its deferred callbacks after each step()
	and only when it is started. In this way, it resembles better
	how a non periodic activity handles its defered event callbacks.
	To enable this behavior,
	a boolean flag must be given upon construction of a <classname>ORO_CoreLib::PeriodicActivity</classname>
	or any derived activity-types :
      </para>
	<programlisting>  <classname>ORO_CoreLib::RunnableInterface</classname>* my_function = ... ;
  <classname>ORO_CoreLib::NonPreemptibleActivity</classname> myactivity( 0.01, my_function, true );     // enable private eventproc.

  event.connect(&amp;syn_func, &amp;asyn_func, my_function->getActivity() );
  
  event.emit(); // calls only syn_func.

  myactivity.start();
  event.emit(); // calls syn_func and after myactivity's step(), asyn_func.</programlisting>
       <para>
	 The private <classname>ORO_CoreLib::EventProcessor</classname> is disabled by default.
       </para>
    </section>
    <section>
      <title>Event Overrun Policy</title>
      <para>
	An Event can only be emit()'ed by one thread at the same time.
	The synchronous handlers will always be executed
	as much times as the event is emit()'ed. This is not the case
	for asynchronous handlers. If an Event is emit()'ed multiple
	times before the completion thread executes, the asynchronous
	handler will be called only once in the completion thread's execution
	step.
      </para>
      <para>
	The question that rises is with which arguments this handler
	is called. The user can choose between the first (default) and
	the last. The first is choosen as default because this causes the least
	overhead in execution time. To choose which policy is used,
	an optional parameter can be given during connect :
      </para>
      <programlisting>  event.connect( &amp;asyn_func, myactivity, Event::OnlyLast );
  event.connect( &amp;asyn_func, myactivity, Event::OnlyFirst ); // default
  event.connect( &amp;asyn_func, myactivity ); // same as previous line</programlisting>
    </section>
    <section>
      <title>The Completion Processor</title>
      <para>
	The <classname>ORO_CoreLib::CompletionProcessor</classname> is implemented using the
	Singleton design pattern, analogous to the
	periodic activity threads. It is the lowest priority, not realtime
	thread in the &orocos; framework. It will execute all
	asynchronous event callbacks that have to be completed when no other work has to
	be done. The only constraint it imposes is that all functions it
	executes must require finite time to complete (it cannot
	detect timeouts). You can get its thread pointer like this :
	<programlisting>  #include &lt;corelib/CompletionProcessor.hpp>

  CompletionProcessor::Instance()-> ... </programlisting>
      </para>
      <para>
	The CompletionProcessor is a NonPeriodicActivity, thus not consuming
	time resources when no Events need to be processed. If you need a 
	hard realtime CompletionProcessor, use a default NonPeriodicActivity ( see
	<xref linkend="activity-non-periodic" /> ) and call its makeHardRealTime() method.
      </para>
      <para>
	To create your own (hard real-time) Event completion processor, use a
	NonPeriodicActivity, it can be used to wait for Events (see
	<xref linkend="corelib-events" /> ). If a NonPeriodicActivity
	is not given a RunnableInterface, and it's methods are not
	overridden in a derived class, it will call it's
	EventProcessor's loop() method and wait for Asynchronous
	Events to process. If stop() is called in this case, the
	activity will break from the EventProcessor's loop() and be
	stopped. If you want to process Events in your own
	RunnableInterface implementation, you need to manually call
	the step() method of the processor() :
      </para>
      <programlisting>  // in your implementation :
  void loop() {
     while ( ... ) {
        // &lt; do non periodic stuff &gt;
   
        // process any pending Events :
        this->getActivity()->processor()->step();
     }
  }
  // ...  </programlisting>
       <para>
	 If you call <function>processor()->loop()</function> instead,
	 the EventProcessor will loop for events until it is stopped,
	 which might not be what you want. So use step() to process
	 all pending Events.
       </para>
    </section>
  </section>
  <section>
    <title>Time Measurement and Conversion</title>
    <section>
      <title>The TimeService</title>
      <para>
	The <classname>ORO_CoreLib::TimeService</classname> is implemented using the
	Singleton design pattern.
	You can query it for the current (virtual) time in clock ticks or in seconds.
	The idea here is that it is responsible for synchronising with other (distributed)
	cores, for doing, for example compliant motion with two robots. This functionality
	is not yet implemented though.
      </para>
      <para>
	When the <classname>ORO_CoreLib::SimulationThread</classname> is used and started, it will change the TimeService's
	clock with each period ( to simulate time progress).
	Also other threads (!) In the system will notice this change, but
	time is guaranteed to increase monotonously.
      </para>
    </section>
    <section>
      <title>Usage Example</title>
      <para>
	Also take a look at the interface documentation.
	<programlisting>  #include &lt;corelib/TimeService.hpp>
  #include &lt;corelib/Time.hpp>

  TimeService::ticks timestamp = <classname>ORO_CoreLib::TimeService</classname>::Instance()->getTicks();
  //...

  Seconds elapsed = TimeService::Instance()->secondsSince( timestamp );	</programlisting>
      </para>
    </section>
  </section>
  <section>
    <title>Attributes</title>
    <para>
      Attributes are class members which contain a (constant) value. Orocos
      can manipulate a classes attribute when it is wrapped in an
      <classname>ORO_CoreLib::Attribute</classname> class. This storage allows
      it to be read by the scripting engine, to be displayed on screen or manipulated
      over a network connection.
    </para>
    <para>
      The advantages of this class come clear when building Orocos Components,
      since it allows a component to export internal data. 
    </para>
    <para>
      <example><title>Creating attributes</title> 
	      <programlisting>
  // an attribute, respresening a double of value 1.0:
  <classname>ORO_CoreLib::Attribute</classname>&lt;double> myAttr(1.0);
  myAttr.set( 10.9 );
  double a = myAttr.get(); 

  // read-only attribute:
  <classname>ORO_CoreLib::Constant</classname>&lt;double> pi(3.14);
  double p = pi.get();
</programlisting>
      </example>
    </para>
  </section>
  <section>
    <title>Properties</title>
    <para>
      Properties are more powerful than attributes (above) since they can be
      stored to an XML format, be hierarchically structured and allow complex
      configuration. 
    </para>
    <section>
      <title>Introduction</title>
      <para>
	Orocos provides configuration by properties through the <classname>ORO_CoreLib::Property</classname>
	class.
	They are used to store primitive data (float, strings,...) in
	a hierachies (using <classname>ORO_CoreLib::PropertyBag</classname>). A Property can be changed by the user and has immediate
	effect on the behaviour of the program. Changing parameters of an
	algorithm is a good example where properties can be used. Each parameter
	has a value, a name and a description. The user can ask any PropertyBag
	for its contents and change the values as they see fit. Java for
	example presents a Property API. 
	The Doxygen Property API should
	provide enough information for succesfully using them in your Software Component.
	<note>
	  <para>
	    Reading and writing a properties value can be done in
	    realtime. Every other transaction, like marshalling
	    (writing to disk), demarshalling (reading from disk) or
	    building the property is not a realtime operation.
	  </para>
	  <para>
	    <example><title>Using properties</title> 
	      <programlisting>
  // a property, respresening a double of value 1.0:

  <classname>ORO_CoreLib::Property</classname>&lt;double> myProp("Parameter A","A demo parameter", 1.0); // not realtime !
  myProp = 10.9; // realtime
  double a = myProp.get(); // realtime  </programlisting>
	    </example>
	  </para>
	</note>
      </para>
      <para>
	Properties are mainly used for two purposes. First, they allow an external
	entity to browse their contents, as they can form hierarchies using
	PropertyBags. Second, they can be written to screen, disk,
	or any kind of stream and their contents can be restored lateron, for example
	after a system restart. The next sections give a short introduction to these
	two usages.
      </para>
    </section>
    <section>
      <title>Grouping Properties in a PropertyBag</title>
      <para>
	First of all, a PropertyBag is not the owner of the properties it owns,
	it merely keeps track of them, it defines a logical group of properties
	belonging together. Thus when you delete a bag, the properties in it are
	not deleted, when you clone() a bag, the properties are not cloned
	themselves. PropertyBag is thus a container of pointers to Property objects.
      </para>
      <para>
	If you want to duplicate the contents of a PropertyBag or perform recursive
	operations on a bag, you can use the helper functions we created and which
	are defined in <filename>PropertyBag.hpp</filename> (see Doxygen documentation).
	These operations are however, most likely not realtime.
      </para>
      <note><para>When you want to put a PropertyBag into another PropertyBag, you need
      to make a Property&lt;PropertyBag&gt; and insert that property into the 
      first bag.</para>
      </note>
      <para> Use <methodname>add</methodname> to add Properties to a bag and 
      <methodname>find</methodname> or <methodname>getProperty&lt;T&gt;</methodname> to
      get a pointer to a <classname>ORO_CoreLib::PropertyBase</classname> or <classname>ORO_CoreLib::Property</classname>&lt;T&gt; :
	<programlisting>  <classname>ORO_CoreLib::PropertyBag</classname> bag;
  <classname>ORO_CoreLib::Property</classname>&lt;double&gt; w("Weight", "in kilograms", 70.5 );
  <classname>ORO_CoreLib::Property</classname>&lt;int&gt; pc("PostalCode", "", 3462 );

  struct BirthDate {
     BirthDate(int d, month m, int y) : day(d), month(m), year(y) {}
     int day;
     enum { jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec} month;
     int year;
  };

  <classname>ORO_CoreLib::Property</classname>&lt;BirthDate&gt; bd("BirthDate", " in 'BirthDate' format", BirthDate(1, apr, 1977));

  bag.add( &amp;w );
  bag.add( &amp;pc );
  bag.add( &amp;bd );
	
  <classname>ORO_CoreLib::PropertyBase</classname>* weight = bag.find("PostalCode");    // assert( weight != 0 )

  <classname>ORO_CoreLib::Property</classname>&lt;BirthDate&gt;* bd_bis = bag.getProperty&lt;BirthDate&gt;("BirthDate"); // assert( bd_bis != 0 )
	</programlisting>
      </para>
    </section>
    <section>
      <title>Marshalling and Demarshalling Properties (Serialization)</title>
      <para>
	Marshalling is converting a property C++ object to a format
	suitable for transportation or storage, like XML Demarshalling
	reconstructs the property again from the stored format. In
	Orocos, the <classname>ORO_CoreLib::Marshaller</classname>
	interface defines how properties can be marshalled.  The
	available marshallers (property to file) in Orocos are the
	<classname>ORO_CoreLib::SimpleMarshaller</classname>,
	<classname>ORO_CoreLib::XMLMarshaller</classname>,
	<classname>ORO_CoreLib::XMLRPCMarshaller</classname>,
	<classname>ORO_CoreLib::INIMarshaller</classname> and the
	<classname>ORO_CoreLib::CPFMarshaller</classname>.  
      </para>
      <para>
	The inverse operation (file to property) is currently
	supported by only two demarshallers:
	<classname>ORO_CoreLib::SimpleDemarshaller</classname> and the
	<classname>ORO_CoreLib::CPFDemarshaller</classname>.  They
	implement the <classname>ORO_CoreLib::Demarshaller</classname>
	interface.
      </para>
      <para>
	The (de-)marshallers know how to convert native C++ types, but if you want
	to store your own classes in a Property ( like <classname>BirthDate</classname>
	in the example above ), the class must be added to the Orocos
	type system.
      </para>
    </section>
  </section>
  <section>
    <title>The NameServer</title>
    <section>
      <title>Introduction</title>
      <para>
	A useful element in the &orocos; framework is what we call the strong typed
	nameserver. It is a (string based) nameserver which stores name, object pairs
	of only one type of object in the local program. 
	Off course, polymorphism allows us to collect many
	derivative types into one nameserver. A nameserver allows late configuration
	of objects. All possible used objects are created first and stored in the
	nameserver. Depending of the run-time users choice (from a text file,
	console input,...), another object is retrieved from the nameserver and
	used in the program.
      </para>
    </section>
    <section>
      <title>Using the NameServer</title>
      <para>
	The local object server is called
	<classname>ORO_CoreLib::NameServer</classname>.  The most
	common usage syntax is given below.
      </para>
      <note><para>
	The most common use of nameserving is keeping track of pointers to objects.
	A NameServer almost always takes pointers to an object as arguments and 
	returns a pointer when the object is looked up again.</para>
      </note>
      <programlisting>  // A NameServer collecting pointers to ClassA objects
  <classname>ORO_CoreLib::NameServer</classname>&lt; ClassA* &gt; nameserver;
  ClassA my_a;
  nameserver.registerObject( &amp;my_a, "ATeam" );
  // ...
  ClassA* an_a = nameserver.getObject( "ATeam" );
  if (an_a != 0 )
      cout &lt;&lt; "ATeam was successfully stored and retrieved !" &gt;&gt; endl;     </programlisting>
      <para>
	A typical use of nameserving is that the nameserver is nested inside the class
	it is nameserving itself. For convenience, the constructor of that class is then
	extended to take a string as argument to indicate the (optional) desired name
	of the object. Imagine that the above ClassA had such a nested nameserver,
	in that case, it would be used as follows :
      </para>
      <programlisting>  ClassA my_a( "The ATeam" ); // give name in constructor
  // ...
  // notice the scope ClassA:: the nameserver is nested in :
  ClassA* an_a = ClassA::nameserver.getObject( "The ATeam" );
  if (an_a != 0 )
    cout &lt;&lt; "The ATeam was successfully stored and retrieved !" &gt;&gt; endl;     </programlisting>
      <para>
	The above technique is used in many classes inside &orocos;. Events, Devices, 
	Control Kernels and Components, ... anything you wish to configure at runtime
	can be nameserved.
      </para>
    </section>
  </section>
  <section>
    <title>Buffers and DataObjects</title>
    <para>
      Orocos provides some basic inter-thread buffering mechanisms in the
      <filename>corelib/buffers</filename> package.
    </para>
    <para>
      The difference between Buffers and DataObjects is that DataObjects
      always contain a single value, while buffers may be empty, full or contain
      a number of values.
      Thus a <classname>ORO_CoreLib::DataObject</classname> always returns the last value written (and a
      write always succeeds), while a buffer
      may implement a FIFO queue to store all written values (and thus can get full).
    </para>
    <figure><title>DataObjects versus Buffers</title>
    <mediaobject>
      <imageobject>
	<imagedata fileref="DataObjectBuffer" />
      </imageobject>
      <caption><para>DataObjects are most suitable for single writer, many readers,
      and always return the last written value. Buffers have a fixed queue length
      and are used for processing all produced data by any number of producers and
      consumers.
      </para></caption>
    </mediaobject>
    </figure>
    <section id="corelib-buffers">
      <title>Buffers</title>
      <para>
	The <classname>ORO_CoreLib::BufferInterface</classname>&lt;T&gt; provides
	the interface for Orocos buffers. Currently the <classname>ORO_CoreLib::BufferLockFree</classname>&lt;T&gt;
	is a typed buffer of type <emphasis>T</emphasis> and works as
	a FIFO queue for storing elements of type T.
	It is lock-free, non blocking and read and writes
	happen in bounded time. It is not subject to priority inversions.
      </para>
	<example>
	  <title>Accessing a Buffer</title>
	  <programlisting>  #include &lt;corelib/BufferLockFree.hpp>

  // A Buffer may also contain a class, instead of the simple
  // double in this example
  // A buffer with size 10:
  <classname>ORO_CoreLib::BufferLockFree</classname>&lt;double> my_Buf( 10 ); 
  if ( my_Buf.Push( 3.14 ) ) {
     // ok. not full.
  }
  double  contents; 
  if ( my_Buf.Pop( contents ) ) {
     // ok. not empty.
     // contents == 3.14
  }</programlisting></example>
       <para>
	 Both <function>Push()</function> and <function>Pop()</function>
	 return a boolean to indicate failure or success.
       </para>
    </section>
    <section id="corelib-data-objects">
      <title>DataObjects</title>
      <para>
	The data inside the <classname>ORO_CoreLib::DataObject</classname>s can be any valid C++ type,
	so mostly people use classes or structs, because these carry
	more semantics than just (vectors of) doubles. The default
	constructor of the data is called when the DataObject is
	constructed.  Here is an example of creating and using a
	DataObject :
	<example>
	  <title>Accessing a DataObject</title>
	  <programlisting>  #include &lt;corelib/DataObjectInterfaces.hpp>

  // A DataObject may also contain a class, instead of the simple
  // double in this example
  <classname>ORO_CoreLib::DataObjectLockFree</classname>&lt;double> my_Do("MyData"); 
  my_Do.Set( 3.14 ); 
  double  contents; 
  my_Do.Get( contents );   // contents == 3.14
  contents  = my_Do.Get(); // equivalent  </programlisting>
	</example>
      </para>
      <para>
	The virtual <classname>ORO_CoreLib::DataObjectInterface</classname> interface
	provides the <function>Get()</function> and
	<function>Set()</function> methods that each DataObject must
	have. Semantically, <function>Set()</function> and
	<function>Get()</function> copy all contents of the
	DataObject.
      </para>
    </section>
  </section>
  <section id="core-logging">
    <title>Logging</title>
    <para>
      Orocos applications can have pretty complex startup and
      initialisation code.  A logging framework, using
      <classname>ORO_CoreLib::Logger</classname> helps to track what
      your program is doing.
    </para>
      <note><para>Logging can
      only be done in the non-realtime parts of your application, thus not in
	the Realtime Periodic Activities !</para></note>
    <para>
      There are currently 8 loglevels :
      <table>
	<title>Logger Log Levels</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>ORO_LOGLEVEL</entry>
	      <entry>Logger::enum</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>-1</entry>
	      <entry>na</entry>
	      <entry>Completely disable logging</entry>
	    </row>
	    <row>
	      <entry>0</entry>
	      <entry>Logger::Never</entry>
	      <entry>Never log anything (to console)</entry>
	    </row>
	    <row>
	      <entry>1</entry>
	      <entry>Logger::Fatal</entry>
	      <entry>Only log Fatal errors. System will abort immediately.</entry>
	    </row>
	    <row>
	      <entry>2</entry>
	      <entry>Logger::Critical</entry>
	      <entry>Only log Critical or worse errors. System may abort shortly after.</entry>
	    </row>
	    <row>
	      <entry>3</entry>
	      <entry>Logger::Error</entry>
	      <entry>Only log Errors or worse errors. System will come to a safe stop.</entry>
	    </row>
	    <row>
	      <entry>4</entry>
	      <entry>Logger::Warning</entry>
	      <entry>[Default] Only log Warnings or worse errors. System will try to resume anyway.</entry>
	    </row>
	    <row>
	      <entry>5</entry>
	      <entry>Logger::Info</entry>
	      <entry>Only log Info or worse errors. Informative messages.</entry>
	    </row>
	    <row>
	      <entry>6</entry>
	      <entry>Logger::Debug</entry>
	      <entry>Only log Debug or worse errors. Debug messages.</entry>
	    </row>
	    <row>
	      <entry>7</entry>
	      <entry>Logger::RealTime</entry>
	      <entry>Log also messages from possibly Real-Time contexts. Needs to be confirmed
	      by a function call to Logger::allowRealTime().</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </para>
    <para>
      You can change the amount of log info printed on your console by setting the environment variable
      <envar>ORO_LOGLEVEL</envar> to one of the above numbers :
      <screen>
  export ORO_LOGLEVEL=5</screen>
      The default is level 4, thus only warnings and errors are printed.
    </para>
    <para>
      The <emphasis>minimum</emphasis> log level for the <filename>orocos.log</filename>
      file is <parameter>Logger::Info</parameter>. It will get more verbose if
      you increase <envar>ORO_LOGLEVEL</envar>, but will not go below Info. 
      This file is always created if the logging infrastructure is used. You can inspect this file
      if you want to know the most usefull information of what is happening inside Orocos.
    </para>
    <para>If you want to disable logging completely, use <screen>export ORO_LOGLEVEL=-1</screen>
      before you start your program.</para>
    <para>
      For using the <classname>ORO_CoreLib::Logger</classname> class in your own application, consult
      the API documentation.
    </para>
    <example>
      <title>Using the Logger class</title>
      <programlisting>  #include &lt;corelib/Logger.hpp>

  Logger::In in("MyModule");
  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; Logger::Error &lt;&lt; "An error Occured : " &lt;&lt; 333 &lt;&lt; "." &lt;&lt; Logger::endl;
  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; Logger::Debug &lt;&lt; debugstring &lt;&lt; data &lt;&lt; Logger::endl;
  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; " more debug info." &lt;&lt; data &lt;&lt; Logger::endl;</programlisting>
      <para>As you can see, the Logger can be used like the standard C++ input streams.
	You may change the Log message's level using the <classname>ORO_CoreLib::Logger::...</classname>
	enums. The above message could result in :
      </para>
      <screen>
  0.123 [ ERROR  ][MyModule] An error Occured : 333
  0.124 [ Debug  ][MyModule] &lt;contents of debugstring and data >
  0.125 [ Debug  ][MyModule]  more debug info. &lt;...data...> </screen>
    </example>
  </section>
  <section>
    <title>The Orocos Type System : Toolkits</title>
    <para>
      Most applications define their own classes or structs to exchange
      data between objects. It is possible to tell Orocos about these
      user defined types such that they can be displayed, stored to XML,
      used in the scripting engine or even transfered over a network
      connection.
    </para>

    <section>
      <title>The Real-Time Toolkit</title>
      <para>
	Orocos uses the 'Toolkit' principle to make it aware of user
	types. Orocos' Real-Time Toolkit already provides support for
	the C++ types <classname>int</classname>,<classname>unsigned
	int</classname>,<classname>double</classname>,
	<classname>char</classname>,<classname>bool</classname>,<classname>float</classname>,
	<classname>std::vector&lt;double&gt;</classname> and
	<classname>std::string</classname>.
      </para>
      <para>
	A toolkit can be imported into the application by writing:
	<programlisting>  #include &lt;corelib/RealTimeToolkit.hpp>
  // ...
  RTT::Toolkit::Import( RTT::RealTimeToolkit );	</programlisting>
	This is however done automatically, unless you disabled that
	option in the configuration system. After this line is executed,
	Orocos is able to display, transfer over a network or recognise
	these types in scripts.
      </para>
    </section>
    <section>
      <title>Telling Orocos about your data</title>
      <para>
	Say that you have an application which transfers data
	in a struct <classname>ControlData</classname> :
	<programlisting>  struct ControlData {
    double x, y, z;
    int sample_nbr;
  }</programlisting>
        How can you tell Orocos how to handle this type ? A helper
	class is provided which you can extend to fit your needs,
	<classname>ORO_CoreLib::TemplateTypeInfo</classname>.
	<programlisting>  #include &lt;corelib/TemplateTypeInfo.hpp>
  // ...
  struct ControlDataTypeInfo
    : public ORO_CoreLib::TemplateTypeInfo&lt;ControlData>
  {
     ControlDataTypeInfo
        : ORO_CoreLib::TemplateTypeInfo&lt;ControlData>("ControlData")
     {}
  };

  // Tell Orocos the name and type of this struct:
  ORO_CoreLib::Types::Instance()->addType( new ControlDataTypeInfo() );
	</programlisting>
	From now on, Orocos knows the 'ControlData' type name and allows
	you to create a scripting variable of that type. It does however
	not know yet how to display it or write it to an XML file.
      </para>
      <section>
	<title>Displaying</title>
	<para>
	  In order to tell Orocos how to display your type, you
	  may overload the <function>TemplateTypeInfo::write</function> fuction
	  or define <function>operator&lt;&lt;()</function> for your type:
	</para>
	<programlisting>  #include &lt;corelib/TemplateTypeInfo.hpp>
  #include &lt;ostream>

  std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const ControlData&amp; cd) {
     return os &lt;&lt; '('&lt;&lt; cd.x &lt;&lt; cd.y &lt;&lt; cd.z &lt;&lt; '): ' &lt;&lt; cd.sample_nbr;
  }
  // ...
  // 'true' argument: <emphasis> it has operator&lt;&lt;</emphasis>
  struct ControlDataTypeInfo
    : public ORO_CoreLib::TemplateTypeInfo&lt;ControlData,<emphasis>true</emphasis>>
  {
     ControlDataTypeInfo
        : ORO_CoreLib::TemplateTypeInfo&lt;ControlData,<emphasis>true</emphasis>>("ControlData")
     {}
  };

  // Tell Orocos the name and type of this struct
  ORO_CoreLib::Types::Instance()->addType( new ControlDataTypeInfo() );
	</programlisting>
	<para>
	  If you use the above line of code to add the type, Orocos will be
	  able to display it as well, for example in the TaskBrowser or
	  in the ReportingComponent.
	</para>
      </section>
      <section>
	<title>Writing to XML</title>
	<para>
	  In order to inform Orocos of the structure of your data type,
	  it must be given a 'decompose' function: Of which primitive types
	  does the struct consists ? Representing structured data is what
	  Orocos <classname>ORO_CoreLib::Property</classname> objects do.
	  Here is how to tell Orocos how the "ControlData" is structured:
	</para>
	<programlisting>  // ...
  struct ControlDataTypeInfo
    : public TemplateTypeInfo&lt;ControlData,true>
  {
     // ... other functions omitted

     virtual bool decomposeTypeImpl(const ControlData&amp; in, PropertyBag&amp; targetbag ) const {
         targetbag.setType("ControlData");
         targetbag.add( new Property&lt;double>("X", "X value of my Data", in.x ) );
         targetbag.add( new Property&lt;double>("Y", "Y value of my Data", in.y ) );
         targetbag.add( new Property&lt;double>("Z", "Z value of my Data", in.z ) );
         targetbag.add( new Property&lt;int>("Sample", "The sample number of the Data", in.sample_nbr ) );
         return true;
     }
  }</programlisting>
        <para>
	  That was easy ! For each member of your struct, add a
	  <classname>ORO_CoreLib::Property</classname> of the correct
	  type to the targetbag and you're done !
	  <function>setType()</function> can be used lateron to
	  determine the version or type of your XML representation.  Next,
	  if Orocos tries to write an XML file with ControlData in it,
	  it will look like:
	</para>
	<programlisting>
<![CDATA[  <struct name="MyData" type="ControlData">
    <simple name="X" type="double">
       <description>X value of my Data</description>
       <value>0.12</value>
    </simple>
    <simple name="Y" type="double">
       <description>Y value of my Data</description>
       <value>1.23</value>
    </simple>
    <simple name="Z" type="double">
       <description>Z value of my Data</description>
       <value>3.21</value>
    </simple>
    <simple name="Sample" type="short">
       <description>The sample number of the Data</description>
       <value>3123</value>
    </simple>
  </struct>]]>
	</programlisting>
      </section>
      <section>
	<title>Reading from XML</title>
	<para>
	  Orocos does not know yet how to convert an XML format back
	  to the ControlData object. This operation is called 'composition'
	  and is fairly simple as well:
	  Here is how to tell Orocos how the "ControlData" is read:
	</para>
	<programlisting>  // ...
  struct ControlDataTypeInfo
    : public TemplateTypeInfo&lt;ControlData,true>
  {

     // ... other functions omitted

     virtual bool composeTypeImpl(const PropertyBag&amp; bag, ControlData&amp; out ) const 
     {
        if ( bag.getType() == std::string("ControlData") ) // check the type
        {  
          Property&lt;double>* x = targetbag.getProperty&lt;double>("X");
          Property&lt;double>* y = targetbag.getProperty&lt;double>("Y");
          Property&lt;double>* z = targetbag.getProperty&lt;double>("Z");
          Property&lt;int>* t = targetbag.getProperty&lt;int>("Sample");

	  if ( !x || !y || !z || !t )
	     return false;

          out.x = x->get();
          out.y = y->get();
          out.z = z->get();
          out.sample_nbr = t->get();
          return true;
        }
        return false; // unknown type !
     }
  }</programlisting>
        <para>
	  First the properties are located in the bag, it should look just
	  like we stored them. If not, return false, otherwise, read the
	  values and store them in the out variable.
	</para>
      </section>
      <section>
	<title>Network transfer (CORBA)</title>
	<para>
	  In order to transfer your data between components over a
	  network, Orocos requires that you provide the conversion
	  from your type to a CORBA::Any type and back, quite similar
	  to the 'composition' and 'decomposition' of your data.
	  Look at the <classname>ORO_CoreLib::TemplateTypeInfo</classname>
	  interface for the functions you need to implement.
	</para>
	<para>
	  The first step is describing your struct in IDL and generate
	  the 'client' headers with 'Any' support. Next you
	  create such a struct, fill it with your data type's data
	  and next 'stream' it to an Any. The other way around is
	  required as well.
	</para>
	<para>
	  In addition, you will need the CORBA support of Orocos
	  enabled in your build configuration.
	</para>
      </section>
      <section>
	<title>Advanced types</title>
	<para>
	  In order to add more complex types, take a look at the
	  code of the RealTimeToolkit and the GeometryToolkit of Orocos.
	</para>
      </section>
    </section>
    <section>
      <title>Building your own Toolkit</title>
      <para>
	The number of types may grow in your application to such
	a number or diversity that it may be convenient to 
	build your own toolkit and import them when appropriate.
	Non-Orocos libraries benefit from this system as well because
	they can introduce their data types into Orocos.
      </para>
      <para>
	Each toolkit must inherit from the <classname>ORO_CoreLib::ToolkitPlugin</classname>
	class and implement three functions: <function>loadTypes()</function>,
	<function>loadOperators()</function> and <function>getName()</function>.
      </para>
      <para>
	The name of a toolkit must be unique. Each toolkit will be loaded
	no more than once. The loadTypes function contains all 
	'TemplateTypeInfo' constructs to tell Orocos about the types
	of your toolkit. The loadOperators function contains all
	operations that can be performed on your data such as addition ('+'),
	indexing ('[i]'), construction ('vector(1.0,2.0,3.0)'),
	comparison ('==') etc.
      </para>
      <para>
	Mimick the code of the
	<classname>ORO_CoreLib::RealTimeToolkit</classname> and
	<classname>ORO_CoreLib::GeometryToolkit</classname> to build
	your own.
      </para>
    </section>
  </section>
</article>
