<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.ac.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>The Orocos Core Library Manual</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002-2006</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the principles of the
	<emphasis>Core Library</emphasis> of &orocos;, the <emphasis>Open
	RObot COntrol Software</emphasis> project. The CoreLib provides
	infrastructural support for the functional and application components
	of the &orocos; framework.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>22 Aug 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.9</revnumber>
	<date>11 Nov 2002</date>
	<authorinitials>ps</authorinitials>
	<revremark>lots of updates</revremark>
      </revision>
      <revision>
	<revnumber>0.11</revnumber>
	<date>29 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Stripped Devices and OS parts</revremark>
      </revision>
      <revision>
	<revnumber>0.12</revnumber>
	<date>2 Apr 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>StateMachine updates</revremark>
      </revision>
      <revision>
	<revnumber>0.13</revnumber>
	<date>18 May 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>Change in the StateMachine interface</revremark>
      </revision>
      <revision>
	<revnumber>0.14</revnumber>
	<date>2 June 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>Clarified some parts based on feedback</revremark>
      </revision>
      <revision>
	<revnumber>0.18</revnumber>
	<date>10 Dec 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>New Event Implementation and Simulation Thread. Reordering and cleanup of Sections.</revremark>
      </revision>
      <revision>
	<revnumber>0.18.1</revnumber>
	<date>5 Jan 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added Logging Framework.</revremark>
      </revision>
      <revision>
	<revnumber>0.20.0</revnumber>
	<date>31 Jan 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added DataObject section within Buffer section. Added TaskNonPeriodic.</revremark>
      </revision>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>15 Feb 2006</date>
	<authorinitials>ps</authorinitials>
	<revremark>Removed Fifo section. Split off developer specific info.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <sect1>
    <title>Introduction</title>
    <para>
      This Chapter describes the semantics of the services
      available in the &orocos; CoreLib Package.
    </para>
    <para>
      The CoreLib provides:
      <itemizedlist>
	<listitem><para>Thread-safe C++ implementations for (periodic) tasks</para></listitem>
	<listitem><para>Synchronous/Asynchronous Events</para></listitem>
	<listitem><para>Time measurement</para></listitem>
	<listitem><para>Application logging and reporting</para></listitem>
	<listitem><para>Properties and XML configuration</para></listitem>
	<listitem><para>Lock-free data exchange primitives such as fifo buffers or shared data.</para></listitem>
      </itemizedlist> 
      and additionally provides interfaces which are common for all realtime services.
      The CoreLib imposes a hard realtime <emphasis>architecture</emphasis>:
    </para>
    <blockquote>
      <para>
	<emphasis> The goal of this fixed architecture is to keep 
	applications deterministic, by avoiding the classical pitfalls of
	letting application programmers freely choose the priorities of their
	tasks, and their communication primitives. Practice has indeed showed
	that most programmers do not succeed in strictly decoupling the
	functional and algorithmic parts of their code from the OS-specific
	primitives used to execute them.</emphasis>
      </para>
    </blockquote>
    <para>
      Of course, the realtime performance depends not only on
      the underlying operating system 
      <emphasis>but also on the hardware.</emphasis> Hardware devices are abstracted
      in the Orocos Device Interface package.
    </para>
    <para>
      The following sections will first introduce the reader to creating
      (periodic) Tasks in the system. Furtheron, they are extended
      with Events. The following sections explain usefull classes which
      are used throughout the framework such as the TimeService,
      Properties and the object NameServer.
    </para>
  </sect1>
  <sect1>
    <title>Periodic and non Periodic Tasks</title>
    <note>
      <para>In future versions of Orocos the CoreLib 'Task' classes may
      be renamed to 'Activity' in order to avoid confusion with the
      higher level 'TaskContext' concept.</para>
    </note>
    <para>
      Threads are the major cause of headaches in multithreaded
      systems programmers heads. Synchronisation, data protection,
      priority tweaking and resource locking must all be done very
      carefully and mostly lead to suboptimal solutions. Even more,
      the predictability of the system highly decreases with the
      introduction of more threads or interactions between threads.
      This section gives an introduction to defining periodic tasks
      which run together with other periodic tasks of the
      same priority in the same periodic thread. Non 
      are implemented using a non periodic thread.
    </para>
    <sect2>
      <title>Periodic Tasks Run in Periodic Threads</title>
      <para>
	A basic control application needs for example, a high priority periodic thread
	and a low priority periodic thread. The high priority thread is
	used for all periodic tasks that need to be executed atomically. No
	action in this thread will ever be preempted by another thread. The low
	priority realtime thread is used for all periodic tasks which may be
	preempted but still have hard deadlines. It can always be
	preempted by the high priority thread. There is also a non
	realtime (periodic) thread which gives no deadline guarantees. 
	For convenience, Orocos provides implementations for these three types of threads 
	( which only differ in periodicity and priority ) and allows
	to extend to more for your specific needs.
      </para>
    </sect2>
    <sect2>
      <title>Creating a Periodic Thread</title>
      <para>
	Orocos provides, by default, two hard realtime periodic threads and
	a non realtime periodic thread. The <classname>ORO_CoreLib::ZeroTimeThread</classname>
	has the highest priority, the <classname>ORO_CoreLib::ZeroLatencyThread</classname>
	has a lower priority and the <classname>ORO_CoreLib::NonRealTimeThread</classname>
	has an even lower priority is not realtime at all (but still periodic).
	If they are needed, Orocos will create and start/stop them automatically,
	thus the user does not need to know or take care of them. 
      </para>
      <important>
	<para>
	  You must configure the priority and periodicity of these three threads
	  in the configtool program.
	</para>
      </important>
      <para>
	For users needing to solve multi-threaded control problems, the
	PriorityThread is provided with which you
	can create an arbitrary number of threads with no more than
	one thread per priority level. It needs a bit more setup than
	the standard Orocos threads, since you still have to set the
	priority and start the thread. An example is given below. 
	A PriorityThread is not automatically started like the ZeroTimeThread,
	ZeroLatencyThread and NonRealTimeThread. It must be done by the
	user. Furthermore, The <classname>ORO_CoreLib::PriorityThread</classname> is the general case of the
	above three cases, since its priority can match their priorities
	as given in the configuration tool.</para>
      <para>
	<example>
	<title>Example Periodic Thread Creation</title>
	<para>
	    This example shows how to create the PriorityThread.
	</para>
	<programlisting>#include "corelib/PriorityTask.hpp"

using namespace ORO_CoreLib;

class KineLoop : public <classname>ORO_CoreLib::RunnableInterface</classname>
{
    bool initialize() { // ...
    }
    void step() {
    }
    void finalize() {
    }
    // ...
};

ORO_main( int argc, char** argv)
{
  // Define your tasks (see later)
  KineLoop kine_loop;

  // An extra thread for low priority tasks
  // 9 : The priority.
  // 0.01 : The period.
  // You have to manually start the thread.
  <classname>ORO_CoreLib::PriorityThread</classname>&lt;9>::Instance()->setPeriod( 0.01 );
  <classname>ORO_CoreLib::PriorityThread</classname>&lt;9>::Instance()->start();
  // Optional :
  <classname>ORO_CoreLib::PriorityThread</classname>&lt;9>::Instance()->makeHardRealtime();

  // This task is run in the extra thread above,
  // kine_loop inherits from RunnableInterface :
  <classname>ORO_CoreLib::PriorityTask</classname>&lt;9> own_task( 0.05, &amp;kine_loop ); // 0.05 is multiple of 0.01

  own_task->start();

  // ...

  own_task->stop();

  return 0;
}</programlisting>
      </example>
      </para>
    </sect2>
    <sect2>
      <title>Creating a Periodic Task</title>
      <para>
	If you want to execute functionality in one of the Orocos threads, you need to 
	create a Task of a certain type, depending on the thread type. The table
	below summarises which Task type there is per thread.
	<table>
	  <title>Thread and Task summary</title>
	  <!-- one of (graphic mediaobject tgroup) -->
	  <tgroup cols="2">
	    <thead>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>Thread</entry>
		<entry>Task</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><classname>ORO_CoreLib::TimerThread</classname></entry>
		<entry><classname>ORO_CoreLib::PeriodicTask</classname></entry>
		<!-- one of (entrytbl entry) -->
	      </row>
	      <row>
		<entry><classname>ORO_CoreLib::ZeroTimeThread</classname></entry>
		<entry><classname>ORO_CoreLib::TaskNonPreemptible</classname></entry>
		<!-- one of (entrytbl entry) -->
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::ZeroLatencyThread</classname></entry>
		<entry><classname>ORO_CoreLib::TaskPreemptible</classname></entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::NonRealTimeThread</classname></entry>
		<entry><classname>ORO_CoreLib::TaskNonRealTime</classname></entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::PriorityThread</classname></entry>
		<entry><classname>ORO_CoreLib::PriorityTask</classname></entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry><classname>ORO_CoreLib::SimulationThread</classname></entry>
		<entry><classname>ORO_CoreLib::SimulationTask</classname></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table></para>
      <para>
	There are two ways to run functionality in a periodic task. By :
	<itemizedlist>
	  <listitem>
	    <para>
	      Implementing the <classname>ORO_CoreLib::RunnableInterface</classname>  in another class
	      ( functions initialize, step or loop/breakLoop and finalize ). The RunnableInterface object (i.e. run_impl) can
	      be assigned to a task using <synopsis> task.run( &amp;run_impl )</synopsis> or
	      at construction time of a Task : <synopsis> TaskNonPreemptible task( period, &amp;run_impl );</synopsis>.
	      <programlisting>  #include &lt;corelib/RunnableInterface.hpp>
  #include &lt;corelib/TaskNonPreemptible.hpp>

  class MyPeriodicTask
	: public <classname>ORO_CoreLib::RunnableInterface</classname>
  {
  public:
    // ...
    bool initialize() {
       // your init stuff
       myperiod = this->getTask()->getPeriod();
       isperiodic = this->getTask()->isPeriodic();
       
       // ...
       return true; // if all went well
    }

    // executed when isPeriodic() == true
    void step() {
       // periodic actions
    }

    // executed when isPeriodic() == false
    void loop() {
       // 'blocking' version of step(). Implement also breakLoop()
    }

    void finalize() {
       // cleanup
    }
  };

  // ...
  MyPeriodicTask run_impl_1;
  MyPeriodicTask run_impl_2;

  <classname>ORO_CoreLib::TaskNonPreemptible</classname> task( 0.01 ); // 100Hz
  task.run( &amp;run_impl_1 );
  task.start(); // calls 'step()'

  <classname>ORO_CoreLib::TaskNonPeriodic</classname> nptask(12); // priority = 12
  nptask.run( &amp;run_impl_2);
  task.start(); // calls 'loop()'

  // etc...  </programlisting>
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Inheriting from a Task class and overriding the initialize, step
	      and finalize methods.
	      <programlisting>
  class MyOtherPeriodicTask
      : public <classname>ORO_CoreLib::TaskNonPreemptible</classname>
  {
  public :
    MyOtherPeriodicTask()
      : <classname>ORO_CoreLib::TaskNonPreemptible</classname>( 0.01 ) // 100Hz
    {
    }

    bool initialize() {
       // your init stuff
       double myperiod = this->getPeriod();
       // ...
       return true; // if all went well
    }

    void step() {
       // periodic actions
    }

    void finalize() {
       // cleanup
    }
	// ...
  };

  // When started, will call your step
  MyOtherPeriodicTask task;
  task.start();  </programlisting>
	    </para>
	  </listitem>
	</itemizedlist>
	The Task will detect if it must run an external RunnableInterface. If none
	was given, it will call its own virtual methods.
      </para>
    </sect2>
    <sect2>
      <title>Periodic Task Ordering</title>
      <para>
	Periodic Tasks are executed <emphasis>in the order as they are started</emphasis>.
	The periodic thread responsible
	for the Task will execute all tasks one after the other, respecting
	the periodicity of the periodic task. This means that a Task with a lower periodicity
	of the thread (e.g. 10 times lower) will only be called a fraction of the
	time (thus every 10th period), still respecting the ordering.
      </para>
      <para>
	<figure><title>Execution sequence diagram</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="execution-sequence" />
	    </imageobject>
	    <!--
	    <caption><para>
	  </para></caption>
	    -->
	  </mediaobject>
	</figure>
      </para>
    </sect2>
    <sect2>
      <title>Example Periodic Task Creation</title>
      <example>
	<title>Example Periodic Task Creation</title>
	<para>
	  This example shows how all kinds of tasks can be created. When a task
	  is started it will add itself to the correct thread.
	</para>
	<programlisting>#include "corelib/TaskNonPreemptible.hpp"
#include "corelib/TaskPreemptible.hpp"
#include "corelib/TaskNonRealTime.hpp"
#include "corelib/PriorityTask.hpp"

using namespace ORO_CoreLib;

ORO_main( int argc, char** argv)
{
  // Define your tasks

  // ...

  // These tasks are run in the Orocos Thread Model
  <classname>ORO_CoreLib::TaskNonPreemptible</classname> fast_task1(0.001, &amp;vel_loop);
  <classname>ORO_CoreLib::TaskNonPreemptible</classname> fast_task2(0.001, &amp;vel_loop);

  <classname>ORO_CoreLib::TaskPreemptible</classname> slow_task(0.01, &amp;pos_loop);
  <classname>ORO_CoreLib::TaskNonRealTime</classname> nrt_task( 0.1, &amp;display_server );

  // This task is run in the extra thread above
  <classname>ORO_CoreLib::PriorityTask</classname>&lt;9> own_task( 0.05, &amp;kine_loop ); // 0.05 is multiple of 0.01

  // All is transparant from here on.
  fast_task1->start();
  fast_task2->start(); // is always run directly after fast_task1 !
  slow_task->start();
  own_task->start();
  nrt_task->start();

  // ...

  fast_task1->stop();
  fast_task2->stop();
  slow_task->stop();
  own_task->stop();
  nrt_task->stop();

  return 0;
}</programlisting>
      </example>
    </sect2>
    <sect2>
      <title>Periodic Threads Overview</title>
      <para>
	The high priority thread is the
	<classname>ORO_CoreLib::ZeroTimeThread</classname>. It will execute all
	<classname>ORO_CoreLib::TaskNonPreemptible</classname> Tasks
	synchronically. You can create your own not preemptable task by
	inheriting from this class. Its name is derived from the fact
	that some tasks need to be executed in an infinite small
	amount of time to work correctly. Control loops are an example
	of this. To come as close as possible to this (impossible)
	constraint, we make sure that the task is never preempted by
	another task and thus is executed 'atomically'.
      </para>
      <para>
	The low priority tasks are executed by the
	<classname>ORO_CoreLib::ZeroLatencyThread</classname> class. It will
	execute all <classname>ORO_CoreLib::TaskPreemptible</classname> Tasks
	sequentially, when no non-preemptible tasks are executed.
	Every <classname>ORO_CoreLib::TaskPreemptible</classname> can be preempted
	by a <classname>ORO_CoreLib::TaskNonPreemptible</classname> but not by
	another <classname>ORO_CoreLib::TaskPreemptible</classname>. The
	ZeroLatencyThread has this name because the zero time
	constraint is dropped, but replaced by the constraint that no
	latency may occur and thus, execution is still realtime.
	Again, to satisfy this constraint, only deterministic time
	operations may be done in this thread.
      </para>
      <para>
	For not realtime executions, as there are userspace
	communication, memory allocations,... we use the
	NonRealTimeThread. Roughly put, you can do
	<emphasis>anything</emphasis> in this thread, as long as it
	takes finite time. This is the lowest priority thread in the
	system and it should never lock a resource of the realtime
	thread. Tasks being executed in the NonRealTimeThread are
	called <classname>ORO_CoreLib::TaskNonRealTime</classname>.
      </para>
      <para>
	The last standard thread type Orocos provides is the 
	<classname>ORO_CoreLib::SimulationThread</classname> which runs
	<classname>ORO_CoreLib::SimulationTask</classname>s. It is special in
	that it executes all its tasks as fast as possible
	( thus without periodic sleeps ) and adjusting the
	system's clock between each <emphasis>step()</emphasis>.
	The latter allows correct timing measurement in the
	tasks running in a SimulationThread. The SimulationThread
	runs by default not-realtime, but this can be changed by
	calling the <function>SimulationThread::Instance()->makeHardRealtime()</function>
	function.
      </para>
      <para>
	The SimulationThread is started likewise the PriorityThread
	above (but without the template parameter). Its priority and
	periodicity can be changed with the configuration tool, or
	before its started.
      </para>
	<programlisting>#include "corelib/SimulationTask.hpp"

using namespace ORO_CoreLib;

ORO_main( int argc, char** argv)
{
  // Define your tasks

  // ...

  // Manually start the simulation thread
  // 0.001 : The (virtual) period :  no task can run 'faster' than this.
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->periodSet( 0.001 );
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->start();

  // Optional, might hang your program :
  <classname>ORO_CoreLib::SimulationThread</classname>::Instance()->makeHardRealtime();

  // fast_sim_task will measure 0.001s elapses between each step(),
  // slow_sim_task will measure 0.01s elapses in time between each step()
  <classname>ORO_CoreLib::SimulationTask</classname> fast_sim_task(0.001, &amp;vel_loop);
  <classname>ORO_CoreLib::SimulationTask</classname> slow_sim_task(0.01, &amp;pos_loop);

  // All is transparant from here on.
  fast_sim_task->start();
  slow_sim_task->start();

  // ...

  fast_sim_task->stop();
  slow_sim_task->stop();

  return 0;
}</programlisting>
      <warning>
	<para>
	  If other threads are running in the same program executable,
	  they will also 'notice' the fast system time changes if the SimulationThread
	  is started. It is thus advisable not to mix SimulationThreads with
	  other threads. Also, any thread with lower priority than the 
	  SimulationThread will never run.
	</para>
      </warning>
    </sect2>
    <sect2 id="task-non-periodic">
      <title>Non Periodic Tasks Run in Their Own Thread</title>
      <para>
	Non periodic ( if blocking ) tasks can only run in <emphasis>non periodic</emphasis> threads, or 
	( if non blocking ) <emphasis>after</emphasis> all periodic tasks of a certain periodic thread. The
	latter to avoid excessive jitter in periodic task execution.
      </para>
      <para>
	If you want to create a task which reads file-IO, or displays
	information or does any other possibly blocking operation, the
	<classname>ORO_CoreLib::TaskNonPeriodic</classname> implementation can be
	used. When it is <function>start()</function>'ed, its loop()
	method will be called exactly once and then it will stop,
	after which it can be started again.  Analogous to periodic
	tasks, the user can implement
	<function>initialize()</function>, <function>loop()</function>
	and <function>finalize()</function> functions in a
	<classname>ORO_CoreLib::RunnableInterface</classname> which will be used by
	the task for executing the user's functions. Alternatively,
	you can reimplement said functions in a derived class of
	TaskNonPeriodic. The task's loop() will be executed in its own
	thread, thus creating a TaskNonPeriodic means creating a new
	thread :
      </para>
      <programlisting>  int priority = 5;
  
  <classname>ORO_CoreLib::TaskNonPeriodic</classname> task( priority, blocking_task );
  task.start(); // calls blocking_task->initialize()

  // now blocking_task->loop() is called in a thread with priority 5.  </programlisting>
      <para>
	After loop() returns, finalize() is called. TaskNonPeriodic
	differs from the periodic tasks in the way it is
	stopped. Since the task may be blocked in the user's loop()
	function, the user should reimplement the
	<function>RunnableInterface::breakLoop()</function>
	function. This funcion must do whatever necessary to let the
	user's loop() function return.  It must return true on
	success, false if it was unable to let the loop() function
	return (the latter is the default implementation's return value).
      </para>
      <para>
	There is another use for TaskNonPeriodic, it can be used to
	wait for Events (see <xref linkend="corelib-events" /> ). If a
	TaskNonPeriodic is not given a RunnableInterface, and it's
	methods are not overridden in a derived class, it will call
	it's EventProcessor's loop() method and wait for Asynchronous
	Events to process. If stop() is called in this case, the task
	will break from the EventProcessor's loop() and be stopped. If
	you want to process Events in your own RunnableInterface
	implementation, you need to manually call the step() method of
	the processor() :
      </para>
      <programlisting>  // in your implementation :
  void loop() {
     while ( ... ) {
        // &lt; do non periodic stuff &gt;
   
        // process any pending Events :
        this->getTask()->processor()->step();
     }
  }
  // ...  </programlisting>
       <para>
	 If you call <function>processor()->loop()</function> instead,
	 the EventProcessor will loop for events until it is stopped,
	 which might not be what you want. So use step() to process
	 all pending Events.
       </para>
    </sect2>
    <sect2>
      <title>Event Driven Tasks</title>
      <para>
	An alternative way to use non periodic tasks is to use
	the <classname>ORO_CoreLib::TaskEventDriven</classname>,
	which can be bound to an <classname>ORO_CoreLib::Event</classname> (see <xref linkend="corelib-events" /> )
	and each time the Event is emitted, the step() method will be invoked
	asynchronously in a given thread.
	This will happen from the moment the task's start method is called
	until the stop method is called. The following example shows
	how such a task can be run asynchronously.
	<programlisting>  #include &lt;corelib/TaskEventDriven.hpp>

  //...
  <classname>ORO_CoreLib::Event</classname>&lt;void(void)> task_event;
  <classname>ORO_CoreLib::TaskEventDriven</classname> task( &amp;task_event, <classname>ORO_CoreLib::ZeroTimeThread</classname>::Instance(), &amp;run_obj);

  task_event.emit(); // nothing happens

  task.start();      // initialize()s task
  task_event.emit(); // task's step() will be executed once in ZeroTimeThread

  task.stop();       // finalize()s task</programlisting>
      </para>
    </sect2>
    <sect2>
      <title>Collecting Thread Information from Tasks</title>
      <para>
	Each Orocos Task (periodic, non periodic and event driven)
	type has a <function>thread()</function> method in its
	interface which gives a non-zero pointer to a
	<classname>ORO_OS::ThreadInterface</classname> object which provides
	general thread information such as the priority and periodicity and allows to
	control the realtimeness of the thread which runs this task. A
	non periodic task's thread will return a period of zero.
      </para>
      <para>
	A <classname>ORO_CoreLib::RunnableInterface</classname> can get the same information
	through the <function>this->getTask()->thread()</function> method calls.
      </para>
      <para>
	
      </para>
    </sect2>
  </sect1>
  <sect1 id="corelib-events">
    <title>Events</title>
    <para>
      An <classname>ORO_CoreLib::Event</classname> is an object to
      which one can connect callback functions. When the Event is
      raised, the connected functions are called one after the
      other. An Event can carry data and deliver it to the function's
      arguments. Orocos allows two possibilities of calling the
      function : synchronous and asynchronous. The former means that
      when the emit() method is called, all synchronous handlers are
      called in the same thread. The latter means that the data is
      stored and the callback function is called in another
      thread. The thread which will execute the deferred callback is
      chosen at connection or setup time.
    </para>
    <figure><title>Event Handling</title>
    <mediaobject>
      <imageobject>
	<imagedata fileref="TaskEventSerialisation" />
      </imageobject>
      <caption><para>Task T1 runs in PeriodicThread (a) while Task T2
      runs in PeriodicThread (b). At some time, T1 registers a
      synchonous and asynchronous callback function ( reaction ) with
      task T2's Event. When T2 emits the Event, the
      synchronous Event callback is executed first ( within Thread (b)
      ), while the asynchronous ( deferred ) callback is queued and
      executed after T1 has run, in Thread (a).  </para></caption>
    </mediaobject>
    </figure>
    <para>
      The Orocos Event system in versions 0.18.x and 0.20.x
      use the <ulink url="http://www.boost.org/">boost::signals</ulink> library.
      Later versions (from 0.22.0 on) use a specially crafted signals implementation
      which allows hard real-time connection of handlers.
    </para>
    <para>
      The Orocos Event extends the signal with asynchronous event handling. 
      Any kind of function can be connected to the event as long as it has the
      same signature as the Event. The 'raise' or 'fire' method of an Orocos Event is
      called <methodname>emit()</methodname> (fire() and operator() are present as well).
    </para>
    <sect2>
      <title>Event Basics</title>
      <example id="core-event-example">
      <title>Using Events</title>
      <para>
	This example shows how a synchronous and asynchronous handler
	are connected to an Event.
      </para>
      <programlisting>#include &lt;corelib/Event.hpp>

using boost::bind;

class SafetyStopRobot
{
public:
    void handle_now() {
        // Synchronous Handler code
    std::cout &lt;&lt; " Putting the robot in a safe state fast !" &lt;&lt; std::endl;
    }
};

Class NotifyUser
{
public:
    void handle_later() {
	    //Asynchronous Completer code
	    std::cout &lt;&lt; "The program stopped the robot !"&lt;&lt;std::endl;
    }
};

...
SafetyStopRobot safety;
NotifyUser      notify;

// The &lt;..> means the callback functions must be of type "void foo(void)"
<classname>ORO_CoreLib::Event</classname>&lt;void(void)> emergencyStop;
<classname>ORO_CoreLib::Handle</classname> emergencyHandle;

// boost::bind is a way to connect the method of an object instance to
// an event.
std::cout &lt;&lt; "Register apropriate handlers to the Emergency Stop Event\n";
emergencyHandle = 
   emergencyStop.connect( bind( &amp;SafetyStopRobot::handle_now, &amp;safety),
	                  bind( &amp;NotifyUser::handle_later, &amp;notify) );

std::cout &lt;&lt; "Emit the event\n";
emergencyStop.emit();

// Disconnecting the callbacks...
emergencyHandle.disconnect();

// Add only synchronous callback :
emergencyHandle = 
   emergencyStop.connect( bind( &amp;SafetyStopRobot::handle_now, &amp;safety) );

std::cout &lt;&lt; "Doing a quiet safety stop..."&lt;&lt;std::endl;
emergencyStop.emit(); // User not notified</programlisting>
      <screen>
	  Register apropriate handlers to the Emergency Stop Event
	  Emit the event
	   Putting the robot in a safe state fast !
	  The program stopped the robot !
	  Doing a quiet safety stop...
	   Putting the robot in a safe state fast !
      </screen>
      <para>
	If you want to find out how boost::bind works, see the Boost
	<ulink url="http://www.boost.org/libs/bind/bind.html">bind manual</ulink>.
	You must use bind if you want to call C++ class member functions to 
	'bind' the member function to an object :
	<programlisting>  ClassName object;
  boost::bind( &amp;ClassName::FunctionName, &amp;object)	</programlisting>
	Where ClassName::FunctionName must have the same signature as the Event.
	When the Event is <function>emit( args )</function>'ed,
	<programlisting>
  object->FunctionName( args )</programlisting>
	is executed by the Event.
      </para>
      <para>When you want to call free ( C ) functions, you do not need bind :
	<programlisting>  Event&lt;void(void)> event;
  void foo() { ... }
  event.connect( &amp;foo );</programlisting>
      </para>
    </example>
    <para>
      Whether your <function>handle()</function> and <function>complete()</function>
      methods contain deterministic code or not is up to you. It depends on the choice of the
      Event type and in which thread it is executed. A good rule of thumb is to make
      all Synchronous handling/completing deterministic time and do all the rest in 
      the Asynchronous part, which will be executed by the
      another thread.
    </para>
    <para>
      You must choose the type of <classname>ORO_CoreLib::Event</classname> upon
      construction. This can no longer be changed once the
      <classname>ORO_CoreLib::Event</classname> is created. The type is the
      same for the synchronous and asynchronous methods. If the type changes,
      the emit() method must given other arguments. For example :
      <example>
	<title>Event Types</title>
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(void)> e_1;
  e_1.emit();

  <classname>ORO_CoreLib::Event</classname>&lt;void(int)>  e_2;
  e_2.emit( 3 );

  <classname>ORO_CoreLib::Event</classname>&lt;void(double,double,double)>  positionEvent;
  positionEvent.emit( x, y, z);</programlisting>
      </example>
    </para>
    <para>
      Furthermore, you need to setup the connect call differently if the Event
      carries one or more arguments :
      <programlisting>  SomeClass someclass;

  Event&lt;void(int, float)&gt; event;

  // notice that for each Event argument, you need to supply _1, _2, _3, etc...
  event.connect( boost::bind( &amp;SomeClass::foo, someclass, _1, _2 ) );

  event.emit( 1, 2.0 );</programlisting>
    </para>
    <important>
    <para>
      The return type for synchronous and asynchronous callbacks is ignored
      and can not be recovered from emit(), which always returns void.
    </para>
    </important>
    </sect2>
    <sect2>
      <title><function>setup()</function> and the <classname>ORO_CoreLib::Handle</classname> object</title>
      <para>
	Event connections can be managed by using a Handle which both <function>connect()</function>
	and <function>setup()</function> return :
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(int, float)&gt; event;
  <classname>ORO_CoreLib::Handle</classname> eh;

  // store the connection in 'eh'
  eh = event.connect( ... );
  assert( eh.connected() );

  // disconnect the function(s) :
  eh.disconnect();
  assert( !eh.connected() );

  // reconnect the function(s) :
  eh.connect();
  // connected again !
	</programlisting>
	Handle objects can be copied and will all show the same status.
	To have a connection setup, but not connected, one can write :
	<programlisting>  <classname>ORO_CoreLib::Event</classname>&lt;void(int, float)&gt; event;
  <classname>ORO_CoreLib::Handle</classname> eh;

  // setup : store the connection in 'eh'
  eh = event.setup( ... );
  assert( !eh.connected() );

  // now connect the function(s) :
  eh.connect();
  assert( eh.connected() );  // connected !
	</programlisting>
	If you do not store the connection of setup(), the connection will never
	be established and no memory is leaked. If you do not use 'eh' to connect
	and destroy this object, the connection is also cleaned up. If you use
	'eh' to connect and then destroy 'eh', you can never terminate the connection,
	except by destroying the Event itself.
      </para>
    </sect2>
    <sect2>
      <title>Choosing the Asynchronous Thread</title>
      <para>
	The Event implementation provides one thread for
	asynchronous execution. The Orocos Tasks package provides
	four additional threads for executing the asynchronous
	callbacks.
      </para>
      <note>
	<para>
	  For brevity, we will not use boost::bind in the following
	  examples and only use 'free' ( <emphasis>C</emphasis> ) functions as callbacks.
	  Asynchronous callbacks are bound in the same way as synchronous
	  callbacks ( <xref linkend="core-event-example"/> ) :
	  <programlisting>  void syn_func( int, double ) { /* .. */ }
  void asyn_func( int, double )  { /* .. */ }</programlisting>
	</para>
      </note>
      <para>
	In the example above, there was aparantly no thread choosen.
	The default thread which executes asynchronous callbacks
	is called the <classname>ORO_CoreLib::CompletionProcessor</classname>. This is a non realtime
	thread, which means that the reaction time is not bounded.
	If you want to execute the callback in another thread,
	an additional argument can be given in the
	<methodname>connect</methodname> or <methodname>setup</methodname> method :
	<programlisting>
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::ZeroLatencyThread</classname>::Instance() );</programlisting>
	The above lists how the ZeroLatencyThread will execute the
	asyn_func if event is emit()'ed. It will do this after it has processed
	all its tasks. The other Orocos threads can do this likewise :
	<programlisting>  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::ZeroTimeThread</classname>::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::NonRealTimeThread</classname>::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::CompletionProcessor</classname>::Instance() ); <emphasis>// Default</emphasis>
  event.connect(&amp;syn_func, &amp;asyn_func, <classname>ORO_CoreLib::PriorityThread</classname>&lt;N&gt;::Instance() );
  event.connect(&amp;syn_func, &amp;asyn_func, &amp;nonperiodic_task );	</programlisting>
	If you would write above listings in a real program, on <function>
	  event.emit()</function>, the syn_func will be called directly
	five times. The asyn_func will be called in each thread once, possibly
	preempting itself.
      </para>
      <para>
	It is also possible to only have the asyn_func called. In this
	case the synopsis is :
	<programlisting>  event.connect( &amp;asyn_func, ZeroLatencyThread::Instance() );
	</programlisting>
	to distinguish from a synchronous callback connection. In this case
	there is no default, so if you wish to use the CompletionProcessor,
	you must specify it explicitly.
	<programlisting>  event.connect( &amp;asyn_func, CompletionProcessor::Instance() );
	</programlisting>
      </para>
      <para>
	For convenience, the Orocos Task threads can also be choosen in another way
	by specifying the Task :
	<programlisting>  TaskNonPreemptible my_task;
  event.connect(&amp;syn_func, &amp;asyn_func, &amp;my_task );	</programlisting>
	or even :
	<programlisting>  RunnableInterface* my_function = ... ;
  // put my_function in a task;
  event.connect(&amp;syn_func, &amp;asyn_func, my_function->getTask() );</programlisting>
	The above says that the asyn_func function should be executed
	after the my_function's task execution period.
	This is a very powerfull way of synchronising function calls
	in different threads. One should be aware that a Task is
	not always executed with every period of the Thread, meaning
	that the asyn_func could be called before the task is run,
	or even multiple times in between a task run.
      </para>
      <note>
	<para>Asynchronous event handlers can have no more than
	6 arguments in the current implementation, but more
	can be easily added.</para>
      </note>
    </sect2>
    <sect2>
      <title>Private EventProcessors for Periodic Tasks</title>
      <para>
	Asynchronous handlers are called in an <classname>ORO_CoreLib::EventProcessor</classname>.
	Each Orocos thread has such an EventProcessor to handle
	the deferred callbacks of all its tasks. A Periodic task
	can also have its a private EventProcessor which handles
	only its deferred callbacks after each step()
	and only when it is started. In this way, it resembles better
	how a non periodic task handles its defered event callbacks.
	To enable this behavior,
	a boolean flag must be given upon construction of a <classname>ORO_CoreLib::PeriodicTask</classname>
	or any derived task-types :
      </para>
	<programlisting>  <classname>ORO_CoreLib::RunnableInterface</classname>* my_function = ... ;
  <classname>ORO_CoreLib::TaskNonPreemptible</classname> mytask( 0.01, my_function, true );     // enable private eventproc.

  event.connect(&amp;syn_func, &amp;asyn_func, my_function->getTask() );
  
  event.emit(); // calls only syn_func.

  mytask.start();
  event.emit(); // calls syn_func and after mytask's step(), asyn_func.</programlisting>
       <para>
	 The private <classname>ORO_CoreLib::EventProcessor</classname> is disabled by default.
       </para>
    </sect2>
    <sect2>
      <title>Event Overrun Policy</title>
      <para>
	An Event can only be emit()'ed by one thread at the same time.
	The synchronous handlers will always be executed
	as much times as the event is emit()'ed. This is not the case
	for asynchronous handlers. If an Event is emit()'ed multiple
	times before the completion thread executes, the asynchronous
	handler will be called only once in the completion thread's execution
	step.
      </para>
      <para>
	The question that rises is with which arguments this handler
	is called. The user can choose between the first (default) and
	the last. The first is choosen as default because this causes the least
	overhead in execution time. To choose which policy is used,
	an optional parameter can be given during connect :
      </para>
      <programlisting>  event.connect( &amp;asyn_func, mytask, Event::OnlyLast );
  event.connect( &amp;asyn_func, mytask, Event::OnlyFirst ); // default
  event.connect( &amp;asyn_func, mytask ); // same as previous line</programlisting>
    </sect2>
    <sect2>
      <title>The Completion Processor</title>
      <para>
	The <classname>ORO_CoreLib::CompletionProcessor</classname> is implemented using the
	Singleton design pattern, analogous to the
	periodic task threads. It is the lowest priority, not realtime
	thread in the &orocos; framework. It will execute all
	asynchronous event callbacks that have to be completed when no other work has to
	be done. The only constraint it imposes is that all functions it
	executes must require finite time to complete (it cannot
	detect timeouts). You can get its thread pointer like this :
	<programlisting>  #include &lt;corelib/CompletionProcessor.hpp>

  CompletionProcessor::Instance()-> ... </programlisting>
      </para>
      <para>
	The CompletionProcessor is a TaskNonPeriodic, thus not consuming
	time resources when no Events need to be processed. If you need a 
	hard realtime CompletionProcessor, use a default TaskNonPeriodic ( see
	<xref linkend="task-non-periodic" /> ) and call its makeHardRealTime() method.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Time Measurement and Conversion</title>
    <sect2>
      <title>The TimeService</title>
      <para>
	The <classname>ORO_CoreLib::TimeService</classname> is implemented using the
	Singleton design pattern.
	You can query it for the current (virtual) time in clock ticks or in seconds.
	The idea here is that it is responsible for synchronising with other (distributed)
	cores, for doing, for example compliant motion with two robots. This functionality
	is not yet implemented though.
      </para>
      <para>
	When the <classname>ORO_CoreLib::SimulationThread</classname> is used and started, it will change the TimeService's
	clock with each period ( to simulate time progress).
	Also other threads (!) In the system will notice this change, but
	time is guaranteed to increase monotonously.
      </para>
    </sect2>
    <sect2>
      <title>Usage Example</title>
      <para>
	Also take a look at the interface documentation.
	<programlisting>  #include &lt;corelib/TimeService.hpp>
  #include &lt;corelib/Time.hpp>

  TimeService::ticks timestamp = <classname>ORO_CoreLib::TimeService</classname>::Instance()->getTicks();
  //...

  Seconds elapsed = TimeService::Instance()->secondsSince( timestamp );	</programlisting>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Properties</title>
    <sect2>
      <title>Introduction</title>
      <para>
	Orocos provides properties through the <classname>ORO_CoreLib::Property</classname>
	class.
	They are used to store primitive data (float, strings,...) in
	a <classname>ORO_CoreLib::PropertyBag</classname>, which can be changed by the user and has immediate
	effect on the behaviour of the program. Changing parameters of an
	algorithm is a good example where properties can be used. Each parameter
	has a value, a name and a description. The user can ask any PropertyBag
	for its contents and change the values as they see fit. Java for
	example presents a Property API. 
	The Doxygen Property API should
	provide enough information for succesfully using them in your Software Component.
	<note>
	  <para>
	    Reading and writing a properties value can be done in
	    realtime. Every other transaction, like marshalling
	    (writing to disk), demarshalling (reading from disk) or
	    building the property is not a realtime operation.
	  </para>
	  <para>
	    <example><title>Using properties</title> 
	      <programlisting>
  // a property, respresening a double of value 1.0:

  <classname>ORO_CoreLib::Property</classname>&lt;double> myProp("Parameter A","A demo parameter", 1.0); // not realtime !
  myProp = 10.9; // realtime
  double a = myProp.get(); // realtime  </programlisting>
	    </example>
	  </para>
	</note>
      </para>
      <para>
	Properties are mainly used for two purposes. First, they allow an external
	entity to browse their contents, as they can form hierarchies using
	PropertyBags. Second, they can be written to screen, disk,
	or any kind of stream and their contents can be restored lateron, for example
	after a system restart. The next sections give a short introduction to these
	two usages.
      </para>
    </sect2>
    <sect2>
      <title>Grouping Properties in a PropertyBag</title>
      <para>
	First of all, a PropertyBag is not the owner of the properties it owns,
	it merely keeps track of them, it defines a logical group of properties
	belonging together. Thus when you delete a bag, the properties in it are
	not deleted, when you clone() a bag, the properties are not cloned
	themselves. PropertyBag is thus a container of pointers to Property objects.
      </para>
      <para>
	If you want to duplicate the contents of a PropertyBag or perform recursive
	operations on a bag, you can use the helper functions we created and which
	are defined in <filename>PropertyBag.hpp</filename> (see Doxygen documentation).
	These operations are however, most likely not realtime.
      </para>
      <note><para>When you want to put a PropertyBag into another PropertyBag, you need
      to make a Property&lt;PropertyBag&gt; and insert that property into the 
      first bag.</para>
      </note>
      <para> Use <methodname>add</methodname> to add Properties to a bag and 
      <methodname>find</methodname> or <methodname>getProperty&lt;T&gt;</methodname> to
      get a pointer to a <classname>ORO_CoreLib::PropertyBase</classname> or <classname>ORO_CoreLib::Property</classname>&lt;T&gt; :
	<programlisting>  <classname>ORO_CoreLib::PropertyBag</classname> bag;
  <classname>ORO_CoreLib::Property</classname>&lt;double&gt; w("Weight", "in kilograms", 70.5 );
  <classname>ORO_CoreLib::Property</classname>&lt;int&gt; pc("PostalCode", "", 3462 );

  struct BirthDate {
     BirthDate(int d, month m, int y) : day(d), month(m), year(y) {}
     int day;
     enum { jan, feb, mar, apr, may, jun, jul, aug, sep, oct, nov, dec} month;
     int year;
  };

  <classname>ORO_CoreLib::Property</classname>&lt;BirthDate&gt; bd("BirthDate", " in 'BirthDate' format", BirthDate(1, apr, 1977));

  bag.add( &amp;w );
  bag.add( &amp;pc );
  bag.add( &amp;bd );
	
  <classname>ORO_CoreLib::PropertyBase</classname>* weight = bag.find("PostalCode");    // assert( weight != 0 )

  <classname>ORO_CoreLib::Property</classname>&lt;BirthDate&gt;* bd_bis = bag.getProperty&lt;BirthDate&gt;("BirthDate"); // assert( bd_bis != 0 )
	</programlisting>
      </para>
    </sect2>
    <sect2>
      <title>Marshalling and Demarshalling Properties (Serialization)</title>
      <para>
	Marshalling is converting an object from machine code to a
	code suitable for transportation or storage. When an object is
	marshalled, a copy is made so that it can be restored in its
	original state. Demarshalling instantiates the object again
	from the marshalled copy. Common formats of marshalling are
	writing out properties or efficient binary memory copies. So
	properties are just an example of objects that can be
	marshalled. We wrote however specific marshallers for
	properties and property bags. These are the
	<classname>ORO_CoreLib::SimpleMarshaller</classname>,
	<classname>ORO_CoreLib::XMLMarshaller</classname>,
	<classname>ORO_CoreLib::XMLRPCMarshaller</classname>,
	<classname>ORO_CoreLib::INIMarshaller</classname> and the
	<classname>ORO_CoreLib::CPFMarshaller</classname>. You will
	need the <ulink
	url="http://xml.apache.org/xerces-c/index.html">Xerces</ulink>
	library for the XML related marshalling.
      </para>
      <para>
	The (de-)marshallers know how to convert native C++ types, but if you want
	to store your own classes in a Property ( like <classname>BirthDate</classname>
	in the example above ), then you need to provide two additional methods
	to the Orocos Property System : <methodname>composeProperty</methodname> and
	<methodname>decomposeProperty</methodname>. You'll need to consult the 
	API documentation on how to fill in these two functions and an example.
      </para>
      <para>
	If you are not interested in marshalling your own types, you can enable
	the 'Default Marshalling' option in the configuration tool, which will
	generate a default for these two functions for type T in any file where you use
	a <classname>ORO_CoreLib::Property</classname>&lt;T&gt;.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>The NameServer</title>
    <sect2>
      <title>Introduction</title>
      <para>
	A useful element in the &orocos; framework is what we call the strong typed
	nameserver. It is a (string based) nameserver which stores name, object pairs
	of only one type of object in the local program. 
	Off course, polymorphism allows us to collect many
	derivative types into one nameserver. A nameserver allows late configuration
	of objects. All possible used objects are created first and stored in the
	nameserver. Depending of the run-time users choice (from a text file,
	console input,...), another object is retrieved from the nameserver and
	used in the program.
      </para>
    </sect2>
    <sect2>
      <title>Using the NameServer</title>
      <para>
	The local object server is called
	<classname>ORO_CoreLib::NameServer</classname>.  The most
	common usage syntax is given below.
      </para>
      <note><para>
	The most common use of nameserving is keeping track of pointers to objects.
	A NameServer almost always takes pointers to an object as arguments and 
	returns a pointer when the object is looked up again.</para>
      </note>
      <programlisting>  // A NameServer collecting pointers to ClassA objects
  <classname>ORO_CoreLib::NameServer</classname>&lt; ClassA* &gt; nameserver;
  ClassA my_a;
  nameserver.registerObject( &amp;my_a, "ATeam" );
  // ...
  ClassA* an_a = nameserver.getObject( "ATeam" );
  if (an_a != 0 )
      cout &lt;&lt; "ATeam was successfully stored and retrieved !" &gt;&gt; endl;     </programlisting>
      <para>
	A typical use of nameserving is that the nameserver is nested inside the class
	it is nameserving itself. For convenience, the constructor of that class is then
	extended to take a string as argument to indicate the (optional) desired name
	of the object. Imagine that the above ClassA had such a nested nameserver,
	in that case, it would be used as follows :
      </para>
      <programlisting>  ClassA my_a( "The ATeam" ); // give name in constructor
  // ...
  // notice the scope ClassA:: the nameserver is nested in :
  ClassA* an_a = ClassA::nameserver.getObject( "The ATeam" );
  if (an_a != 0 )
    cout &lt;&lt; "The ATeam was successfully stored and retrieved !" &gt;&gt; endl;     </programlisting>
      <para>
	The above technique is used in many classes inside &orocos;. Events, Devices, 
	Control Kernels and Components, ... anything you wish to configure at runtime
	can be nameserved.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Buffers and DataObjects</title>
    <para>
      Orocos provides some basic inter-thread buffering mechanisms in the
      <filename>corelib/buffers</filename> package.
    </para>
    <para>
      The difference between Buffers and DataObjects is that DataObjects
      always contain a single value, while buffers may be empty, full or contain
      a number of values.
      Thus a <classname>ORO_CoreLib::DataObject</classname> always returns the last value written (and a
      write always succeeds), while a buffer
      may implement a FIFO queue to store all written values (and thus can get full).
    </para>
    <figure><title>DataObjects versus Buffers</title>
    <mediaobject>
      <imageobject>
	<imagedata fileref="DataObjectBuffer" />
      </imageobject>
      <caption><para>DataObjects are most suitable for single writer, many readers,
      and always return the last written value. Buffers have a fixed queue length
      and are used for processing all produced data by any number of producers and
      consumers.
      </para></caption>
    </mediaobject>
    </figure>
    <sect2 id="corelib-buffers">
      <title>Buffers</title>
      <para>
	The <classname>ORO_CoreLib::BufferInterface</classname>&lt;T&gt; provides
	the interface for Orocos buffers. Currently the <classname>ORO_CoreLib::BufferLockFree</classname>&lt;T&gt;
	is a typed buffer of type <emphasis>T</emphasis> and works as
	a FIFO queue for storing elements of type T.
	It is lock-free, non blocking and read and writes
	happen in bounded time. It is not subject to priority inversions.
      </para>
	<example>
	  <title>Accessing a Buffer</title>
	  <programlisting>  #include &lt;corelib/BufferLockFree.hpp>

  // A Buffer may also contain a class, instead of the simple
  // double in this example
  // A buffer with size 10:
  <classname>ORO_CoreLib::BufferLockFree</classname>&lt;double> my_Buf( 10 ); 
  if ( my_Buf.Push( 3.14 ) ) {
     // ok. not full.
  }
  double  contents; 
  if ( my_Buf.Pop( contents ) ) {
     // ok. not empty.
     // contents == 3.14
  }</programlisting></example>
       <para>
	 Both <function>Push()</function> and <function>Pop()</function>
	 return a boolean to indicate failure or success.
       </para>
    </sect2>
    <sect2 id="corelib-data-objects">
      <title>DataObjects</title>
      <para>
	The data inside the <classname>ORO_CoreLib::DataObject</classname>s can be any valid C++ type,
	so mostly people use classes or structs, because these carry
	more semantics than just (vectors of) doubles. The default
	constructor of the data is called when the DataObject is
	constructed.  Here is an example of creating and using a
	DataObject :
	<example>
	  <title>Accessing a DataObject</title>
	  <programlisting>  #include &lt;corelib/DataObjectInterfaces.hpp>

  // A DataObject may also contain a class, instead of the simple
  // double in this example
  <classname>ORO_CoreLib::DataObjectLockFree</classname>&lt;double> my_Do("MyData"); 
  my_Do.Set( 3.14 ); 
  double  contents; 
  my_Do.Get( contents );   // contents == 3.14
  contents  = my_Do.Get(); // equivalent  </programlisting>
	</example>
      </para>
      <para>
	The virtual <classname>ORO_CoreLib::DataObjectInterface</classname> interface
	provides the <function>Get()</function> and
	<function>Set()</function> methods that each DataObject must
	have. Semantically, <function>Set()</function> and
	<function>Get()</function> copy all contents of the
	DataObject.
      </para>
    </sect2>
  </sect1>
  <sect1 id="core-logging">
    <title>Logging</title>
    <para>
      Orocos applications can have pretty complex startup and
      initialisation code.  A logging framework, using
      <classname>ORO_CoreLib::Logger</classname> helps to track what
      your program is doing.
    </para>
      <note><para>Logging can
      only be done in the non-realtime parts of your application, thus not in
	the Realtime Periodic Tasks !</para></note>
    <para>
      There are currently 8 loglevels :
      <table>
	<title>Logger Log Levels</title>
	<tgroup cols="3">
	  <thead>
	    <row>
	      <entry>ORO_LOGLEVEL</entry>
	      <entry>Logger::enum</entry>
	      <entry>Description</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry>-1</entry>
	      <entry>na</entry>
	      <entry>Completely disable logging</entry>
	    </row>
	    <row>
	      <entry>0</entry>
	      <entry>Logger::Never</entry>
	      <entry>Never log anything (to console)</entry>
	    </row>
	    <row>
	      <entry>1</entry>
	      <entry>Logger::Fatal</entry>
	      <entry>Only log Fatal errors. System will abort immediately.</entry>
	    </row>
	    <row>
	      <entry>2</entry>
	      <entry>Logger::Critical</entry>
	      <entry>Only log Critical or worse errors. System may abort shortly after.</entry>
	    </row>
	    <row>
	      <entry>3</entry>
	      <entry>Logger::Error</entry>
	      <entry>Only log Errors or worse errors. System will come to a safe stop.</entry>
	    </row>
	    <row>
	      <entry>4</entry>
	      <entry>Logger::Warning</entry>
	      <entry>[Default] Only log Warnings or worse errors. System will try to resume anyway.</entry>
	    </row>
	    <row>
	      <entry>5</entry>
	      <entry>Logger::Info</entry>
	      <entry>Only log Info or worse errors. Informative messages.</entry>
	    </row>
	    <row>
	      <entry>6</entry>
	      <entry>Logger::Debug</entry>
	      <entry>Only log Debug or worse errors. Debug messages.</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </para>
    <para>
      You can change the amount of log info printed on your console by setting the environment variable
      <envar>ORO_LOGLEVEL</envar> to one of the above numbers :
      <screen>
  export ORO_LOGLEVEL=5</screen>
      The default is level 4, thus only warnings and errors are printed.
    </para>
    <para>
      The <emphasis>minimum</emphasis> log level for the <filename>orocos.log</filename>
      file is <parameter>Logger::Info</parameter>. It will get more verbose if
      you increase <envar>ORO_LOGLEVEL</envar>, but will not go below Info. 
      This file is always created if the logging infrastructure is used. You can inspect this file
      if you want to know the most usefull information of what is happening inside Orocos.
    </para>
    <para>If you want to disable logging completely, use <screen>export ORO_LOGLEVEL=-1</screen>
      before you start your program.</para>
    <para>
      For using the <classname>ORO_CoreLib::Logger</classname> class in your own application, consult
      the API documentation.
    </para>
    <example>
      <title>Using the Logger class</title>
      <programlisting>  #include &lt;corelib/Logger.hpp>

  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; Logger::Error &lt;&lt; "An error Occured : " &lt;&lt; 333 &lt;&lt; "." &lt;&lt; Logger::endl;
  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; Logger::Debug &lt;&lt; debugstring &lt;&lt; data &lt;&lt; Logger::endl;
  <classname>ORO_CoreLib::Logger</classname>::log() &lt;&lt; " more debug info." &lt;&lt; data &lt;&lt; Logger::endl;</programlisting>
      <para>As you can see, the Logger can be used like the standard C++ input streams.
	You may change the Log message's level using the <classname>ORO_CoreLib::Logger::...</classname>
	enums. The above message could result in :
      </para>
      <screen>
  0.123 [ERROR] An error Occured : 333
  0.124 [Debug] &lt;contents of debugstring and data >
  0.125 [Debug]  more debug info. &lt;...data...> </screen>
    </example>
  </sect1>
</article>
