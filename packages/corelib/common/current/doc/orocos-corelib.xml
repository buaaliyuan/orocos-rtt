<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY rtai        "<acronym>RTAI</acronym>">
<!ENTITY rtos        "<acronym>RTOS</acronym>">
]
>

<book>
  <bookinfo>
    <title>The Orocos Core Library Manual</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	<emphasis>Core</emphasis> component of &orocos;, the <emphasis>Open
RObot COntrol Software</emphasis> project. The Core provides
infrastructural support for the functional and application components
of the &orocos; framework. An overview of that &orocos; framework
(including installation) is
given in the general &orocos; overview document.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>22 Aug 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.9</revnumber>
	<date>11 Nov 2002</date>
	<authorinitials>ps</authorinitials>
	<revremark>lots of updates</revremark>
      </revision>
      <revision>
	<revnumber>0.11</revnumber>
	<date>29 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Stripped Devices and OS parts</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>

  <chapter>
    <title>Introduction</title>
    <para>
      This Chapter describes the semantics of the services
      available in the &orocos; CoreLib Package.
    </para>
    <para>
	The Core makes an abstraction of the operating system on which it runs.
	It provides C++ interfaces to only the <emphasis>minimal
	  set</emphasis> of operating system
	primitives that it needs: mutexes, condition variables and tasks.
	This is in accordance with the general developers requirements of the
      project: a minimalistic approach is much easier to scale, to maintain,
      and to port. The OS abstraction is refered to as the <emphasis> 
	OS Interfaces (OSI) </emphasis> and sometimes in older documentation
      as <emphasis>Framework OS Interfaces (FOSI)</emphasis>. Both denote
      the same thing.
	The abstraction also allows &orocos; users to build their software 
	on all supported systems with only
	a recompilation step. But the Core goes further than restricting
	the abstracted OS primitives: it also imposes a hard realtime
	<emphasis>architecture</emphasis>. This architecture is explained and
	motivated in a later Section.
      <emphasis>
	The goal of this fixed architecture is to keep 
	applications deterministic, by avoiding the classical pitfalls of
	letting application programmers freely choose the priorities of their
	tasks, and their communication primitives. Practice has indeed showed
	that most programmers do not succeed in strictly decoupling the
	functional and algorithmic parts of their code from the OS-specific
	primitives used to execute them.</emphasis>
      </para>
      <para>
	Of course, the realtime performance depends not only on
	  the underlying operating system 
	  <emphasis>but also on the hardware.</emphasis> The &orocos; CoreLib
	Package also provides an abstraction of the hardware, again in order
	to facilitate maintenance and porting. This abstraction is referred to
      as <emphasis>Device Interfaces (DI)</emphasis> or in older documentation
      as the <emphasis>Framework Device Interfaces (FDI)</emphasis>. Both
      denote the same thing.
      </para>
      <para>
	The abstractions cause (almost) no execution overhead, because the wrapping
	is solved at compile or configuration time, i.e., before the hard
	realtime tasks are running.
      </para>
  </chapter>
  <chapter>
    <title>The Orocos Thread Philosophy</title>
    <sect1>
	<title>Introduction : Task versus Thread</title>
	  <para>
	    Threads are the major cause of headaches in multithreaded systems
	    programmers heads.
	    Synchronisation, data protection, priority tweaking and resource
	    locking must all be done very carefully and mostly lead to suboptimal
	    solutions. Even more, the predictability of the system highly decreases
	    with the introduction of more threads or interactions between threads.
	    Because of this, we propose the following:
	  </para>
	  <para>
	    Only two realtime threads : A high priority thread and a low priority thread.
	    The high priority thread is used for all tasks that need to be executed
	    atomically. No action in this thread
	    will ever be pre-empted. 
	    The low priority thread is used for all tasks which may be 
	    interrupted but still have hard deadlines. It can always be preempted by the 
	    high priority thread. There is also a non realtime thread which gives no
	deadline guarantees.
	  </para>
      <para>
	If you want to execute functionality in one of these threads, you need to 
	create a Task of a certain type, depending on the thread type. The table
	below summarises which Task type there is per thread.
	<table>
	  <title>Thread and Task summary</title>
	  <!-- one of (graphic mediaobject tgroup) -->
	  <tgroup cols="2">
	    <thead>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>Thread</entry>
		<entry>Task</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>ZeroTimeThread</entry>
		<entry>TaskNonPreemptable</entry>
		<!-- one of (entrytbl entry) -->
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>ZeroLatencyThread</entry>
		<entry>TaskPreemptable</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>NonRealTimeThread</entry>
		<entry>TaskNonRealTime</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
      </para>
	  <para>
	    The high priority thread is the <classname>ZeroTimeThread</classname>. It will
	    execute all <classname>TaskNonPreemptable</classname> Components synchronically.
	    You can create your own not preemtable task by inheriting from this
	    class. Its name is derived from the fact that some tasks need to be executed
	    in an infinite small amount of time to work correctly. Control loops
	    are an example of this. To come as close as possible to this (impossible)
	    constraint, we make sure that the task is never preempted by another task and
	    thus is executed 'atomically'.
	  </para>
	  <para>
	    <figure><title>Execution collaboration diagram</title>
	      <mediaobject>
		<imageobject role="fo">
		  <imagedata fileref="execution-collaboration.eps" format="EPS"/>
		</imageobject>
		<imageobject role="html">
		  <imagedata fileref="execution-collaboration.png" format="PNG"/>
		</imageobject>
         	<textobject><phrase>Collaboration diagram</phrase></textobject>
	    <caption><para>Internal call flow of task execution.</para>
	    </caption>
	    <!--
		<caption><para>
	      </para></caption>
		-->
	  </mediaobject>
	</figure>
      </para>
	  <para>
	    <figure><title>Execution sequence diagram</title>
	      <mediaobject>
		<imageobject role="html">
		  <imagedata fileref="execution-sequence.png" format="PNG"/>
		</imageobject>
		<imageobject role="fo">
		  <imagedata fileref="execution-sequence.eps" format="EPS"/>
		</imageobject>
		<!--
		<caption><para>
	      </para></caption>
		-->
	      </mediaobject>
	    </figure>
	  </para>
	  <para>
	    The low priority tasks are executed by the <classname>ZeroLatencyThread</classname>
	    Component.
	    It will execute all <classname>TaskPreemptable</classname> Components
	    sequentially, when no non-preemptable tasks are 
	    executed. Every <classname>TaskPreemptable</classname> can be preempted by a 
	    <classname>TaskNonPreemptable</classname> but not by another <classname>TaskPreemptable</classname>.
	    The ZeroLatencyThread has this name because the zero time constraint is
	    dropped, but replaced by the constraint that no latency may occur and 
	    thus, execution is still realtime. Again, to satisfy this constraint,
	    only deterministic time operations may be done in this thread.
	  </para>
	  <para> For not realtime executions, as there are userspace communication,
	    memory allocations,... we use the NonRealTimeThread. Roughly put, you
	    can do <emphasis>anything</emphasis> in this thread, as long as it 
	    takes finite time. This is the lowest priority thread in the system and
	    it should never lock a resource of the realtime thread. Tasks being executed
	    in the NonRealTimeThread are called <classname>TaskNonRealTime</classname>.
	  </para>
    </sect1>
  </chapter>
    <chapter>
      <title>Events</title>

      <para>
	Events are implemented using the <classname>Observer</classname> 
	design pattern. An object or component which wants to be notified
	of events, has to implement the <classname>EventListenerInterface</classname>, 
	in which the
	<function>handleEvent(CallbackInterface*)</function> method will be called when
	the event occurs. This is a subscription model (yeah, like the newsletters,
	but we don't do SPAM), you only get notified when you registered for it.
      </para>
      <para>
        The <classname>EventListener</classname> can decide to call the event completer (if available)
        by calling the <function>complete()</function>
        function on the <classname>CallbackInterface</classname> object.  
	An example is when an EventListener is gathering data and enough data is available, 
	the Completer should finish the job, so the EventListener invokes the complete() method.
	<classname>EventListener</classname> and completer can be
        different or the same objects. Let's look at an example : 
      </para>
      <para>
	<example><title>Using events</title>
	  <programlisting>
	    <![CDATA[
	    class SafetyStopRobot : public EventListenerInterface 
            {
    	    public:
	        virtual void handleEvent(CallbackInterface *cb) {
	            // Handler code
    	        std::cout << " Putting the robot in a safe state fast !" << std::endl;
    	        // optional
	            cb->complete();
    	        }
	    };

	    Class NotifyUser : public EventCompleterInterface 
            {
	    public:
	        virtual void completeEvent() {
        	    //Completer code
        	    std::cout << "The program stopped the robot !"<<std::endl;
	        }
	    };

	    ...
	    SafetyStopRobot synchronousSafetyHandler;
	    NotifyUser      asynchronousNotifier;
	    Event emergencyStop(Event::SYNASYN);

	    std::cout << "Register apropriate handlers to the Emergency Stop Event\n";
	    emergencyStop.addHandler( &synchronousSafetyHandler, &asynchronousNotifier);

	    std::cout << "Fire the event\n";
	    emergencyStop.fire();

	    emergencyStop.removeHandler( &synchronousSafetyHandler, &asynchronousNotifier );      // Remove both handlers
	    emergencyStop.addHandler(&synchronousSafetyHandler, EventCompleterInterface::none );  // No completer will be called

	    std::cout << "Doing a quiet safety stop..."<<std::endl;
	    emergencyStop.fire(); // User not notified

	    ...
	    ]]>
	  </programlisting>

	  <screen>
	  Register apropriate handlers to the Emergency Stop Event
	  Fire the event
	   Putting the robot in a safe state fast !
	  The program stopped the robot !
	  Doing a quiet safety stop...
	   Putting the robot in a safe state fast !
	  </screen>
	<para>
	  Off course, the <emphasis>Putting the robot in a safe state fast !</emphasis>
	  sentence should be replaced with the actual call to stop the robot.
	</para>
	</example>
      </para>
      <para>	
	We can categorise event handling and
        completion in two categories: synchronous and asynchronous, both
        possible for handling and completion. This leaves four types of events :
        <itemizedlist>
	  <listitem><para>Synchronous event handling, synchronous completion (think separate components)</para></listitem>
	  <listitem><para>Synchronous event handling, asynchronous completion (think interrupts)</para></listitem>
	  <listitem><para>Asynchronous event handling, asynchronous completion (think mission to Mars)</para></listitem>
	  <listitem><para>Asynchronous event handling, synchronous
	      completion (think separate components on Mars)</para></listitem>
        </itemizedlist>
        One could argue that the first and last one have no practical applications, we're
        busy thinking of some. All four types are nonetheless implemented in the framework.
      </para>
      <para><emphasis>
	  The aim of this separation of listener and completer is decoupling: both
	  can be implemented in different objects and do not know about each other. Even
	  more, the completer should not count on the fact that it is called each time
	  the listener is called. It is possible that in some cases the listener asks for
	  completion, and in other cases does not require it (yet).</emphasis>
      </para>
      <para>
	Whether your <function>handleEvent()</function> and <function>completeEvent()</function>
	methods contain deterministic code or not is up to you. It depends on the choice of the
	Event type and in which thread it is executed. A good rule of thumb is to make
	all Synchronous handling/completing deterministic time and do all the rest in 
	the Asynchronous part, which will be executed by the <classname>CompletionProcessor</classname>.
      </para>

    <tip>
      <para>
	You must choose the type of <classname>Event</classname> upon construction. This can no longer
	be changed once the <classname>Event</classname> is created. If it could,
	the consumer of the event would not know what would be synchronously and 
	asynchronously executed, leading to undeterministic behaviour. You must specify
	the type as the first constructor argument with one of the four following:
	Event::SYNSYN,Event::ASYNSYN,Event::SYNASYN,Event::ASYNASYN; with the first
	[SYN|ASYN] denoting the handling and the second the completion policy.
      </para>
    </tip>
    <sect1>
	<title>Available Event Policies</title>
	<para>
	  Our subscription based Event is just an example of the many possibilities of Events in
	  general. We provide four other Event primitives which you will need in your Event based
	  applications.
	</para>
      <sect2>
	<title>EventSimple</title>
	<para>
	  <classname>EventSimple</classname> is a simplification of the general Event. 
	  It can have exactly one Listener and one Completer, which can be set or removed.
	  You can use this Event in case you want to be sure that only one Listener and
	  one Completer are notified when this event is fire()'d.
	</para>
      </sect2>
      <sect2>
	<title>EventMultiCast</title>
	<para>
	  <classname>EventMultiCast</classname> has one Listener and many Completers.
	  When the event is fire()d and the Listener calls for complete()'ion,
	  all subscribed Completers will be notified. In this sence, not the fire
	  call is MultiCasted, but the complete call is MultiCasted to all Completers.
	</para>
      </sect2>
      <sect2>
	<title>EventBarrier</title>
	<para>
	  <classname>EventBarrier</classname> has many Listeners and one Completer.
	  When the event is fire()d and the Listener calls for complete()'ion,
	  the Completer will only be notified if all Listeners called the
	  complete() method. A new fire() method call will reset all complete() calls
	  and wait again for all Listeners to call complete() before the Completer
	  is notified.
	</para>
	<para>
	  An example is an EmergencyStop Event. Some program logic decides that the
	  EmergencyStop Event must be fired. All Listeners are called and perform
	  their emergency stop handling and call the complete() method. When
	  all Listeners called this, the Completer is called which now knows
	  that everyone stopped safely and can report this to the user or another
	  component. It is as if the Completer was on hold until all Listeners were
	  ready, hence the word barrier.
	</para>
      </sect2>
      <sect2>
	<title>EventPeriodic</title>
	<para>
	  <classname>EventPeriodic</classname> is a special case of the Event
	  subscription model. That is, the Listener-Completer mapping is N to N,
	  as with the normal Event, but the fireing of the event results in
	  periodically notifying of Listeners. For example, if the periodicity
	  is 10 to 1, each Listener will have been called exactly once after
	  the EventPeriodic was fired ten times. For each Listener, it is as 
	  if the fire calls are done with longer periods in between.
	</para>
	<para>
	  This Event is used in the &orocos; Threading classes for executing
	  tasks at a lower frequency than the thread is running.
	</para>
      </sect2>
      <sect2>
	<title>EventDivider</title>
	<para>
	  <classname>EventDivider</classname> is also a special case of the Event
	  subscription model. That is, the Listener-Completer mapping is N to N,
	  as with the normal Event, but the notifying of the Listeners of the 
	  event will only happen after X effective fire calls. It is as if
	  The Event divides the firing by factor X.
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>The Completion Processor</title>
      <para>
	The Completion Processor is also implemented using the <classname>Singleton</classname> design pattern.
	It is the lowest priority, not realtime thread in the &orocos; framework. It will execute all
	Events that have to be completed asynchronously. The only constraint it has is
	that all tasks it executes should require finite time to complete.
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>The HeartbeatGenerator</title>
    <sect1>
      <title>Purpose</title>
      <para>
	The <classname>HeartbeatGenerator</classname> is implemented using the
	<classname>Singleton</classname> design pattern.
	You can query it for the current (virtual) time in clock ticks or in seconds.
	The idea here is that it is responsible for synchronising with other (distributed)
	cores, for doing, for example compliant motion with two robots. This functionality
	is not yet implemented though.
      </para>
    </sect1>
  </chapter>
  <chapter>
      <title>States and the StateContext</title>
    <sect1>
      <title>Introduction</title>
      <para>
	Any complex software component will sooner or later need a way to change state, depending
	on how it is used by the other components. The <classname>StateInterface</classname> 
	describes how state changes are handled. When the current state is left, its
	<function>onExit()</function> method is called. Next, the <function>onEntry()</function>
	of the new state is called and right after that its <function>handle()</function> is
	called. Each time the current state is again requested, the <function>handle()</function>
	is called again.
      </para>
      <para>
	So the <classname>StateInterface</classname> determines what has to be done, but 
	the decision to change state is made in the <classname>StateContext</classname>. The 
	StateContext keeps track of the current state and all valid state transitions.
	One has to 'program' the StateContext so that it knows which transitions can be made
	under which conditions
      </para>
    </sect1>
     <sect1>
	<title>The ConditionInterface</title>
	<para>
	  The ConditionInterface is very basic :
	  <programlisting>
	    <![CDATA[
	    class ConditionInterface
	    {
	    virtual bool evaluate() = 0;
	    };
	    ]]>
	  </programlisting>

	  Conditions are classes that evaluate an expression and return the result. This expression
	  must be defined by the user. Some examples are in the source tree, like <classname>
	    ConditionOnce</classname> (returns only true when it is the first time evaluated), 
	  <classname>CondionTrue</classname> (always returns true), etc. The StateContext must have for
	  each state transition a Condition object which it will <function>evaluate()</function>
	  to determine if the transition is allowed.
	</para>
      </sect1>
      <sect1>
	<title>Programming and Requesting State Transitions</title>
	<para>
	  Now how does it all work together ? First, a StateContext object is created and
	  all its possible States. 
	  <programlisting>
	    <![CDATA[
	    StateInit startState;
	    StateA aState;
	    StateB bState;
	    StateError errState;

	    ConditionTrue cTrue;
	    ConditionOnce cOnce;

	    StateContext context;

	    ]]>
	  </programlisting>
	  Next, we will tell the <varname>context</varname> object which is the initial state which
	  state transitions are allowed :
	  <programlisting>
	    <![CDATA[
	    context.initState(&startState);

	    context.transitionSet(&startState, &aState, &cOnce);
	    context.transitionSet(&aState, &bState, &cTrue);
	    context.transitionSet(&bState, &aState, &cTrue);
	    context.transitionSet(&errState, &cTrue);

	    ]]>
	  </programlisting>
	  As you can see, you can only go once from the startState to the aState, then you can
	  always switch from aState to bState and back. All states are allowed to go to the 
	  errorstate, but in this example, it will be impossible to leave the errorstate:
	  <programlisting>
	    <![CDATA[
	    ...
	    // we are in the startState
	    context.requestState(&bState); // will return false !
	    context.requestState(&aState); // ok, returns true.
	    context.requestState(&bState); // ok, returns true.
	    context.requestState(&errState); // returns true, but we are trapped in it.

	    // we are now in the errState
	    ...
	    ]]>
	  </programlisting>
	</para>
      </sect1>
    </chapter>
    <chapter>
    <title>Properties</title>
    <sect1>
      <title>Introduction</title>
      <para>
	Properties are well known in object oriented programming languages. 
	They are used to store primitive data (float, strings,...) in
	a 'PropertyBag', which can be changed by the user and has immediate
	effect on the behaviour of the program. Changing parameters of an
	algorithm is a good example where properties can be used. Each parameter
	has a value, a name and a description. The user can ask any PropertyBag
	for its contents and change the values as they see fit. Java for
	example presents a Property API. 
      </para><para>
      RTAI, LXRT and GNU/Linux have been tested succesfully
	with properties. An example of how to build a PropertyBag can be found in the
	<filename>doc/examples/properties/simple_hibernate.cpp</filename> file. 
      The Doxygen Property API should
      provide enough information for succesfully using them in your Software Component.
	<note>
	  <para>
	    Reading and writing a properties value can be done in realtime. Every other 
	    transaction, like marshalling, demarshalling or building the property
	    is not a realtime operation.
	  </para>
	  <para>
	    <example><title>Using properties</title> 
	      <programlisting>
		<![CDATA[
		...
		// a property, respresening a double of value 1.0:

		Property<double> myProp("Parameter A","A demo parameter", 1.0); // not realtime !
		myProp = 10.9; // realtime
		double a = myProp.get(); // realtime
		...
		]]>
	      </programlisting>
	    </example>
	  </para>
	</note>
      </para>
      </sect1>
      <sect1>
	<title>How should I use PropertyBag ?</title>
	<para>
        First of all, a PropertyBag is not the owner of the properties it owns,
        it merely keeps track of them, it defines a logical group of properties
        belonging together. Thus when you delete a bag, the properties in it are
        not deleted, when you clone() a bag, the properties are not cloned
        themselves. PropertyBag is thus a container of pointers to Property objects.
	</para>
    <para>
        If you want to duplicate the contents of a PropertyBag or perform recursive
        operations on a bag, you can use the helper functions we created and which
        are defined in <filename>PropertyBag.hpp</filename> (see Doxygen documentation).
        These operations are however, most likely not realtime.
    </para>
    <note><para>When you want to put a PropertyBag into another PropertyBag, you need
        to make a Property&lt;PropertyBag&gt; and insert that property into the 
        first bag.</para>
    </note>
      </sect1>
      <sect1>
	<title>Marshalling and demarshalling</title>
	<para>
        Marshalling is converting an object from machine code to a code suitable
        for transportation or storage. When an object is marshalled, a copy is made
        so that it can be restored in its original state. Demarshalling instantiates
        the object again from the marshalled copy. Common formats of marshalling are
        writing out properties or efficient binary memory copies. So properties are
        just an example of objects that can be marshalled. We wrote however specific
        marshallers for properties and property bags. These are the 
        SimpleMarshaller, XMLMarshaller, XMLRPCMarshaller, INIMarshaller and
        the CPFMarshaller (for CORBA). You will need the <ulink
        url="http://xml.apache.org/xerces-c/index.html">Xerces</ulink> library for the XML
        related marshalling.
	</para>
	<para>
	  The marshaller uses the <classname>PropertyIntrospectionInterface</classname>
	  for inspecting the type of a Property. This mechanism is called 
	  double dispatching. Double dispatching is an extension of the standard C++
      single dispatching also known as virtual functions. When a virtual
      function is called, the method which will be invoked is dependent on the
      object on which it gets invoked. With double dispatching, after the first
      dispatching on the object itself, there's a second dispatching done on one
      of the parameters of the function.
	</para>
    </sect1>
  </chapter>
  <chapter>
    <title>The NameServer</title>
    <sect1>
      <title>Introduction</title>
      <para>
	A key element in the &orocos; framework is what we call the strong typed
	nameserver. It is a (string based) nameserver which stores name, object pairs
	of only one type of object in the local program. 
	Off course, polymorphism allows us to collect many
	derivative types into one nameserver. A nameserver allows late configuration
	of objects. All possible used objects are created first and stored in the
	nameserver. Depending of the run-time users choice (from a text file,
	console input,...), another object is retrieved from the nameserver and
	used in the program.
      </para>
    </sect1>
    <sect1>
      <title>Using the NameServer</title>
      <para>
	The header is called <filename>NameServer.hpp
	</filename> and the API is quite straight forward. The most common usage
	syntax is given below. The Doxygen documentation contains the full API.
      </para>
      <note><para>
	The most common use of nameserving is keeping track of pointers to objects.
	A NameServer almost always takes pointers to an object as arguments and 
	returns a pointer when the object is looked up again.</para>
      </note>
      <programlisting>
	NameServer&lt; ClassA* &gt; nameserver; // A NameServer collecting pointers to ClassA objects
	ClassA my_a;
	nameserver.registerObject( &amp;my_a, "ATeam" );
	// ...
	ClassA* an_a = nameserver.getObject( "ATeam" );
	if (an_a != 0 )
	    cout &lt;&lt; "ATeam was successfully stored and retrieved !" &gt;&gt; endl;
      </programlisting>
      <para>
	A typical use of nameserving is that the nameserver is nested inside the class
	it is nameserving itself. For convenience, the constructor of that class is then
	extended to take a string as argument to indicate the (optional) desired name
	of the object. Imagine that the above ClassA had such a nested nameserver,
	in that case, it would be used as follows :
      </para>
      <programlisting>
	ClassA my_a( "The ATeam" ); // give name in constructor
	// ...
	// notice the scope ClassA:: the nameserver is nested in :
	ClassA* an_a = ClassA::nameserver.getObject( "The ATeam" );
	if (an_a != 0 )
	    cout &lt;&lt; "The ATeam was successfully stored and retrieved !" &gt;&gt; endl;
      </programlisting>
      <para>
	The above technique is used in many classes inside &orocos;. Events, Devices, 
	Control Kernels and Components, ... anything you wish to configure at runtime
	can be nameserved.
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>Reporting</title>
    <sect1>
      <title>Introduction</title>
      <para>
	Having a realtime process running is one thing, knowing what its internal status
	is is another. Reporting is made in such a way that existing components can
	be extended with a Reporting Stub, which creates reports of the internal state
	of variables and waits for client requests to update or export the data. 
	A client can then ask each existing Stub to create and
	deliver a report. A timestamp is used to tag all data. When the client
	has collected all reports, it may transform it to another format, for example,
	in a log file or a display on screen. We call these clients often ReportWriters
	since they write out the gathered reports in one or another format.
	An example of an application is a realtime robot component
	which delivers every 10ms its position, velocity and sensor data 
	to a userspace map building application.
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>Fifos</title>
    <sect1>
      <title>A warning</title>
      <warning>
	<para>
	  The fifos implementation is slightly outdated and unmaintained in the latest releases.
	  You might expect problems when trying to use them. In the past they were used to 
	  communicate from kernel space to userspace programs, but since the Orocos Framework is now 
	  completely situated in userspace, this communication has become obsolete.
	</para>
      </warning>
    </sect1>
    <sect1>
      <title>Using fifos</title>
      <para>
	Fifos are used to send data from one address space to another. For example
	from realtime to userspace or vice versa. We have four kind of fifos :
      <itemizedlist>
	<listitem><para>FifoRTIn : Used to read data in realtime from a realtime fifo</para></listitem>
	<listitem><para>FifoRTOut: Used to write data in realtime to a realtime fifo</para></listitem>
	<listitem><para>FifoUSIn : Used to read data in userspace from a realtime fifo</para></listitem>
	<listitem><para>FifoUSOut: Used to write data in userspace to a realtime fifo</para></listitem>
      </itemizedlist>
      Furthermore, one can still use the FifoRTIn/Out in userspace simulations.
      They will act as if they get their data from real fifos. The API documentation should
      be clear about how to use them.
    </para>
    <para>
      Components requireing data communition will indicate this with a <classname> WriteInterface
      </classname>,<classname>ReadInterface</classname> or <classname>ObservableReadInterface 
      </classname> in their constructors argument list.
      All fifos implement one of these interfaces.
    </para>
    <note>
      <para>
	For examining which data would be sent through a fifo, one can always temporarily
	use a <classname>WriteCout</classname> object instead of a fifo, which will print the data
	to the screen instead of delivering it.
      </para>
    </note>
    </sect1>
  </chapter>
</book>
