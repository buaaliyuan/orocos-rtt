Drivers/canbus

The canbus subdirectory provides can device drivers and canopen 
protocol implementations. Layer 2 is provided by the CANPie
subdirectory. We wrote our own CANPie 'core' functions to interact
with our home made can chip driver.

The CANOpen protocol is provided by the CANFestival implementation.



Notes on LXRT
------------

On has to decide which part is userspace/kernelspace of the 
driver for lxrt. For now, the 'core' functions would be wrapped
to extended lxrt calls so that the device driver is in kernel space
and CANPIE is in userspace. CANFestival is in userspace too then.

This has the disadvantage that the can implementation can not be
directly interrupt driven. For this to be possible, a callback
mechnism kernel-->userspace must be provided analog to the comedi
solution. The mechanism is as follows  : 

1. The user creates a counting semaphore and registers it with the
kernel system using a standard extended lxrt call.
2. The kernel system receives the semaphore and registers a callback
function to the interrupt handler which will signal the semaphore
when it is called.
3. The user waits on the semaphore in a separate thread.
4. When the semaphore is signaled, the user will awake and can react
to it. This is analogue to the resume_from_interrupt examples, also
delivered with lxrt.

Another alternative is to keep the interrupts completely in the kernel
and poll from user-lxrt side some mailboxes/ shared memory etc.