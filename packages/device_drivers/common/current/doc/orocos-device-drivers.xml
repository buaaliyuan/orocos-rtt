<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title> Orocos Device Drivers </title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2003,2004</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

    <abstract>
      <para>
	This document explains what device drivers are
	standard available in Orocos.
      </para>
    </abstract>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation, with no Invariant Sections, with no
	Front-Cover Texts, and with no Back-Cover Texts. A copy of
	this license can be found at <ulink
	  url="http://www.fsf.org/copyleft/fdl.html">
	  http://www.fsf.org/copyleft/fdl.html </ulink>.
      </para>
    </legalnotice>
  </articleinfo>

  <sect1>
    <title>Introduction</title>
    <para>
      This section gives you the basic knowledge to start working with the
      Orocos Device Drivers package.
    </para>

    <sect2>
      <title>Requirements</title>
      <para>
	This package has a dependency on the Orocos Core Library and
	Orocos-device_interface packages. So you need to install that
	package first before you can proceed. Further, this package
	extends the <ulink url="http://www.comedi.org">comedi</ulink>
	library and integrates it into the framework. Comedi is a
	realtime device drivers package and supports a lot of
	hardware. You might want to install comedi and comedilib when
	they support your hardware or if you want to port your home
	made drivers to comedi. We refer to their website for
	installation instructions.
      </para>
      <para>
	The device drivers come with kernel modules that use the
	(realtime) OS. RTAI/LXRT offers realtime execution in kernel
	and userspace and a mechanism to communicate between both
	(called LXRT Extensions). If you want to convert your own
	device driver to RTAI/LXRT like within Orocos, you can read
	the <ulink url="http://people.mech.kuleuven.ac.be/~psoetens/lxrt/portingtolxrt.html">
	  Porting to LXRT HOWTO</ulink>.
      </para>
    </sect2>
    <sect2>
      <title>What's in this package</title>
      <para>
        <itemizedlist>
	  <listitem>
	    <para>This package contains a primitive wrapper to the
	      kernel comedi functionality and comedilib
	      (userspace).</para></listitem>
	  <listitem>
	    <para>A home made driver for the APCI1710, APCI2200 and
	      APCI1032 PCI cards and a C++ classes for
	      reading/resetting the cards and some event
	      handling.</para></listitem>
	  <listitem>
	    <para>An Axis implementation.</para></listitem>
	  <listitem>
	    <para>A CANOpen implementation using <ulink
		url="http://www.microcontrol.net/CANpie/">
		CANPie</ulink>. Currently reading/writing
	      Digital/Analog IO are supported and reading SSI encoders
	      over the bus. Our setup CAN node was a Beckhoff coupler,
	      with these terminals installed.
	    </para>
	  </listitem>
	  <listitem>
	    <para>Classes for reading SSI encoders and incremental
	      encoders.</para></listitem>
	  <listitem>
	    <para>A sample implementation for wrapping the whole
	      Comedi Library to C++</para></listitem>
	  <listitem>
	    <para>Device driver and classes for reading the JR3 6 DOF
	      Force Sensor</para></listitem>
        </itemizedlist>
	The aim of this package is to show how a
	driver can implement one or more interfaces of the Device
	Interface Package. Other packages will exclusively refer to
	the device interfaces, and the decision of which driver to
	actually use, can be deferred until run time.
      </para>
      <para>
	All device drivers consist of two major parts. First a C
	kernel module, with realtime support, to communicate with the
	hardware and offer a C interface to 'the outside'. Second a
	C++ class using the C interface and representing the device as
	a C++ object. This class uses the Orocos Core Library for more
	advanced features like polling or nameserving. It also
	implements one of the Device Interfaces, so that the hardware
	is properly abstracted.
      </para>
    </sect2>
    <sect2>
    <title>Installation</title>
      <para>
	We refer to the orocos-installation manual on how to install
	this package.
      </para>
      <para>
	Most device drivers are configurable in the configtool
	menus so that they match the card configuration.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Developers Documentation</title>
    <para>
      All the drivers code resides in the
      <classname>ORO_DeviceDriver</classname> namespace. An Orocos
      Device Driver is a class which implements one or more interfaces
      of the <ulink
	url="http://people.mech.kuleuven.ac.be/~psoetens/orocos/doc/orocos-device-interface.html"> 
	Device Interface</ulink>.
    </para>
    <sect2>
      <title>Comedi C++</title>
      <para>
	We have currently two Comedi C++ implementations. The one in
	the main source tree provides
	<classname>ComediDevice</classname>,
	<classname>ComediSubDeviceAIn </classname> and <classname>
	  ComediSubDeviceAOut</classname> classes which provide basic
	device access and nameserving. The wrapper classes
	<classname>ComediSubDeviceAOut</classname> and
	<classname>ComediSubDeviceAIn</classname> show how the
	<classname>AnalogOutInterface</classname> and the
	<classname>AnalogInInterface</classname> interfaces of the FDI
	can be implemented. A more extended, but experimental
	implementation can be found in the comedi subdirectory. We do
	not currently use it, but you are encouraged to experiment
	with it or provide us suggestions and patches :-).
      </para>
    </sect2>
    <sect2>
      <title>Logical Device Drivers</title>
      <para>
	This contains implementation of logical devices such as DigitalInput,
	DigitalOutput, AnalogInput, AnalogOutput, Axis, AnalogDrive,... they are
	access-wrappers around the more general IO Interfaces. They require
	the corresponding Device Interface to communicate with.
      </para>
      <sect3>
	<title>Analog and Digital IO</title>
	<para>
	  Helpfull utility classes AnalogInput, AnalogOutput, DigitalInput
	  and DigitalOutput provide a 1 channel access to a device interface.
	  They take on construction two parameters : the device interface
	  they should operate on and the channel of that device they
	  represent.
	</para>
      </sect3>
      <sect3>
	<title>The Axis class</title>
	<para>
	  The Axis is parameterised by an Encoder, a Drive and Breaks.
	  It manages these resources in a consistent way, allowing 
	  callibration and unit ( velocity to volts ) conversions.
	  The Axis is needed to interpret encoder 'counts' to 
	  pysical units (translation or rotation). It associates
	  three dependent hardware parts in one object.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>CANPie and CANOpen Device Drivers</title>
      <para>
	Orocos has an application independent implementation of
	a part of the CANOpen protocol, especially for IO and reading
	SSI encoders. CANPie is used as the controller abstraction and
	a linux kernel module for the Philips SJA 1000 is provided. The
	device driver works in realtime with RTAI/LXRT. Node Guarding
	and proper setup/cleanup are implemented using the Orocos
	Core Library. Class documentation can be found on the Doxygen
	pages.
      </para>
    </sect2>
  </sect1>
</article>
