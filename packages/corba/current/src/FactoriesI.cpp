// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:910

#include "corba/FactoriesI.h"
#include "corba/ExecutionI.h"

using namespace Orocos;
using namespace ORO_Execution;
using namespace ORO_CoreLib;
using namespace ORO_Corba;
using namespace std;

// Implementation skeleton constructor
Orocos_MethodInterface_i::Orocos_MethodInterface_i (GlobalMemberFactory* gmf)
    :mfact(gmf)
{
}

// Implementation skeleton destructor
Orocos_MethodInterface_i::~Orocos_MethodInterface_i (void)
{
}

::Orocos::ObjectList * Orocos_MethodInterface_i::getObjects (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    vector<string> flist = mfact->getObjectList();
    ObjectList_var rlist = new ObjectList();
    rlist->length( flist.size() );
    for (size_t i=0; i != flist.size(); ++i)
        rlist[i] = CORBA::string_dup( flist[i].c_str() );
    return rlist._retn();
}

::Orocos::MethodList * Orocos_MethodInterface_i::getMethods (
    const char * obj
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
  ))
{
    MethodList_var rlist = new MethodList();
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0)
        throw Orocos::NoSuchObjectException( obj );

    vector<string> flist = ofact->getNames();
    rlist->length( flist.size() );
    for (size_t i=0; i != flist.size(); ++i)
        rlist[i] = CORBA::string_dup( flist[i].c_str() );
    return rlist._retn();
}

::Orocos::Descriptions * Orocos_MethodInterface_i::getArguments (
      const char * obj, 
      const char* method
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      ,Orocos::NoSuchObjectException
      ,Orocos::NoSuchNameException
      ))
{
    Descriptions_var ret = new Descriptions();
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasMember( string( method ) ) == false )
        throw Orocos::NoSuchNameException( method );
    // method found, convert args:
    MemberFactoryInterface::Descriptions args = ofact->getArgumentList( string(method) );
    ret->length( args.size() );
    for (size_t i =0; i != args.size(); ++i) {
        ret[i].name = CORBA::string_dup( args[i].name.c_str() );
        ret[i].description = CORBA::string_dup( args[i].description.c_str() );
        ret[i].type = CORBA::string_dup( args[i].type.c_str() );
    }
    return ret._retn();
}
  
 char * Orocos_MethodInterface_i::getResultType (
      const char * obj, 
      const char* method
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      ,Orocos::NoSuchObjectException
      ,Orocos::NoSuchNameException
    ))
{
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasMember( string( method ) ) == false )
        throw Orocos::NoSuchNameException( method );
    return CORBA::string_dup( ofact->getResultType( string(method) ).c_str() );
}
  
 char * Orocos_MethodInterface_i::getDescription (
      const char * obj, 
      const char* method
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      ,Orocos::NoSuchObjectException
      ,Orocos::NoSuchNameException
    ))
{
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasMember( string( method ) ) == false )
        throw Orocos::NoSuchNameException( method );
    return CORBA::string_dup( ofact->getDescription( string(method) ).c_str() );
}

::Orocos::Method_ptr Orocos_MethodInterface_i::createMethod (
    const char * obj,
    const char * method,
    const ::Orocos::Arguments& args
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ,Orocos::WrongNumbArgException
    ,Orocos::WrongTypeArgException
  ))
{
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasMember( string( method ) ) == false )
        throw Orocos::NoSuchNameException( method );
    // convert Corba args to C++ args.
    MemberFactoryInterface::Arguments nargs;
    nargs.reserve( args.length() );
    for (size_t i =0; i != args.length(); ++i)
        nargs.push_back( ExpressionProxy::Create( Expression::_duplicate( args[i] ) ) );
    // create a local data source and a new method servant to serve it.
    try {
        return ofact->create( string(method), nargs )->method();
    } catch ( name_not_found_exception& nnf ) {
        throw Orocos::NoSuchNameException( method );
    } catch ( wrong_number_of_args_exception& wna ) {
        throw Orocos::WrongNumbArgException( wna.wanted, wna.received );
    } catch (wrong_types_of_args_exception& wta ) {
        throw Orocos::WrongTypeArgException( wta.whicharg, wta.expected_.c_str(), wta.received_.c_str() );
    }
    return Orocos::Method::_nil();
}

::Orocos::Method_ptr Orocos_MethodInterface_i::createMethodAny (
    const char * obj,
    const char * method,
    const ::Orocos::AnyArguments& args
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ,Orocos::WrongNumbArgException
    ,Orocos::WrongTypeArgException
  ))
{
    const MemberFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasMember( string( method ) ) == false )
        throw Orocos::NoSuchNameException( method );
    // convert Corba args to C++ args.
    MemberFactoryInterface::Arguments nargs;
    nargs.reserve( args.length() );
    for (size_t i =0; i != args.length(); ++i)
        nargs.push_back( new ValueDataSource<CORBA::Any_var>( new CORBA::Any( args[i] ) ) );
    // create a local data source and a new method servant to serve it.
    try {
        return ofact->create( string(method), nargs )->method();
    } catch ( name_not_found_exception& nnf ) {
        throw Orocos::NoSuchNameException( method );
    } catch ( wrong_number_of_args_exception& wna ) {
        throw Orocos::WrongNumbArgException( wna.wanted, wna.received );
    } catch (wrong_types_of_args_exception& wta ) {
        throw Orocos::WrongTypeArgException( wta.whicharg, wta.expected_.c_str(), wta.received_.c_str() );
    }
    return Orocos::Method::_nil();
}

// Implementation skeleton constructor
Orocos_CommandInterface_i::Orocos_CommandInterface_i (GlobalCommandFactory* gcf)
    :mfact(gcf)
{
}

// Implementation skeleton destructor
Orocos_CommandInterface_i::~Orocos_CommandInterface_i (void)
{
}

::Orocos::ObjectList * Orocos_CommandInterface_i::getObjects (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    vector<string> flist = mfact->getObjectList();
    ObjectList_var rlist = new ObjectList();
    rlist->length( flist.size() );
    for (size_t i=0; i != flist.size(); ++i)
        rlist[i] = CORBA::string_dup( flist[i].c_str() );
    return rlist._retn();
}

::Orocos::CommandList * Orocos_CommandInterface_i::getCommands (
    const char * obj
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
  ))
{
    CommandList_var rlist = new CommandList();
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );

    vector<string> flist = ofact->getCommandList();
    rlist->length( flist.size() );
    for (size_t i=0; i != flist.size(); ++i)
        rlist[i] = CORBA::string_dup( flist[i].c_str() );
    return rlist._retn();
}

::Orocos::Descriptions * Orocos_CommandInterface_i::getArguments (
      const char * obj, 
      const char* command
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ))
{
    Descriptions_var ret = new Descriptions();
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasCommand( string( command ) ) == false )
        throw Orocos::NoSuchNameException( command );
    // method found, convert args:
    CommandFactoryInterface::Descriptions args = ofact->getArgumentList( string(command) );
    ret->length( args.size() );
    for (size_t i =0; i != args.size(); ++i) {
        ret[i].name = CORBA::string_dup( args[i].name.c_str() );
        ret[i].description = CORBA::string_dup( args[i].description.c_str() );
        ret[i].type = CORBA::string_dup( args[i].type.c_str() );
    }
    return ret._retn();
}

  
 char * Orocos_CommandInterface_i::getResultType (
      const char * obj, 
      const char* command
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ))
{
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasCommand( string( command ) ) == false )
        throw Orocos::NoSuchNameException( command );
    return CORBA::string_dup( ofact->getResultType( string(command) ).c_str() );
}
  
 char * Orocos_CommandInterface_i::getDescription (
      const char * obj, 
      const char* command
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ))
{
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasCommand( string( command ) ) == false )
        throw Orocos::NoSuchNameException( command );
    return CORBA::string_dup( ofact->getDescription( string(command) ).c_str() );
}

::Orocos::Command_ptr Orocos_CommandInterface_i::createCommand (
    const char * obj,
    const char * command,
    const ::Orocos::Arguments& args
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ,Orocos::WrongNumbArgException
    ,Orocos::WrongTypeArgException
  ))
{
  // Add your implementation here
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasCommand( string( command ) ) == false )
        throw Orocos::NoSuchNameException( command );
    // convert Corba args to C++ args.
    // Use CommandC:
    try {
        CommandC comc = mfact->create( std::string( obj ), string( command ) );
        for (size_t i =0; i != args.length(); ++i)
            comc.arg( DataSourceBase::shared_ptr(ExpressionProxy::Create( Expression::_duplicate(args[i]) )) );
        // servant uses that object:
        Orocos_Command_i* com = new Orocos_Command_i( comc );
        return com->_this();
    } catch ( name_not_found_exception& nnf ) {
        throw Orocos::NoSuchNameException( command );
    } catch ( wrong_number_of_args_exception& wna ) {
        throw Orocos::WrongNumbArgException( wna.wanted, wna.received );
    } catch (wrong_types_of_args_exception& wta ) {
        throw Orocos::WrongTypeArgException( wta.whicharg, wta.expected_.c_str(), wta.received_.c_str() );
    }
    return ::Orocos::Command::_nil();
}

::Orocos::Command_ptr Orocos_CommandInterface_i::createCommandAny (
    const char * obj,
    const char * command,
    const ::Orocos::AnyArguments& args
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
    ,Orocos::NoSuchObjectException
    ,Orocos::NoSuchNameException
    ,Orocos::WrongNumbArgException
    ,Orocos::WrongTypeArgException
  ))
{
  // Add your implementation here
    const CommandFactoryInterface* ofact = mfact->getObjectFactory( std::string( obj ) );
    if ( ofact == 0 )
        throw Orocos::NoSuchObjectException( obj );
    if ( ofact->hasCommand( string( command ) ) == false )
        throw Orocos::NoSuchNameException( command );
    // convert Corba args to C++ args.
    // Use CommandC:
    try {
        CommandC comc = mfact->create( std::string( obj ), string( command ) );
        for (size_t i =0; i != args.length(); ++i)
            comc.arg( DataSourceBase::shared_ptr( new ValueDataSource<CORBA::Any_var>( new CORBA::Any( args[i] ) )));
        // servant uses that object:
        Orocos_Command_i* com = new Orocos_Command_i( comc );
        return com->_this();
    } catch ( name_not_found_exception& nnf ) {
        throw Orocos::NoSuchNameException( command );
    } catch ( wrong_number_of_args_exception& wna ) {
        throw Orocos::WrongNumbArgException( wna.wanted, wna.received );
    } catch (wrong_types_of_args_exception& wta ) {
        throw Orocos::WrongTypeArgException( wta.whicharg, wta.expected_.c_str(), wta.received_.c_str() );
    }
    return ::Orocos::Command::_nil();
}

