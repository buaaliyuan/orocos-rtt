// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:910

#include "corba/ControlTaskI.h"
#include "corba/ControlTaskServer.hpp"
#include "corba/ControlTaskProxy.hpp"
#include "corba/CosPropertyServiceI.h"
#include "corba/AttributesI.h"
#include "corba/FactoriesI.h"
#include "corba/ScriptingAccessI.h"

using namespace ORO_Execution;
using namespace ORO_CoreLib;
using namespace ORO_Corba;
using namespace CosPropertyService;

// Implementation skeleton constructor
Orocos_ControlTask_i::Orocos_ControlTask_i (TaskContext* orig)
    : mtask( orig ), mCosProps( ), mMFact(), mCFact(), mEEFact()
{
    // Add the corba object to the interface:
    TemplateMethodFactory<Orocos_ControlTask_i>* cfact = newMethodFactory(this);
    cfact->add("shutdown", method( &Orocos_ControlTask_i::shutdownCORBA,
                                   "Shutdown CORBA ORB. This function makes RunOrb() return."));
    mtask->methods()->registerObject( "CORBA", cfact );

}

  void Orocos_ControlTask_i::shutdownCORBA() {
	  ControlTaskServer::ShutdownOrb(false);
  }


// Implementation skeleton destructor
Orocos_ControlTask_i::~Orocos_ControlTask_i (void)
{
}

::CosPropertyService::PropertySet_ptr Orocos_ControlTask_i::propertySet (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    // create and activate servant.
    if ( CORBA::is_nil( mCosProps) ) {
        Logger::log() << Logger::Info << "Creating PropertySet."<<Logger::endl;
        CosPropertyService_PropertySet_i* props = new CosPropertyService_PropertySet_i( mtask->attributes()->properties() );
        mCosProps = props->_this();
    }
    return PropertySet::_duplicate( mCosProps.in() );
}

::Orocos::AttributeInterface_ptr Orocos_ControlTask_i::attributes (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    if ( CORBA::is_nil( mAttrs) ) {
        Logger::log() << Logger::Info << "Creating AttributeInterface."<<Logger::endl;
        Orocos_AttributeInterface_i* attrs = new Orocos_AttributeInterface_i( mtask->attributes() );
        mAttrs = attrs->_this();
    }
    return Orocos::AttributeInterface::_duplicate( mAttrs.in() );
#if 0
    // create and activate servant.
    if ( CORBA::is_nil( mCosAttrs) ) {
        Logger::log() << Logger::Info << "Creating Attributes PropertySet."<<Logger::endl;
        CosPropertyService_PropertySet_i* props = new CosPropertyService_PropertySet_i( mtask->attributes() );
        mCosProps = props->_this();
    }
    return PropertySet::_duplicate( mCosProps.in() );
#endif
}


::Orocos::MethodInterface_ptr Orocos_ControlTask_i::methods (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    if ( CORBA::is_nil( mMFact ) ) {
        Logger::log() << Logger::Info << "Creating MethodInterface."<<Logger::endl;
        Orocos_MethodInterface_i* mserv = new Orocos_MethodInterface_i( mtask->methods() );
        mMFact = mserv->_this();
    }
    return Orocos::MethodInterface::_duplicate( mMFact.in() );
}

::Orocos::CommandInterface_ptr Orocos_ControlTask_i::commands (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    if ( CORBA::is_nil( mCFact ) ) {
        Logger::log() << Logger::Info << "Creating CommandInterface."<<Logger::endl;
        Orocos_CommandInterface_i* mserv = new Orocos_CommandInterface_i( mtask->commands() );
        mCFact = mserv->_this();
    }
    return Orocos::CommandInterface::_duplicate( mCFact.in() );
}

::Orocos::ScriptingAccess_ptr Orocos_ControlTask_i::scripting (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    if ( CORBA::is_nil( mEEFact ) ) {
        Logger::log() << Logger::Info << "Creating ScriptingAccess."<<Logger::endl;
        Orocos_ScriptingAccess_i* mserv = new Orocos_ScriptingAccess_i( mtask->scripting() );
        mEEFact = mserv->_this();
    }
    return Orocos::ScriptingAccess::_duplicate( mEEFact.in() );
}


 char* Orocos_ControlTask_i::getName (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) 
{
    CORBA::String_var ret = CORBA::string_dup( mtask->getName().c_str() );
    return ret._retn();
}

::Orocos::ControlTask::ControlTaskNames * Orocos_ControlTask_i::getPeerList (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    TaskContext::PeerList peers = mtask->getPeerList();
    ::Orocos::ControlTask::ControlTaskNames_var result = new ::Orocos::ControlTask::ControlTaskNames();
    result->length( peers.size() );
    for (unsigned int i=0; i != peers.size(); ++i )
        result[i] = CORBA::string_dup( peers[i].c_str() );
    
    return result._retn();
}

::Orocos::ControlTask_ptr Orocos_ControlTask_i::getPeer (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::string pname(name);
    TaskContext* task = mtask->getPeer( pname );
    if ( task ) {
        // create or lookup new server for this peer.
        return ControlTaskServer::Create( task )->server();
    }
    return 0;
}

CORBA::Boolean Orocos_ControlTask_i::addPeer (
    ::Orocos::ControlTask_ptr p,
    const char * alias
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::string malias(alias);
    if (mtask->hasPeer(alias) == false )
        return mtask->addPeer( ControlTaskProxy::Create(p), alias );
    return false;
}

CORBA::Boolean Orocos_ControlTask_i::hasPeer (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::string mname(name);
    return mtask->hasPeer(mname);
}

CORBA::Boolean Orocos_ControlTask_i::removePeer (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::string mname(name);
    mtask->removePeer( mname );
    return true;
}

CORBA::Boolean Orocos_ControlTask_i::connectPeers (
    ::Orocos::ControlTask_ptr p
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    TaskContext* t = ControlTaskProxy::Create( p );
    return mtask->connectPeers( t );
}

CORBA::Boolean Orocos_ControlTask_i::disconnectPeers (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::string pname(name);
    mtask->disconnectPeers( pname );
    return true;
}


