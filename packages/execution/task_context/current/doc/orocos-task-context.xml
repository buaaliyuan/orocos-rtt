<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>
      The Orocos Task Infrastructure Manual
    </title>
    <subtitle>Designing Real-Time Orocos Applications</subtitle>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>2004,2005,2006</year>
      <holder>Peter Soetens</holder>
    </copyright>
    
    <abstract>
      <para>
	This document describes the &orocos; Task Infrastructure, which
	allows to design Real-Time tasks which transparantly communicate
	with each other.
      </para>
    </abstract>
    
    <revhistory>
      <revision>
	<revnumber>0.18.0</revnumber>
	<date>19 Nov 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.20.0</revnumber>
	<date>1 May 2005</date>
	<authorinitials>PS</authorinitials>
	<revremark>Moved TaskBrowser to front and updated to ProgramLoader</revremark>
      </revision>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>January 2006</date>
	<authorinitials>PS</authorinitials>
	<revremark>Updates on new Execution Engine</revremark>
      </revision>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>17 February 2006</date>
	<authorinitials>PS</authorinitials>
	<revremark>Went through biggest part of manual to 'prettyfy' examples.
	Cut out all the developer specific comments.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <section id="task-context-intro">
    <title>Introduction</title>
    <para>
      This manual documents how multi-threaded tasks can be defined in &orocos;
      such that they form a thread-safe robotics/machine control application.
      Each control component is defined as a "TaskContext", which defines 
      the "context" in which the component task is executed. The context
      is built by the five Orocos primitives: Event, Property, Command, Method
      and Data Flow. This document defines how a user can write his own 
      task context and how it can be used in an application.
    </para>
    <figure id="fig-task-peers">
      <title>
	Tasks Run in Threads
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="TaskPeers" />
	</imageobject>
	<caption>
	  <para>
	    Tasks run in (periodic) threads.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      A task is a basic unit of functionality which executes one or more (realtime)
      programs in a single thread. 
      The program can vary from a mere C function over a realtime program script
      to a realtime hierarchical state machine. The focus is completely on 
      thread-safe time determinism. Meaning, that the system is free of priority-inversions,
      and all operations are lock-free (also data sharing and other forms of communication
      such as events and commands). This is done using the mechanisms of the &orocos;
      Real-Time CoreLib which allows each task to run in its own thread or share
      threads. Real-Time tasks can communicate with non Real-Time tasks (and vice versa)
      transparantly. 
    </para>
    <para>
      The Orocos Task Infrastructure enables :
      <itemizedlist>
	<listitem>
	  <para>Lock free, thread-safe, inter-thread function calls.</para>
	</listitem>
	<listitem>
	  <para>Communication between hard Real-Time and non Real-Time threads.</para>
	</listitem>
	<listitem>
	  <para>Deterministic execution time during communication
	  for the higher priority thread.</para>
	</listitem>
	<listitem>
	  <para>Synchronous and asynchronous communication between threads.</para>
	</listitem>
	<listitem>
	  <para>C++ class implementations for all the above.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      This document relates to other manuals as such :
      <glosslist>
	<glossentry>
	  <glossterm>CoreLib</glossterm>
	  <glossdef>
	    <para> provides the Event infrastructure,
	      Task-thread mapping, Properties and lock-free queueing
	      implementations.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Execution Engine</glossterm>
	  <glossdef>
	    <para> provides a real-time program execution framework.
	    It executes the real-time programs which interact with other tasks.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Program Parser</glossterm>
	  <glossdef>
	    <para> provides a scripting language which is convertible to
	    a form which can be accepted by the Execution Engine.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Control Kernel</glossterm>
	  <glossdef>
	    <para> is an application which uses all of the above
	      and provides an (although complex) example of how
	      the &taskpkg; can be used in practice.
	    </para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </para>
    <para>
      The Scripting manual gives more details about script syntax
      for state machines and programs.
    </para>
    <figure id="fig-a-task-context">
      <title>
	Schematic Overview of a TaskContext
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="ATaskContext" />
	</imageobject>
	<caption>
	  <para>The Execution Flow is formed by Programs and
	    State Machines sending commands, events,... to Peer Tasks. The Data Flow
	    is the propagation of data from one task to another, where
	    one producer can have multiple consumers.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      A task's interface consists of : Commands,
      Methods, DataSources, Properties and Events, and Data Flow ports which are all public.
      We will refer to them as <emphasis>members</emphasis>.
      The class <classname>ORO_Execution::TaskContext</classname> 
      groups all these interfaces and serves as the basic building
      block of applications. A component developer 'builds'
      these interfaces using the instructions found in this manual.
    </para>
  </section>
  <section>
    <title>An Introductory Example to TaskContexts</title>
    <para>
      This section introduces tasks through the "taskintro"
      application, which can be downloaded from Orocos.org.  It
      contains three TaskContexts, each showing some features and
      possibilities, <xref linkend="fig-task-intro"/>. The 'FactoringTask' waits for a command to factor
      a number in its primes. When done, it fires an event with the
      result.  The 'ReactiveTask' is a periodic task which waits for
      the events to happen when it is running. The 'PeriodicTask' can
      count to a certain number in each periodic step, when given the
      command to do so. We show some example commands, but the
      application has more methods and commands than presented here.
    </para>
    <figure id="fig-task-intro">
      <title>
	Schematic Overview of the Example.
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="TaskIntro" />
	</imageobject>
	<caption>
	  <para>Three tasks form a network and interact. The
	  TaskBrowser can visit any task.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      The way we interact with TaskContexts during development of an
      Orocos application is through the TaskBrowser.  The
      <classname>ORO_Execution::TaskBrowser</classname> is a powerful console tool
      which helps you to explore, execute and debug
      <classname>ORO_Execution::TaskContext</classname>s in running programs. All you
      have to do is to instantiate a TaskBrowser and enter its loop()
      method. When the program is started from a console, the
      TaskBrowser takes over user input and output.
    </para>
    <note>
      <para>
	The <classname>ORO_Execution::TaskBrowser</classname> requires the
	Orocos Program Parser package to interpret the console input.
      </para>
    </note>
    <programlisting>
  #include &lt;execution/TaskBrowser.hpp&gt;
  #include &lt;os/main.h&gt;
  // ...

  int ORO_main( int, char** )
  {
      // Create your tasks
      <classname>ORO_Execution::TaskContext</classname>* task = ...

      // when all is setup :
      <classname>ORO_Execution::TaskBrowser</classname> tbrowser( task );

      tbrowser.loop();
      return 0;
  }
    </programlisting>
    <para>
      The TaskBrowser uses the GNU readline library to easily
      enter commands to the tasks in your system. This means you
      can press TAB to complete your commands or press the up arrow
      to scroll through previous commands.
    </para>
    <screen>
$ ./taskintro
0.003 [Info] Parsing file CountingSM.osd
0.069 [Info] Loading StateMachine counterMachine
0.074 [Info] ReactiveTaskContext reacting to PrimeEvent !

  This console reader allows you to browse and manipulate TaskContexts.
  You can type in a command, datasource, method, expression or change variables.
  (type 'help' for instructions)
    TAB completion and HISTORY is available ('bash' like)

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :
    </screen>
    <para>
      The first lines are printed by the Orocos ORO_CoreLib::Logger, which has been
      configured to display informative messages to console. You can always
      watch the log file 'orocos.log' in the same directory to see all messages.
    </para>
    <para>
      Depending on what you type, the TaskBrowser will act differently.
      The builtin commands <command>cd</command>, <command>help</command>,
      <command>quit</command> and <command>ls</command> are seen as commands
      to the TaskBrowser itself, if you typed something else,
      it tries to evaluate your command to an expression and will
      print the result to the console. If you did not type an expression,
      it tries to parse it as a command to a (peer) task. If that also
      fails, it means you made a typo and it prints the syntax error
      to console.
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>1+1</command>
      Got :1+1
   = 2
    </screen>
    <para>To display the contents of the current task, type <command>ls</command>,
      and switch to one of the listed peers with <command>cd</command>, while
      <command>cd ..</command> takes you one peer back in history :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls</command>

PeriodicTask Attributes :
    (Attribute  ) int Counter
    (Property   ) PropertyBag ItemCollection
    (Property   ) std::string Parameter
    (Attribute  ) double SpeedOfLight
    (Attribute  ) int Target

PeriodicTask Objects    :  this
PeriodicTask Peers      :  FactoringTask ReactiveTask states

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>cd FactoringTask</command>
   Switched to : FactoringTask

 In Task FactoringTask. (Status of last Command : none )
 (type 'ls' for context info) :ls

FactoringTask Attributes :
    (Attribute  ) int Priority

FactoringTask Objects    :  this
FactoringTask Peers      :  PeriodicTask ReactiveTask

 In Task FactoringTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>cd ..</command>

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :
    </screen>
    <note>
    <para>To get a quick overview of the commands, type
      <command>help</command>.
    </para>
    </note>
    <para>
      Let's revisit the output of <command>ls</command> :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls</command>

PeriodicTask Attributes :
    (Attribute  ) int Counter
    (Property   ) PropertyBag ItemCollection
    (Property   ) std::string Parameter
    (Attribute  ) double SpeedOfLight
    (Attribute  ) int Target

PeriodicTask Objects    :  this
PeriodicTask Peers      :  FactoringTask ReactiveTask states
    </screen>
    <para>
      First you get a list of the Properties and Attributes (alphabetical) of
      the current TaskContext. Propeties can be written to disk, attributes
      are solely for script interaction. Each of them can be changed (except
      constants.) In the example, the current task has only one object: 'this'. The 'this'
      object serves like a public interface of the TaskContext. Objects contain
      methods, commands or datasources. Last, the peers are shown, two other tasks
      and 'states', which denotes that this TaskContext has a StateMachine. Likewise,
      a peer task 'programs' contains all loaded programs.
      To get a list of the Task's interface, you can always type an object name,
      for example 'this'.
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) : <command>this</command>
      Got :this
  Command    : bool countTo( int Target )
   Count to a given number using a StateMachine program.
   Target : Number to count to.
  DataSource : bool isRunning( )
   Is this GenericTaskContext started ?
  Method     : bool assert( bool MustBeTrue )
   Assert will get your program in the error state if the argument is false.
   MustBeTrue : The result of a boolean expression which must be true.
  Method     : bool loadProgram( const&amp; std::string Filename )
   Load an Orocos Program Script from a file.
   Filename : An ops file.
  Method     : bool loadStateMachine( const&amp; std::string Filename )
   Load an Orocos State Description from a file.
   Filename : An osd file.
  Method     : bool readProperties( const&amp; std::string Filename )
   Read Properties from a file.
   Filename : A CPF formatted XML file.
  Method     : bool start( )
   Start this GenericTaskContext.
  Method     : bool stop( )
   Stop this GenericTaskContext.
  Method     : bool unloadProgram( const&amp; std::string ProgramName )
   Unload an Orocos Program Script from a file.
   ProgramName : The Program's name.
  Method     : bool unloadStateMachine( const&amp; std::string StateMachineName )
   Unload an Orocos State Description from a file.
   StateMachineName : A name of a Root StateMachine instantiation.
  Method     : bool writeProperties( const&amp; std::string Filename )
   Write or update Properties to a file.
   Filename : A CPF formatted XML file.
    </screen>
    <para>
      The 'this' object is special in that the command or method must
      not be prefixed by an object name and that it apears as if the
      method is called directly on the task :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :ReactiveTask.stop()
      Got :ReactiveTask.stop()
   = true
    </screen>
    <para>
      'Methods' and 'DataSources' are executed directly by the TaskBrowser itself,
      and then it prints the result. The return value of stop() was a boolean,
      which is 'true'.
    </para>
    <para>
      When a 'Command' is entered, it is sent to the TaskContext itself, which 
      will execute it in its own thread. The different stages of its lifetime are
      displayed by the prompt. Hitting enter will refresh the status line.
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : <emphasis>none</emphasis> )
 (type 'ls' for context info) :<command>countTo(1000)</command>
      Got :countTo(1000)

 In Task PeriodicTask. (Status of last Command : <emphasis>queued</emphasis>)
 (type 'ls' for context info) :2589.528 [Info] PeriodicTaskContext counts to 1000.


 In Task PeriodicTask. (Status of last Command : <emphasis>busy</emphasis> )
 (type 'ls' for context info) :

 In Task PeriodicTask. (Status of last Command : <emphasis>done</emphasis> )
 (type 'ls' for context info) :
    </screen>
    <para>
      A Command might be rejected (return false) by the receiving TaskContext :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : <emphasis>done</emphasis> )
 (type 'ls' for context info) :<command>countTo(-20)</command>
      Got :countTo(-20)

 In Task PeriodicTask. (Status of last Command : <emphasis>queued</emphasis> )
 (type 'ls' for context info) :

 In Task PeriodicTask. (Status of last Command : <emphasis>fail</emphasis> )
 (type 'ls' for context info) :         
    </screen>
    <para>
      Besides giving commands to tasks, you can alter the attributes of 
      any task, program or state machine. The TaskBrowser will confirm
      validity of the assignment with 'true' or 'false' :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls states.counterMachine</command>

counterMachine Attributes :
   int multiplier

counterMachine Objects    :  this
counterMachine Peers      :  states

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>states.counterMachine.multiplier = 20</command>
      Got :states.counterMachine.multiplier = 20
   = true

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>states.counterMachine.multiplier</command>
      Got :states.counterMachine.multiplier
   = 20

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>countTo(200)</command>
      Got :countTo(200)

 In Task PeriodicTask. (Status of last Command : queued )
 (type 'ls' for context info) :60.272 [Info] PeriodicTaskContext counts to 200.


 In Task PeriodicTask. (Status of last Command : done )
 (type 'ls' for context info) :      
    </screen>
    <para>
      Last but not least, hitting TAB twice, will show you a list of
      possible completions, such as peers or commands :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : fail )
 (type 'ls' for context info) :
Counter             cd ..               readProperties
FactoringTask.      countTo             start
ItemCollection      help                states.
Parameter           isRunning           stop
ReactiveTask.       loadProgram         unloadProgram
SpeedOfLight        loadStateMachine    unloadStateMachine
Target              ls                  writeProperties
assert              peers
cd                  quit
 (type 'ls' for context info) : 
    </screen>
    <para>
      TAB completion works even across peers, such that you can type
      a TAB completed command to another peer than the current peer.
    </para>
    <para>
      The TaskBrowser is application independent, so that your enduser-application
      might need a more suitable interface. However, for testing and
      inspecting what is happening inside your realtime programs,
      it is a very useful tool. The next sections show how you can add
      properties, commands, methods etc to a TaskContext.
    </para>
  </section>
  <section id="basic-task">
    <title>Setting Up a Basic Task</title>
    <para>
      Tasks are 
      implemented by the <classname>ORO_Execution::TaskContext</classname> class,
      which should not be confused with the CoreLib periodic Task
      implementations.
      It is useful speaking of a context because it defines
      the context in which the task operates. 
      It defines the interface of the task, its properties,
      its peer tasks and uses its
      <classname>ORO_Execution::ExecutionEngine</classname> to handle its
      programs and to accept commands from other tasks.
    </para>
    <para>
      This section walks you through the definition of an example task
      in order to show you how you could build your own task.
    </para>
    <important>
      <para>
	The ready-to-execute code of this section can be found in the
	'simple-task' package on the <ulink
	url="http://www.orocos.org/download.html">Download</ulink>
	page of the Orocos.org website.
      </para>
    </important>
    <para>
      A <classname>ORO_Execution::TaskContext</classname> is constructed as :
    </para>
    <para>
      <programlisting>
  #include &lt;execution/TaskContext.hpp&gt;

  // we assume this is done in all the following code listings :
  using namespace ORO_Execution;

  <classname>ORO_Execution::TaskContext</classname> a_task("ATask");
      </programlisting>
    </para>
    <para>
      The argument is the (unique) name of the task.
    </para>
    <para>
      A task's interface consists of : Commands, Methods, DataSources,
      Attributes and Properties and Events, which are all public.  We
      will refer to them as <emphasis>members</emphasis>.  The
      TaskContext exports its interface members (to other tasks) by
      means of object factories.  Which members are exported is up to
      the application. The factories are required to map the interface
      of a task to internal, application specific, C++ methods.
    </para>
    <figure id="fig-a-task-context-intro">
      <title>
	Schematic Overview of a TaskContext
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="ATaskContext" />
	</imageobject>
	<caption>
	  <para>The Execution Flow is formed by Programs and
	    State Machines sending commands to Peer Tasks. The Data Flow
	    is the propagation of data from one task to another, where
	    one producer can have multiple consumers.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      When a TaskContext is running, it accepts commands or events using its
      Execution Engine.  The Execution Engine will check periodically
      for new commands in it's queue and execute programs which are
      running in the task. Thus to start using the task, one needs to start
      the Execution Engine.  As long as it is not started, it will accept no
      commands and run no programs.
    </para>
    <section><title>Task Application Code</title>
    <para>
      The user may insert his application code in the
      <function>startup()</function>,
      <function>update()</function> and
      <function>shutdown()</function> functions of a TaskContext
      by inheriting from that class. Orocos provides an 'enhanced'
      TaskContext, the <classname>ORO_Execution::GenericTaskContext</classname>
      which we will use in the examples to encourage users to
      use this class:
    </para>
    <programlisting>  #include &lt;execution/GenericTaskContext.hpp>
  class MyTask 
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
  public:
       MyTask(std::string name) 
         : <classname>ORO_Execution::GenericTaskContext</classname>(name)
       {
          // see lateron what to put here.
       }
  
       /**
        * This function contains the application's startup code.
	* Return false to abort startup.
	*/
       bool startup() {
          // ...
	  return true;
       }

       /**
        * This function is periodically called.
	*/
       void update() {
          // Your algorithm for periodic execution goes inhere
       }

       /**
        * This function is called when the task is stopped.
	*/
       void shutdown() {
          // Your cleanup code
       }
  };</programlisting>
    <para>
      When a TaskContext is started, <function>startup()</function> is
      called once and may abort the startup sequence by returning
      false, for example, because of misconfiguration. When all went
      well, <function>update()</function> is called (a)periodically by
      the ExecutionEngine, see below.  When the task is stopped,
      <function>shutdown()</function> is called after the last
      <function>update()</function>.
    </para>
    </section>
    <section>
      <title>Starting Task Execution</title>
      <para>
	The functionality of a task, i.e. its algorithm, is executed
	in a thread by the Execution Engine.  To run an
	<classname>ORO_Execution::ExecutionEngine</classname>, you
	need to use one of the
	<classname>ORO_CoreLib::TaskInterface</classname> classes from
	the CoreLib. ( See the &coreman; for more documentation. ) The
	<classname>TaskInterface</classname> object will invoke the
	ExecutionEngine, which will in turn invoke the application's
	methods above.
	<programlisting>
  #include &lt;corelib/TaskNonPreemptible.hpp&gt;

  using namespace ORO_CoreLib;

  <classname>ORO_Execution::TaskContext</classname>* a_task = new MyTask("the_task")
  // ... start the execution engine of a_task :
  <classname>ORO_CoreLib::TaskNonPreemptible</classname> periodicTask(0.001, a_task->engine() );
  periodicTask.start(); 
  // ...
  periodicTask.stop();</programlisting></para>
      <para>
	Which will run the Execution Engine of "ATask" with a timer
	frequency of 1kHz. This is the frequency at which state
	machines are evaluated, program steps taken, commands and
	events are accepted and executed and the application code is
	run. When the periodic task is stopped again, all programs are
	stopped, state machines are brought into the final state and
	no more commands or events are accepted.
      </para>
      <para>
	A TaskContext can also be run in a non periodic task:
	<programlisting>
  #include &lt;corelib/TaskNonPeriodic.hpp&gt;

  using namespace ORO_CoreLib;

  <classname>ORO_Execution::TaskContext</classname>* a_task = new MyTask("the_task")
  // ... start the execution engine of a_task :
  <classname>ORO_CoreLib::TaskNonPeriodic</classname> nonpTask(5, a_task->engine() );
  nonpTask.start(); 
  // ...
  nonpTask.stop();</programlisting></para>
      <para>
	In case the Execution Engine waits for new Commands or Events to
	come in to be executed. Each time such an event happens, the user's
	application code (<function>update()</function>) is called as well.
      </para>
    </section>
    <section>
      <title>Interfacing the TaskContext</title>
      <para>
	During development of your TaskContext, it is handy to connect
	the <classname>ORO_Execution::TaskBrowser</classname> to your
	task such that you can interactively manipulate it and it's 
	properties:
	<programlisting>  #include &lt;execution/TaskBrowser.hpp>
  // ... see above
  <classname>ORO_Execution::TaskBrowser</classname> browser(a_task);

  // Start the interactive console:
  browser.loop();</programlisting>
        In which you can start/stop the task and manipulate every
	aspect of it's interface, as was seen in the previous section.
      </para>
    </section>
    <section>
      <title>Introducing the TaskContext's Interface</title>
      <para>
	A TaskContext exists of a number of accessor methods which
	expose a specific part of the interface. These methods are:
    </para>
    <para>
      <programlisting>  a_task.ports();
  a_task.methods();
  a_task.attributes();
  a_task.commands();
  a_task.events();
      </programlisting>
      The meaning of these factories are explained in the following
      sections.
    </para>
    </section>
    <section>
      <title>The Data Flow Interface</title>
      <note><title>Purpose</title><para>The 'Data Flow' is
      a 'stream of data' between tasks. A classical control
      loop can be implemented using the Data Flow interface.
      The data is passed buffered or unbuffered from one
      task to another.
      </para></note>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="DataFlowInterface" />
	</imageobject>
      </mediaobject>
      <para>
	The Orocos Data Flow is implemented with the
	<emphasis>Port-Connector</emphasis> software pattern. Each
	task defines its data exchange ports and inter-task connectors
	transmit data from one port to another. A Port is defined by a
	name, unique within that task, the data type it wants to
	exchange and the buffered or un-buffered method of exchanging.
	Buffered exchange is done by "Buffer" Ports and un-buffered
	exchange is done by "Data" Ports.
      </para>
      <para>
	A Data Port can offer read-only access or read-write access
	to the unbuffered data. A Buffer Port can offer read-only,
	write-only and read-write access to the buffered data.
	The example below shows all these possiblities.
      </para>
      <section>
	<title>Setting up the Data Flow Interface</title>
	<important>
	  <para>
	    The ready-to-execute code of this section can be found in the
	    'dataflow-task' package on the <ulink
	    url="http://www.orocos.org/download.html">Download</ulink>
	    page of the Orocos.org website.
	  </para>
	</important>
	<para>
	  Any kind of data can be exchanged (also user defined types)
	  but for readability, only the 'double' C type is used here.
	  <programlisting>  #include &lt;execution/Ports.hpp&gt;
  using namespace ORO_Execution;

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
    // Read-only data port:
    <classname>ORO_Execution::ReadDataPort</classname>&lt;double&gt; indatPort;
    // Read-Write data port:
    <classname>ORO_Execution::WriteDataPort</classname>&lt;double&gt; outdatPort;

    // Read-only buffer port:
    <classname>ORO_Execution::ReadBufferPort</classname>&lt;double&gt; inbufPort;
    // Write-only buffer port:
    <classname>ORO_Execution::WriteBufferPort</classname>&lt;double&gt; outbufPort;
    // Read-Write buffer port:
    <classname>ORO_Execution::BufferPort</classname>&lt;double&gt; rwbufPort;
  public:
    // ...
    MyTask(std::string name)
      : <classname>ORO_Execution::GenericTaskContext</classname>(name),
        indatPort("Data_R"),
	outdatPort("Data_W"),
	inbufPort("SetPoint_X"),
	outbufPort("Packet_1", 15), // note: buffer size
	rwbufPort("Packet_2", 30)
    {
       this->ports()->addPort( &amp;indatPort );
       this->ports()->addPort( &amp;outdatPort );
       this->ports()->addPort( &amp;inbufPort );
       this->ports()->addPort( &amp;outbufPort );
       this->ports()->addPort( &amp;rwbufPort );

       // more additions to follow, see below
     }

     // ...
  };</programlisting>
      </para>
      <para>
	The example starts with declaring all the ports of
	MyTask. A template parameter specifies the type of data the 
	task wants to exchange through that port. Logically, if two
	tasks are connected, they must agree on this type.
	The constructor of MyTask initialises each port with a name.
	This name is used to 'match' ports between connected tasks.
	Orocos will warn at run-time if names or types do not match.
      </para>
      <para>
	Write and read-write Buffers take besides a name, the
	prefered buffer size as a parameter. In the example,
	these are the values 15 and 30. Before the task is
	connected to its peers, you can still change this
	value with the <function>setBufferSize()</function>
	function of the Port.
      </para>
      <note>
	<para>
	  Alternatively, you can connect buffers in your
	  main() program by writing:
	  <programlisting>  #include &lt;execution/ConnectionFactory.hpp&gt;
  // ...
  int buf_size = 100;
  ConnectionFactory&lt;double&gt; cf;
  ConnectionInterface::shared_ptr con =
    cf.createBuffer(a_task->ports()->getPort("SetPoint_X"), 
                            b_task->ports()->getPort("SetPoint_X"), 
                            buf_size);
  if (con)
     con->connect();</programlisting>
	<emphasis>before</emphasis> the tasks are connected. 
	This connection will then take precedence. 
	</para>
      </note>
      </section>
      <section>
	<title>Using the Data Flow Interface in C++</title>
	<para>
	  The Data Flow interface is used by your task from within
	  the program scripts or its <function>update()</function>
	  method. Logically the script or method read the inbound
	  data, calculate something and write the outbound data.
	</para>
	<programlisting>  #include &lt;execution/Ports.hpp&gt;
  using namespace ORO_Execution;

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
     // ...Constructor sets up Ports, see above.

     bool startup() {
       // Check validity of (all) Ports:
       if ( !indatPort.connected() ) {
          // No connection was made !
	  return false;
       }
       if ( !outdatPort.connected() ) {
          // ...
       }
     }

     bool update() {
       // Read and write the Data Flow:
       // Unbuffered:
       double val = indatPort.data()->Get();
       // <emphasis>calculate...</emphasis>
       outdatPort.data()->Set( val );

       // Buffered:
       if ( inbufPort.read()->Pop( val ) ) {
          // <emphasis>calculate...</emphasis>
       } else {
          // buffer empty.
       }

       if ( outbufPort.write()->Push( val ) ) {
          // ok.
       } else {
          // buffer full.
       }
     }
     // ...
  };</programlisting>
	<para>
	  It is wise to check in the <function>startup()</function>
	  function if all necessary ports are <function>connected()</function>.
	  At this point, the task startup can still be aborted by
	  returning false.
	</para>
	<para>
	  The data is read, processed and written in the
	  <function>update()</function> function of the task.  A Data
	  Port's data can be accessed by the
	  <function>data()</function> function, while a Buffer Port's
	  buffer can be accessed by the
	  <function>read()</function>,<function>write()</function> and
	  <function>buffer()</function> functions for read-only,
	  write-only and read-write buffers respectively.  More
	  specifically, <function>data()</function> returns a (const)
	  <classname>ORO_CoreLib::DataObjectInterface</classname>,
	  <function>read</function> returns a
	  <classname>ORO_CoreLib::ReadInterface</classname>,
	  <function>write</function> returns a
	  <classname>ORO_CoreLib::WriteInterface</classname> and
	  <function>buffer</function> returns a
	  <classname>ORO_CoreLib::BufferInterface</classname>.
	</para>
      </section>
      <section>
	<title>Using Data Flow in Scripts</title>
	<para>
	  When a Port is connected, it becomes available to the
	  Orocos scripting system such that (part of) the calculation
	  can happen in a script. Also, the TaskBrowser can then
	  be used to inspect the contents of the DataFlow online.
	</para>
	<para>
	  A small program script could be loaded into MyTask with
	  the following contents:
	  <programlisting>  program MyControlProgram {
    double K    = task.K        // read task property, see later.
    double setp_d

    while ( true ) {
      if ( SetPoint_X.Pop( setp_d ) ) { // read Buffer Port
        double in_d = Data_R.Get()      // read Data Port
        double out_d = (setp_d - in_d) * K  // Calculate
        do Data_W.Set( out_d )          // write Data Port
      }
      do nothing       // this is a 'wait' point.
    }
  } </programlisting>
         The program "MyControlProgram" starts with declaring
	 two variables and reading the task's Property 'K'.
	 Then it goes into an endless loop, trying to Pop
	 a setpoint value from the "SetPoint_X" Buffer Port. If that succeeds (buffer not empty)
	 the  "Data_R" Data Port is read and a simple 
	 calculation is done. The result is written to the
	 "Data_W" Data Port and can now be read by the other
	 end. Alternatively, the result may be directly
	 used by the Task in order to write it to a device
	 or any non-task object. You can use methods (below)
	 to send data from scripts back to the C++ implementation.
	</para>
	<para>
	  Remark that the program is executed within the Execution
	  Engine. In order to avoid the endless loop, a 'wait' point
	  must be present. The "do nothing" command inserts such a
	  wait point and is part of the Scripting syntax.  If you plan
	  to use Scripting state machines, such a
	  <function>while(true)</function> loop and hence wait point
	  is not necessary. See the Scripting Manual for a full
	  overview of the syntax.
	</para>
      </section>
    </section>
    <section>
      <title>The Method Interface</title>
      <note><title>Purpose</title><para>A task's methods are intended
      to be called 'synchronously' by the caller, i.e. are directly
      executed like a function. Use it to 'calculate' a result or
      change a parameter.</para></note>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="MethodInterface" />
	</imageobject>
      </mediaobject>
      <para>
	The easiest way to access a TaskContext's interface
	is through Methods. They resemble very much normal C
	or C++ functions. They take arguments and return a value.
	The return value can in return be used as an argument
	for other Methods or stored in a variable. For
	all details, we refer to the &orocos; Scripting
	Manual.
      </para>
      <para>
	To add a TaskContext's method to the Method Factory, one can use
	the <classname>TemplateMethodFactory</classname>,
	to easily create method factories :</para>
      <para>
	<programlisting>
  #include &lt;execution/TemplateFactories.hpp&gt;
  using namespace ORO_Execution;

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
    public:
    void reset() { ... }
    string getName() const { ... }
    double changeParameter(double f) { ... }
    // ...

    MyTask(std::string name)
      : <classname>ORO_Execution::GenericTaskContext</classname>(name)
    {
       TemplateMethodFactory&lt;MyTask&gt;* mfact =
	   newMethodFactory( <emphasis>this</emphasis> );
       mfact-&gt;add( &quot;reset&quot;,
                     method( &amp;MyTask::reset, &quot;Reset the system.&quot; ) );
       mfact-&gt;add( &quot;name&quot;,
                     method( &amp;MyTask::getName,
                             &quot;Read out the name of the system.&quot; ) );
       mfact-&gt;add( &quot;changeP&quot;,
                     method( &amp;MyTask::changeParameter,
                             &quot;Change a parameter, return the old value.&quot;,
	                     &quot;New Value&quot;, &quot;The new value for the parameter.&quot; ) ); 

       this->methods()->registerObject("this", mfact);

       // more additions to follow, see below
     }
     // ...
  };</programlisting>
      </para>
      <para>
	The first statement 
	<programlisting>
  TemplateMethodFactory&lt;MyTask&gt;* mfact =
    newMethodFactory( this );
	</programlisting>
	constructs a new TemplateMethodFactory, which will create
	methods for the <emphasis>object</emphasis> 'this'. You need
	to supply the C++ type of the object as a template
	parameter, here the class <classname>MyTask</classname>. 
	Each Method object created by this TemplateMethodFactory will be 
	invoked on that object. Any number of methods with
	any kind of arguments can be added.

	After this factory is constructed, we add methods
	to it using the add() function.  The add() function requires a
	name for the added method, and information on the method to be
	associated with that name.  The latter is generated using the
	function method().
      </para>
      <programlisting>
  mfact-&gt;add( &quot;reset&quot;,
             method( &amp;MyTask::reset, &quot;Reset the system.&quot; ) );</programlisting>
      <para>
	The <function>method()</function> function requires a pointer
	to a class function of the earlier provided type
	(<classname>MyTask</classname>), having a number of arguments,
	and returning the appropriate result.  The function's
	signature will automatically define the signature in the
	exported API.  After the class function pointer follows a C
	string containing a description of the function, followed by a
	name and description for each of the arguments.
      </para>
<programlisting>
  this->methods()->registerObject("this", fact);	</programlisting>
      <para>
	Finally, the factory is stored in the Method interface of
	a_task, where it is added to the "this" methods, thus to the
	public interface of the task.  One may also store the methods
	in an object with a different name, which is then intended for
	internal use.
      </para>
      <important>
	<para>The method factory, and all other factories of a TaskContext
	take ownership of the registered or added objects. You are not
	allowed to delete them.</para>
      </important>
      <para>
	Using this mechanism, any method of <emphasis>any</emphasis>
	class can be added to a task's method interface. All methods
	are grouped in an object namespace ( here &quot;this&quot; ),
	which can be served by different classes ( and thus factories
	). For example, you can add methods for an internal object
	using a separate TemplateFactory.
      </para>
    <figure id="fig-task-factories">
      <title>
	  Template Factories and Classes UML Diagram
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="TaskFactories" />
	</imageobject>
	<caption>
	  <para> This diagram demonstrates how TemplateFactories
	  can be applied to your class.
	  </para>
	</caption>
      </mediaobject>
    </figure>
      <section>
	<title>Invoking Methods in C++</title>
	<para>
	  In order to easily invoke a task's methods from a C++ program,
	  the <classname>ORO_Execution::MethodC</classname> class was designed to store
	  and invoke methods and collect the return values. <classname>ORO_Execution::MethodC</classname>
	  objects are created by a task's method factory. For example:
	</para>
	<programlisting>  // create a method:
  MethodC reset_meth = a_task.methods()->create("this", "reset");

  // Call 'reset' of a_task:
  bool valid = reset_meth.execute();  </programlisting>
      <para>
	Methods can also be given arguments and collect return values. Both constant
	arguments and variable arguments are supported. However, the return value
	con only be stored in a variable:
      </para>
      <programlisting>  // used to store the return value:
  string name;
  MethodC name_meth = 
    a_task.methods()->create("this", "name").ret( name );

  // Call 'name' of a_task:
  bool result = name_meth.execute(); 

  cout &lt;&lt; "Name was: " &lt;&lt; name &lt;&lt; endl; 

  // store return value.
  double oldvalue;
  // const argument (note: 'argC'):
  MethodC mychange_1 =
      a_task.methods()->create("this", "changeP").argC(1.0).ret( oldvalue );

  // this example ignores the return value.
  // variable argument (note: 'arg'):
  double d_arg = 1.23;
  MethodC mychange_2 =
      a_task.methods()->create("this", "changeP").arg( d_arg );

  // Call 'changeParameter' of a_task with argument '1.0'
  bool result_1 = mychange_1.execute();
  // oldvalue now contains previous value.

  // Call 'changeParameter' of a_task, reads contents of d_arg.
  bool result_2 = mychange_2.execute();</programlisting>
       <para>
	 Any number of arguments can be given (just add
	 .arg(X).arg(Y).arg(Z) etc ), but an error will be logged when
	 a wrong number or wrong type of argument is given.
       </para>
      </section>
      <section>
	<title>Invoking Methods in Scripts</title>
	<para>
	  To invoke
	methods from a script, one can then write :</para>
	<para>
	<programlisting>
  do ATask.changeP( 0.1 )
  // or :
  set result = ATask.changeP( 0.1 ) // store return value </programlisting></para>
      <para>
	If the method should
	belong to the task's interface, the
	&quot;this&quot; object is assumed.
	If another &quot;objname&quot; is given instead
	of &quot;this&quot;, this would result in :</para>
      <para>
	<programlisting>
  do ATask.objname.changeP( 0.1 )  </programlisting></para>
      <para>
	Any number of methods and objects can be added to a
	TaskContext. Also the methods of the TaskContext
	itself (or its derived classes) may be added. The
	added methods keep their polymorphism, meaning that
	<emphasis>
	  you may add pure virtual methods to the factory.
	</emphasis>
      </para>
      </section>
    </section>
    <section id="method-args-types">
      <title>Method Argument and Return Types</title>
      <para>
	The arguments can be of any type. However, to be compatible with
	the Orocos Program Parser variables, it is best to follow the following 
	guidelines :
	<table id="method-args-table">
	  <title>Method Return &amp; Argument Types</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>C++ Type</entry>
		<entry>In C++ functions passed by</entry>
		<entry>Maps to Parser variable type</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Primitive C types : double, int, bool, char</entry>
		<entry><emphasis>value</emphasis> (no const, no reference )</entry>
		<entry>double, int, bool, char</entry>
	      </row>
	      <row>
		<entry>C++ Container types : std::string, std::vector&lt;double&gt;</entry>
		<entry><emphasis>const &amp;</emphasis></entry>
		<entry>string, array</entry>
	      </row>
	      <row>
		<entry>Orocos Fixed Container types : ORO_CoreLib::Double6D, ORO_Geometry::[Frame | Rotation | Twist | ... ]</entry>
		<entry><emphasis>value</emphasis> (no const, no reference )</entry>
		<entry>double6d, frame, rotation, twist, ...</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	Other types than these listed in <xref
	linkend="method-args-table" /> (such as : unsigned int, float,
	std::map, MyClass*, ... ) are allowed, but will be incompatible with
	parsed programs and state machines, meaning, the result or
	arguments can not be stored in a parser variable, but can be
	passed on from method to method, by using the return value of
	one method as argument of another method. Also, using dynamic allocating
	types, will cause memory allocation allong the path, unless proper
	action is taken since the parser copies all types <emphasis>by value</emphasis>.
      </para>
      <para>
	A method can also take pointers as arguments or return pointers to objects,
	but the parser will (unless properly extended) not be able to store them
	in a parser variable.
      </para>
  </section>
  <section id="task-attr-rep">
    <title>The Attributes and Properties Interface</title>
      <note><title>Purpose</title><para>A task's attributes and
      properties are intended to configure and tune a task with
      certain values. Properties have the advantage of being writable
      to an XML format, hence can store 'persistent' state.  For
      example, a control parameter. Attributes are lightweight values
      which can be read and written during runtime, for example, the
      current measured temperature.  </para></note>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="PropertyInterface" />
	</imageobject>
      </mediaobject>
    <para>
      A TaskContext may have any number of attributes or properties,
      of any type. They can be used by programs in the
      TaskContext to get (and set) configuration data.
      The task allows to store any C++ value type and
      also knows how to handle Property objects. Attributes are plain
      variables, while properties can be written to and updated from an XML file.
    </para>
    <section>
      <title>Adding Task Attributes or Properties</title>
      <para>
	An attribute can be added in the task's
	<classname>ORO_Execution::AttributeRepository</classname> like this :</para>
      <para>
	<programlisting>  #include &lt;corelib/Property.hpp>

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
     <classname>ORO_CoreLib::Property</classname>&lt;std::string&gt; param;
     <classname>ORO_CoreLib::Property</classname>&lt;double&gt; value;
  public:
    // ...
    MyTask(std::string name)
      : <classname>ORO_Execution::GenericTaskContext</classname>(name),
        param("Param","Param Description","The String"),
	value("Value","Value Description", 1.23 )
    {
       // other code here...

       this->attributes()->addAttribute( "aflag", bool(false) );
       this->attributes()->addAttribute( "max",   int(5) );
      
       this->attributes()->addProperty( &amp;param );
       this->attributes()->addProperty( &amp;value );
     }
     // ...
  };
</programlisting></para>
      <para>
	Which inserts an attribute of type bool and int, name 'aflag' and 'max' and initial
	value of false and 5 to the task's repository. Adding a Property
	is also straightforward. The same property is also added in a bag which
	can also be added to the repository.
	The methods return false if an attribute with that name already exists.
      </para>
      <para>
	You can also add constants, which can then no longer be
	changed :</para>
      <para>
	<programlisting>
  this->attributes()->addConstant( "pi", double(3.14) );</programlisting></para>
      <para>
	You should again be careful for duplicate entries.
      </para>
      <important>
	<para>The attribute repository and all other factories of a
	TaskContext take ownership of the registered or added
	objects. You are not allowed to delete them. Properties are an
	exception to this rule, they remain owned by you and you may
	only delete them after a
	<function>removeProperty()</function>.</para>
      </important>
    </section>
    <section>
      <title>Accessing Task Attributes in C++</title>
      <para>
	To get a value from the repository,
      you can use :</para>
      <para>
	<programlisting>
  TaskAttribute&lt;bool&gt;* attrb 
       = a_task.attributes()->getAttribute&lt;bool&gt;( "aflag" );

  bool result = attrb->get();
  assert( result == false );

  TaskAttribute&lt;std::string&gt;* attrs 
       = a_task.attributes()->getAttribute&lt;std::string&gt;( "Param" );

  assert( attrs->get() == "The String" );</programlisting></para>
    </section>
    <section>
      <title>Accessing Task Attributes in Scripts</title>
      <para>
	A program script can access the above attributes as in</para>
      <para>
	<programlisting>  // a program in "ATask" does :
  var double pi2 = task.pi * 2.
  var int    myMax = 3
  set task.max = myMax

  // Both assignments below change the same Property !
  set task.Param = "B Value"
  set task.Collection.Param = "C Value"</programlisting>
	<programlisting>  // an external (peer task) program does :
  var double pi2 = ATask.pi * 2.
  var int    myMax = 3
  set ATask.max = myMax	</programlisting></para>
      <para>
	When trying to assign a value to a constant, the script parser
	will throw an exception, thus before the program is run.
	You must always specify the task's name (or 'task') when accessing a
	task's attribute, this is different from methods and commands,
	which may omit the task's name if the program is running within
	the task.
      </para>
      <important>
	<para>
	  The same restrictions of <xref linkend="method-args-types" /> hold for
	  the attribute types, when you want to access them from program scripts.
	</para>
      </important>
    </section>
    <section>
      <title>Storing and Loading Task Properties</title>
      <para>
	See <xref linkend="task-property-config" /> for storing and loading
	the Properties in a AttributeRepository to and from files, in order
	to save a TaskContext's state.
      </para>
    </section>
  </section>
  <section>
    <title>The Command Interface</title>
      <note><title>Purpose</title><para>A task's commands are intended
      to be called 'asynchronously', thus <emphasis>sent</emphasis> by the caller
      to the receiver. Use it to 'reach a goal' in the receiver, typically
      this takes time to accomplish. Commands are, in contrast with methods,
      executed by the receiver.</para></note>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="CommandInterface" />
	</imageobject>
      </mediaobject>
    <para>
      The next factory we discuss is the Command Factory,
      which produces C++ <classname>ORO_Execution::CommandC</classname>
      objects which encapsulate a command call to a TaskContext's
      interface.
    </para>
    <section>
      <title>Adding Commands to a TaskContext</title>
      <para>
	To add a command to the Command Interface, one can use
	the <classname>TemplateCommandFactory</classname>,
	to easily create command factories :</para>
      <para>
	<programlisting>
  #include &lt;execution/TemplateFactories.hpp&gt;

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
  public:
    /**
     * The first command starts a cycle.
     */
    bool startCycle() { ... }
    bool cycleDone() const { ... }

    /**
     * Another command cleans stuff up.
     */
    bool cleanupMess(double f) { ... }
    bool isMessCleaned() const { ... }

  public:
    MyTask(std::string name)
      : <classname>ORO_Execution::GenericTaskContext</classname>(name)
    {
      // ... other startup code here

      TemplateCommandFactory&lt;MyTask&gt;* cfact =
          newCommandFactory( <emphasis>this</emphasis> );
      cfact-&gt;add( &quot;startCycle&quot;, 
                    command( &amp;MyTask::startCycle,
                             &amp;MyTask::cycleDone,
                             &quot;Start a new cycle.&quot; ) );
      cfact-&gt;add( &quot;cleanup&quot;,
                    command( &amp;MyTask::cleanupMess,
                             &amp;MyTask::isMessCleaned,
                             &quot;Start cleanup operation.&quot;,
	                     &quot;cfactor&quot;, &quot;A cfactor denoting the thoroughness.&quot; ) );

      this->commands()->registerObject("this", cfact);
    }
  };</programlisting></para>
      <para>
	Commands differ from Methods in that they take
	an extra function which is called the Completion
	Condition. It is a function which returns true
	when the command is done. The command itself
	also returns a boolean which indicates if it 
	was accepted or not. Reasons to be rejected
	can be faulty arguments or that the system
	is not ready to accept a new command.
      </para>
      <programlisting>
  cfact-&gt;add( &quot;startCycle&quot;, 
            command( &amp;MyTask::startCycle,
                     &amp;MyTask::cycleDone,
                     &quot;Start a new cycle.&quot; ) );</programlisting>
      <para>
	Thus the <function>command()</function> function
	requires two member pointers instead of
	one.  The first one is a function that does the actual work
	that the command will invoke, and the second is a bool
	<emphasis>const</emphasis> function having :</para>
      <itemizedlist>
	<listitem>
	  <para>the same arguments as the command,</para>
	</listitem>
	<listitem>
	  <para>OR only the first argument of the command,</para>
	</listitem>
	<listitem>
	  <para>OR no arguments at all.</para>
	</listitem>
      </itemizedlist>
      <para>
	The second function (the completion condition)
	will be called to see whether the
	associated command is finished.  The rest of the arguments to
	the command function remain the same.  It also requires a
	constant C string describing the function, and two constant C
	strings giving a description and name for every argument.
      </para>
      <important>
	<para>The command factory, and all other factories of a TaskContext
	take ownership of the registered or added objects. You are not
	allowed to delete them.</para>
      </important>
    </section>
    <section>
      <title>Invoking Commands in C++</title>
      <para>
	Once a command is added to a task's factory, other tasks
	can make use of that command. The <classname>ORO_Execution::CommandC</classname>
	class is especially designed to manage task commands in C++.
	You can ask a task's factory to create such object:
      </para>
      <programlisting>  CommandC mycom = a_task.commands()->create("this", "startCycle");

  // Send 'startCycle' to a_task.
  bool result = mycom.execute();
  // next, check its status:
  bool accepted = mycom.accepted(); // accepted by execution engine?
  bool valid = mycom.valid();       // command was valid (well-formed)?
  bool done = mycom.evaluate();     // command was done?
      </programlisting>
      <para>
	Such commands can also be given arguments. Both constant
	arguments and variable arguments are supported:
      </para>
      <programlisting>  // const argument (note: 'argC'):
  CommandC mycleanup_1 =
      a_task.commands()->create("this", "cleanup").argC(1.0);

  // variable argument (note: 'arg'):
  double d_arg = 1.23;
  CommandC mycleanup_2 =
      a_task.commands()->create("this", "cleanup").arg( d_arg );

  // Send 'cleanup' to a_task with argument '1.0'
  bool result_1 = mycleanup_1.execute();

  // Send 'cleanup' to a_task, reads contents of d_arg.
  bool result_2 = mycleanup_2.execute();</programlisting>
       <para>
	 Any number of arguments can be given, but an error will be
	 logged when a wrong number or wrong type of argument is given.
       </para>
    </section>
    <section>
      <title>Invoking Commands from Scripts</title>
      <para>
	The above lets you write in a program script :</para>
      <para>
	<programlisting>
  do this.startCycle()
  do this.cleanup( 0.1 )	</programlisting></para>
      <para>
	when the program is loaded in a_task.
      </para>
      <para>
	Commands returning false will propagate that error
	to the program or function calling that command, which
	will cause the program to enter an error state, ie
	it stops its execution.
      </para>
      <important>
	<para>
	  The same restrictions of <xref linkend="method-args-types"
	  /> hold for the command and condition types, when you want
	  to access them from program scripts.
	</para>
      </important>
    </section>
  </section>
  <section>
    <title>The Event Interface</title>
      <note><title>Purpose</title><para>A task's events are intended
      to be 'emitted', thus <emphasis>published</emphasis> by the task
      to subscribers. Use it to 'notify' interested parties of a change
      in the system.</para></note>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="EventInterface" />
	</imageobject>
      </mediaobject>
    <para>
      A task may register its events in its interface in order to be
      used by its state machines and other tasks as well.  The events
      used by the task context are defined and explained by the Orocos
      CoreLib. The <classname>ORO_Execution::EventService</classname> is the
      main access point to register and locate a task's events.
    </para>
    <section>
      <title>Adding Events</title>
      <para>
	Events can be easily added to a task's interface,
	much like properties are:
	<programlisting>  #include &lt;corelib/Event.hpp>

  class MyTask
    : public <classname>ORO_Execution::GenericTaskContext</classname>
  {
    // An event with a bool argument:
    <classname>ORO_CoreLib::Event</classname>&lt; void(bool) &gt; turnSwitch;
    // An event with three arguments:
    <classname>ORO_CoreLib::Event</classname>&lt; bool(double, double, double) &gt; moveAxis;
  public:
    MyTask(std::string name)
      : <classname>ORO_Execution::GenericTaskContext</classname>(name)
    {
      // ... other startup code here
  
      // add it to the task's interface:
      this->events()->addEvent( "turnSwitch", &amp;turnSwitch ); 
      this->events()->addEvent( "move", &amp;moveAxis );
    }
  };</programlisting>
	and so on.
      </para>
    </section>
    <section>
      <title>Emitting Events in C++</title>
      <para>
	Once events are added, they can be emitted using the
	<classname>ORO_Execution::EventC</classname> object. Analogous to
	commands and methods, arguments can be provided:
	<programlisting>  <classname>ORO_Execution::EventC</classname> move_event 
    = a_task.events()->setupEmit( "move" ).argC(1.0).argC(2.0).argC(3.0);
  // emit the event 'move' with given args:
  move_event.emit();

  // or with variable arguments:
  double a = 0.3, b = 0.2, c = 0.1;
  move_event = a_task.events()->setupEmit("move").arg(a).arg(b).arg(c);
  // upon emit, read a,b,c:
  move_event.emit(); </programlisting>
      </para>
      <para>Note that the <function>emit()</function> method does not return
      a value.
      </para>
    </section>
    <section>
      <title>Reacting to Events in C++</title>
      <para>
	Analogous to emitting an event, one can also react to
	an event in C++, using the <classname>ORO_Execution::ConnectionC</classname>
	object. However, this object is only of intermediate use
	as event connections can be accessed through the
	<classname>ORO_Execution::Handle</classname> object. The first example
	shows how to setup a synchronous connection to the event
	of the previous examples:
	<programlisting>  #include &lt;boost/bind.hpp>
  /**
   * Example: Connect a class method to an Event.
   */
  class Reactor {
  public:
    void react_callback(double a1, double a2, double a3) {
         // use a1, a2, a3
    }
  };

  /**
   * Example: Connect a 'C' function to an Event.
   */
  void foo_callback( double a1, double a2, double a3 ) {
      // use a1, a2, a3
  }

  // Class callback:
  Reactor r;
  <classname>ORO_Execution::ConnectionC</classname> reaction
    = a_task.events()->setupConnection("move");
  reaction.callback(&amp;r, &amp;Reactor::callback ));
  <classname>ORO_Corelib::Handle</classname> h = reaction.handle();

  // or in short (note: '.handle()' ):
  <classname>ORO_CoreLib::Handle</classname> h2 
    = a_task.events()->setupConnection("move")
                 .callback( &amp;r, &amp;Reactor::react_callback )
                 .handle();
    
  h2.connect(); // connect to event "move"

  move_event.emit(); // see previous example.

  // now Reactor::callback() was called.

  h2.disconnect(); // disconnect again.

  // 'C' Function callback:
  h2 = a_task.events()->setupConnection("move")
                 .callback( &amp;foo_callback )
                 .handle();

  h2.connect();
  move_event.emit()

  // now foo_callback is called with arguments.	</programlisting>
      </para>
      <note>
	<para>
	  Using the <function>boost::bind</function> function is not yet supported
	  in this interface. You must provide the object and function seperately
	  in <function>callback()</function>.
	</para>
      </note>
      <para>
	Analogous to the event example in the CoreLib Manual,
	a class is made to react to the event. A connection
	is setup between the "move" event and the <function>react_callback</function>
	function of "r". The connection can be controlled using
	the handle to connect or disconnect the reaction to events.
	When <function>connect()</function> is called, every
	<function>emit()</function> will call <function>react_callback()</function>
	with the given arguments. Using a 'C' function works analogous as shown
	above.
      </para>
      <para>
	A second example continues, but uses an asynchronous connection.
	First a new task (b_task) is created which will handle the event
	asynchronously. During setup, the <classname>ORO_CoreLib::EventProcessor</classname> of
	b_task's Execution Engine is used to process the event.
	<programlisting>  <classname>ORO_Execution::TaskContext</classname> b_task("BTask");
  <classname>ORO_CoreLib::TaskPreemptible</classname> ptask_b(0.1);
  ptask_b.run( &amp;b_task );
  ptask_b.start();

  <classname>ORO_CoreLib::Handle</classname> h3 
    = a_task.events()->setupConnection("move")
                            .callback(&amp;r, &amp;react_callback,
                                      b_task.engine()->events() ).handle();
    
  h3.connect(); // connect asynchronously to event "move"

  move_event.emit(); // see previous example.

  // wait a bit...

  // now react_callback() was called from within b_task's execution engine.
	</programlisting>
	Note that after passing the object and function, the EventProcessor
	of b_task is added in the <function>callback</function> method, such
	that the callback is executed in b_task's thread.
      </para>
    </section>
    <section>
      <title>Using Events from Scripts</title>
      <para>
	Events are as easy to use as methods (above) from within
	scripts, using the keyword <symbol>emit</symbol>:
	<programlisting>  emit ATask.move( 1.0, 2.0, 3.0 )</programlisting>
      </para>
      <para>
	It is also possible to react to events from within a state
	machine in order to change state. We refer to the Program
	Parser Manual for syntax and examples.
      </para>
    </section>
  </section>
  </section>
  <section id="connect-tasks">
    <title>Task Connections</title>
    <para>
      A Real-Time system contains multiple concurrent
      tasks which must communicate to each other.
      TaskContext objects can be connected to each other
      so that they can communicate Real-Time data or commands.
      We call them &quot;Peers&quot; as there is no fixed
      hierarchy. A connection from one TaskContext to its
      Peer can be uni- or bi-directional. In a uni-directional
      connection, only one peer can send commands or data to the other, while
      in a bi-directional connection, both can send each other
      commands or data. This allows to build strictly hierarchical topological
      networks as well as complete flat or circular networks or any
      kind of mixed network.
    </para>
    <section><title>Connecting Tasks</title>
    <example><title>TaskContext Peer Topology Example</title>
    <para>This diagram shows some possible topologies. Four tasks,
    "A", "B", "C" and "D" have each a port "MyData" and a port "MyData2".
    The example demonstrates that connections are always made from
    writer (sender) to reader (receiver).
    </para>
    <mediaobject>
	<imageobject>
	  <imagedata fileref="DataFlowTopology" />
	</imageobject>
	<caption>
	  <para>
	    Example networks.
	  </para>
	</caption>
    </mediaobject>
    <para>
      The first network has two writers and two readers for "MyData".
      It can be formed starting from "A" and adding "B","C"
      and "D" as peers of "A" respectively. Since the network started from
      "A" all peers share the same connection. The same network could have
      been formed starting from "B". The second diagram connects
      "A" to "C" and then "B" to "D". Two connections are now made and if
      the application tries to connect "B" to "C", this will fail since
      the "MyData" Port of "C" already participates in a connection.
    </para>
    <para>
      The third network has one writer and three readers for "MyData2".
      It can now only be formed starting from "D" and adding "A","B" and "C"
      as peers to "D". Combining both network one and three is possible
      by merely invoking all the 'addPeer' methods in the correct order.
    </para>
    </example>
    <para>
      Peers are connected as such (<methodname>hasPeer</methodname> takes a string 
      argument ):</para>
    <para>
      <programlisting>
  // bi-directional :
  a_task.connectPeers( &amp;b_task );
  assert( a_task.hasPeer( &amp;b_task.getName() ) 
          &amp;&amp; b_task.hasPeer( &amp;a_task.getName() );
  // uni-directional :
  a_task.addPeer( &amp;c_task );
  assert( a_task.hasPeer( &amp;c_task.getName() ) 
          &amp;&amp; ! c_task.hasPeer( &amp;a_task.getName() );</programlisting></para>
    <para>
      Both <function>connectPeers</function> and <function>addPeer</function>
      connect the Data Flow Ports (see above) and allow scripts
      or C++ code to browse the connected Peers. The Data Flow connections
      are <emphasis>created</emphasis> from writer to reader. Thus <function>addPeer</function>
      connects the write Data and Buffer Ports of "a_task" to the
      read Ports of "c_task". <function>connectPeers</function>
      does this connection <emphasis>creation</emphasis> in both directions. If a task's
      Port already has a connection, any peer task
      with compatible ports will automatically participate in
      that connection by using either function call.
      For example, if "a_task" and "b_task" exchange a
      Data type "Data_X", and "c_task" reads "Data_X", the 
      <function>addPeer</function> will forward "Data_X" to
      "c_task" as well.
    </para>
    <para>
      From within a program script, peers can be accessed by
      merely prefixing their name to the member you want to
      access. A program <emphasis>within</emphasis> &quot;ATask&quot; could
      access its peers as such :</para>
    <para>
      <programlisting>
  do BTask.object.command()
  var int result = CTask.method() </programlisting></para>
    <para>
      The peer connection graph can be traversed at arbitrary
      depth. Thus you can access your peer's peers.
    </para></section>
    <section><title>Disconnecting Tasks</title>
    <para>
      Tasks can be disconnected from a network by invoking
      <function>disconnect()</function> on that task. It will
      inform all its peers that it has left the network and
      disconnect all its ports. This does not mean that
      all data flow connections are deleted. As long as one task's
      port still participates in a connection, the connections
      exist. When the last port disconnects, the data flow connection
      is cleaned up as well.
    </para>
    <example><title>TaskContext Peer Disconnection Example</title>
    <para>(1) shows what would happen if tasks "A" and "B"
    are disconnected from the network. (2) shows what would happen if
    the connection itself is disconnected.
    </para>
    <mediaobject>
	<imageobject>
	  <imagedata fileref="DataFlowDisconnect" />
	</imageobject>
	<caption>
	  <para>
	    Disconnecting tasks.
	  </para>
	</caption>
    </mediaobject>
    <para> When <function>A.disconnect()</function> is called (1),
    it removes its participation from the "MyData" connection.
    The same happens for <function>B.disconnect()</function>.
    "C" and "D" read then from a connection which has no more
    writers. Adding "A" again to the network would make "A"
    again a writer of "MyData". If both "C" and "D" call disconnect
    as well, the "MyData" connection is cleaned up.
      <programlisting>  a_task.disconnect();
  assert( !a_task.hasPeer( &amp;b_task.getName() ) 
          &amp;&amp; !b_task.hasPeer( &amp;a_task.getName() );

  b_task.disconnect();
  assert( !c_task.hasPeer( &amp;b_task.getName() ) 
          &amp;&amp; ! d_task.hasPeer( &amp;b_task.getName() );</programlisting>
    </para>
    <para>
      Data Flow connections can be disconnected (2) as
      well, in which case all ports are disconnected.
      <programlisting>  ConnectionInterface::shared_ptr con = a_task.ports()->getPort("MyData")->connection();
  if (con)
    con->disconnect();

  assert( !a_task.ports()->getPort("MyData").connected() );
  assert( !b_task.ports()->getPort("MyData").connected() );
  assert( !c_task.ports()->getPort("MyData").connected() );
  assert( !d_task.ports()->getPort("MyData").connected() ); </programlisting>
    </para>
    </example>
    </section>
  </section>
  <section id="run-tasks">
    <title>Using Tasks</title>
    <para>
      This section elaborates on the interface all Task Contexts have
      from a 'Task user' perspective.
    </para>
    <section id="task-property-config">
      <title>Task Property Configuration</title>
      <para>
	As was seen in <xref linkend="task-attr-rep" />,
	<classname>ORO_CoreLib::Property</classname> objects can be
	added to a task's interface. To read and write properties from
	or to files, you can use the
	<classname>ORO_Execution::GenericTaskContext</classname>
	class' methods. It creates or reads files in the XML Component
	Property Format such that it is human readable and modifiable.
      </para>
      <programlisting>  // ...
  <classname>ORO_Execution::GenericTaskContext</classname>* a_task = ...
  a_task->readProperties( "PropertyFile.cpf" );
  // ...
  a_task->writeProperties( "PropertyFile.cpf" ); </programlisting>
       <para>
	 Where <function>readProperties()</function> reads the file and updates the
	 task's properties and <function>writeProperties()</function> <emphasis>updates</emphasis> the
	 given file with the properties of the task. It is allowed to
	 share a single file with multiple tasks or update the task's
	 properties from multiple files.
       </para>
    </section>
    <section>
      <title>Task Scripts</title>
      <para>
	Orocos supports two types of scripts:
	<itemizedlist>
	  <listitem><para>An Orocos Program Script (ops) contains a <emphasis>Real-Time</emphasis>
	  functional program which calls methods and sends commands to
	  tasks, depending on classical functional logic.</para></listitem>
	  <listitem><para> An Orocos State machine Description (osd)
	  script contains a <emphasis>Real-Time</emphasis> (hierarchical)
	  state machine which dictates which program script snippets
	  are executed upon which event.  </para>	</listitem>
	</itemizedlist>
	Both are loaded at runtime into a task. The scripts are parsed
	to an object tree, which can then be executed by the
	<classname>ORO_Execution::ExecutionEngine</classname> of a
	task.
      </para>
      <section id="task-context-programs">
	<title>Program Scripts</title>
	<para>
	  Program can be finely controlled once loaded in
	  the <classname>ORO_Execution::ProgramProcessor</classname>,
	  which is part of the Execution Engine.
	  A program can be paused, it's variables inspected
	  and reset while it is loaded in the Processor.
	  A simple program script can look like :</para>
	<para>
	  <programlisting>  program foo
  {
    var int i = 1
    var double j = 2.0
    do changeParameter(i,j)
  }</programlisting>
	  Any number of programs may be listed in a file.
	</para>
	<para>
	  Orocos Programs are loaded as such into a GenericTaskContext
	  :</para>
	<para>
	  <programlisting>  <classname>ORO_Execution::GenericTaskContext</classname>* a_task = ...

  a_task->loadProgram( "ProgramBar.ops" ); </programlisting></para>
	<para>
	  When the Program is loaded in the Task Context, it can
	  also be controlled from other scripts or a TaskBrowser. Assuming
	  you have loaded a Program with the name 'foo', the
	  following commands are available :
	</para>
	<screen>
  do programs.foo.start()
  do programs.foo.pause()
  do programs.foo.step()
  do programs.foo.stop()
	</screen>
	<para>While you also can inspect its status :</para>
	<screen>
  programs.foo.isRunning()
  programs.foo.inError()
  programs.foo.isPaused()
	</screen>
	<para>You can also inspect and change the variables of a loaded program,
	but as in any application, this should only be done
	for debugging purposes.</para>
	<screen>
  set programs.foo.i = 3
  var double oldj = programs.foo.j
	</screen>
	<para>
	  Program scripts can also be controlled in C++.
	  Take a look at the
	  <classname>ORO_Execution::ProgramInterface</classname> class
	  reference for more program related functions. One can
	  get a pointer to a program by calling:
	</para>
	<programlisting>  ProgramInterface* foo = this->engine()->getProgram("foo");
  if (foo != 0) {
    bool result = foo->start(); // try to start the program !
    if (result == false) {
       // Program could not be started.
       // Execution Engine not running ?
    }
  }</programlisting>
      </section>
      <section>
	<title>State Machines</title>
	<para>
	  Hierarchical state machines are modelled in Orocos
	  with the <classname>ORO_Execution::StateMachine</classname> class.
	  They are like programs in that they can call a
	  peer task's members, but the calls are grouped
	  in a state and only executed when the state machine
	  is in that state. A detailed introduction can be found
	  in the &parseman;. This section limits to showing
	  how an Orocos State Description (osd) script can be loaded in a 
	  Generic Task Context.
	</para>
	<para>
	  <programlisting>  <classname>ORO_Execution::GenericTaskContext</classname>* a_task = ...

  a_task->loadStateMachine( "StateMachineBar.osd" ); </programlisting></para>
	<para>
	  When the State Machine is loaded in the Task Context, it can
	  also be controlled from your scripts or TaskBrowser. Assuming
	  you have instantiated a State Machine with the name 'machine', the
	  following commands are available :
	</para>
	<screen>
  do states.machine.activate()
  do states.machine.start()
  do states.machine.pause()
  do states.machine.step()
  do states.machine.stop()
  do states.machine.deactivate()
  do states.machine.reset()
  do states.machine.reactive()
  do states.machine.automatic() // identical to start()
  do states.machine.requestState("StateName")
	</screen>
	<para>As with programs, you can inspect and change the
	variables of a loaded StateMachine.</para>
	<screen>
  set programs.machine.myParam = ...
	</screen>
	<para>
	  The Scripting Manual goes in great detail on how to 
	  construct and control State Machines.
	</para>
      </section>
      <section>
	<title>Further Reading</title>
	<para>
	  In addition to this text, be sure to read the &parseman;
	  such that you get a grip of the full power of Real-Time
	  Orocos scripts.
	</para>
      </section>
    </section>
  </section>
  <section>
    <title>Advanced Techniques</title>
    <para>
      If you master the above methods of setting up tasks, this section
      gives some advanced uses for integrating your existing application
      framework in Orocos Tasks.
    </para>
    <section>
      <title>Using the <classname>ORO_Execution::GenericTaskContext</classname></title>
      <para>
	To help users in setting up quickly a TaskContext, the GenericTaskContext
	class has been made available which adds some standard methods and
	commands to its interface which are common to many tasks. It supports
	loading Programs and StateMachines, saving Properties to disk and reading
	them back in and stopping and starting the Task.
	You can download an introduction to setting up TaskContexts which
	uses this class from the Orocos.org download page.
      </para>
    </section>
    <section>
      <title>Wrapping Methods in Functions</title>
      <para>
	Methods are always executed in the thread of the caller. If a 
	method does non-realtime operations, like writing data to disk, 
	it should not be called by a realtime thread. However, if the
	thread which owns the method is itself not realtime, it can execute
	the method as a command in its own thread. This can easily be
	accomplished by writing a wrapper function ( or alternatively, 
	register the method as a command too ).
      </para>
      <programlisting>  export function domethod( int arg ) {
     do mymethod( arg )
  } </programlisting>
      <para>
	Load this function with the <classname>ORO_Execution::ProgramLoader</classname>
	in the TaskContext having 'mymethod', and hard realtime tasks
	can instruct it to execute that method, without jeopardizing 
	their own realtime behaviour.
      </para>
    </section>
    <section>
      <title>Waiting for Something : Synchronisation</title>
      <para>
	When tasks need to synchronise, you have a wide range of
	options to use. 
      </para>
      <section>
	<title>Waiting in States</title>
	<para>
	  A (sub-)State Machine can pause itself and an extra function
	  in the task's interface can provide the key to progress to
	  another state. First the StateMachine is loaded in an .osd file  :
	</para>
	<programlisting>
  StateMachine X {
     // ...
     state y {
        entry {
           // pause myself, no transitions are checked.
           do this.pause()
        }
        transitions {
	   // guard this transition.
           if task.checkSomeCondition() then
              select z
        }
     }
     state z {
       // ...
     }
  }

  RootMachine X x</programlisting>
	<para>Then, load an ops file which contains :</para>
	<programlisting>
  export function progress() {
    // Check if we may progress :
    if this.states.x.inState("y") then {
        // continue :
        do this.states.x.start()
        // OR try single transition :
        do this.states.x.step()
    }
  }</programlisting>
	<para>
	  A peer task then calls <function>progress()</function>
	  which in turn checks if the function is applicable.
	  But even then, the responsibility of the transition
	  lies within the State Machine.
	</para>
	<para>
	  Off course, the example can be simplified by setting/
	  resetting a boolean flag between function and
	  State Machine.
	</para>
	<programlisting>
  StateMachine X {
     // ...
     state y {
        transitions {
           if task.progressflag == true then
                select z
        }
     }
     state z {
       // ...
     }
  }

  RootMachine X x</programlisting>
	<para>Then, load an ops file which contains :</para>
	<programlisting>
  export function progress() {
    // Check if we may progress :
    if this.states.x.inState("y") then {
          set task.progressflag = true
    }
  }</programlisting>
	<para>
	  When the user or another program calls the progress() command,
	  the flag will be set.
	</para>
      </section>
      <section>
	<title>Requesting States</title>
	<para>
	  A State Machine can be used such that it waits for state
	  change requests instead of discovering itself to which 
	  state it makes a transition. This requires the State Machine to run in
	  another mode, the requestState mode ( as opposed to the automatic mode,
	  which is entered by start() ). 
	</para>
	<programlisting>
  StateMachine X {
     // ...
     state y {
        entry {
	   // ...
        }
        transitions {
	   // guard this transition.
           if task.checkSomeCondition() then
              select z
	   // always good to go to states :
	   select ok_1
           select ok_2
        }
     }
     state z {
       // ...
     }
     state ok_1 {
       // ...
     }
     state ok_2 {
       // ...
     }
  }

  RootMachine X x</programlisting>
	<para>Then, load an ops file which contains :</para>
	<programlisting>
  export function progress() {
       // request to enter anther state :
       do this.states.x.requestState("z")
    }
  export function progress_Ok() {
       // this will succeed always from state 'x' :
       do this.states.x.requestState("ok1")
    } </programlisting>
         <para>
	   This command will fail if the transition is not 
	   possible ( for example, the state machine is not in
	   state y, or task.checkSomeCondition() was not true ),
	   otherwise, the state machine will make the transition
	   and the command succeeds and completes when the z state
	   is fully entered (it's init program completed).
	 </para>
	 <para>
	   To merely request that a state is handled, one can
	   call requestState on the current state :
	 </para>
	<programlisting>
  export function handleState() {
       // request to handle current state :
       do this.states.x.requestState( this.states.x.getState() )
    }  </programlisting>
	 <para>
	   To request to go to the next possible state (or call handle if
	   none) and then wait again for requests, use 'step()' :
	 </para>
	<programlisting>
  export function evaluate() {
       // request go to the next state and wait :
       do this.states.x.step()
    }  </programlisting>
         <para>
	   Note that if the StateMachine happened to be paused, step() would
	   only progress one single statement. To check if the StateMachine
	   is waiting for requests, use the 'inRequest()' method :
	 </para>
	<programlisting>
  export function progress() {
       if ( this.states.x.inRequest() ) {
           // ... it's waiting
       } else {
          // was not waiting, possibly running, paused or non active
       }
    }  </programlisting>
        <para>
	  All these methods can of course also be called from parent
	  to child State Machine, or across tasks.
	</para>
      </section>
    </section>
    <section>
      <title>Polymorphism : Task Interfaces</title>
      <para>
	Most projects have define their own task interfaces in C++.
	Assume you have a class with the following interface :
      </para>
      <programlisting>
  class DeviceInterface
  {
  public:
    /**
     * Set/Get a parameter. Returns false if parameter is read-only.
     */
    virtual bool setParameter(int parnr, double value) = 0;
    virtual double getParameter(int parnr) const = 0;

    /**
     * Get the newest data.
     * Return false on error.
     */
    virtual bool updateData() = 0;
    virtual bool updated() const = 0;

    /**
     * Get Errors if any.
     */
    virtual int getError() const = 0;
  };</programlisting>
      <para>
	Now suppose you want to do make this interface available,
	such that program scripts of other tasks can access this 
	interface. Because you have many devices, you surely want
	all of them to be accessed transparantly from a supervising
	task. Luckily for you, C++ polymorphism can be transparantly
	adopted in Orocos TaskContexts. This is how it goes.
      </para>
      <section>
	<title>Step 1 : Export the interface</title>
	<para>We construct a TaskContext, which exports your
	C++ interface to a task's interface.
	</para>
	<programlisting>
  #include &lt;execution/GenericTaskContext.hpp&gt;
  #include &lt;execution/TemplateFactories.hpp&gt;
  #include "DeviceInterface.hpp"

  class TaskDeviceInterface
    : public DeviceInterface,
      public <classname>ORO_Execution::GenericTaskContext</classname>
  {
  public:
      TaskDeviceInterface()
        : <classname>ORO_Execution::GenericTaskContext</classname>( "DeviceInterface" )
      {
         this->setup();
      }

      void setup() 
      {
         // Add Methods :
         TemplateMethodFactory&lt;DeviceInterface&gt;* mfact =
            newMethodFactory( this );
         mfact-&gt;add(&quot;setParameter&quot;,
                    method(&amp;DeviceInterface::setParameter,
	                   &quot;Set a device parameter.&quot;,
	                   &quot;Parameter&quot;, &quot;The number of the parameter.&quot;,
	                   &quot;New Value&quot;, &quot;The new value for the parameter.&quot;)); 
         this->methods()->registerObject("this", mfact);

         // Add Data Sources :
         TemplateDataSourceFactory&lt;DeviceInterface&gt;* dfact =
            newDataSourceFactory( this );
         dfact-&gt;add( &quot;getParameter&quot;,
                     data(&amp;DeviceInterface::getParameter,
	                  &quot;Get a device parameter.&quot;,
                          &quot;Parameter&quot;, &quot;The number of the parameter.&quot;));
         dfact-&gt;add(&quot;getError&quot;,
                    data(&amp;DeviceInterface::getError,
	                 &quot;Get device error status.&quot;));
         this->datasources()->registerObject("this", dfact);

         // Add Commands :
         TemplateCommandFactory&lt;DeviceInterface&gt;* cfact =
            newCommandFactory( this );
         cfact-&gt;add( &quot;updateData&quot;,
                        command( &amp;DeviceInterface::updateData,
                                 &amp;DeviceInterface::updated,
                                 &quot;Command data acquisition.&quot; ) );
         this->commands()->registerObject("this", cfact);
      }
  };</programlisting>
	<para>
	  The above listing just combines all factories which were introduced
	  in the previous sections. Also note that the TaskContext's name
	  is fixed to "DeviceInterface". This is not obligatory though.
	</para>
      </section>
      <section>
	<title>Step 2 : Inherit from the new interface</title>
	<para>Your DeviceInterface implementations now
	  only need to inherit from <classname>TaskDeviceInterface</classname>
	  to instantiate a Device TaskContext :
	</para>
	<programlisting>
  #include "TaskDeviceInterface.hpp"

  class MyDevice_1 
    : public TaskDeviceInterface
  {
  public:

    bool setParameter(int parnr, double value) {
      // ...
    }
    double getParameter(int parnr) const {      // ...
    }
    // etc.
  };
	</programlisting>
      </section>
      <section>
	<title>Step 3 : Add the task to other tasks</title>
	<para>
	  The new TaskContext can now be added to other tasks.
	  If needed, an alias can be given such that the
	  peer task knows this task under another name.
	  This allows the user to access different incarnations
	  of the same interface from a task.
	</para>
	<programlisting>
	  // now add it to the supervising task :
  MyDevice_1 mydev;
  supervisor.addPeer( &amp;mydev, "device" );
	</programlisting>
	<para>
	  From now on, the "supervisor" task will be able to access
	  "device". If the implementation changes, the same interface
	  can be reused whithout changing the programs in the supervisor.
	</para>
	<para>
	  A big warning needs to be issued though : if you change a
	  peer at runtime (after parsing programs),
	  you need to reload all the programs, functions,
	  state contexts which use that peer so that they reference
	  the new peer and its C++ implementation.
	</para>
      </section>
      <section>
	<title>Step 4 : Use the task's interface</title>
	<para>To make the example complete, here is an example
	script which could run in the supervisor task :
	</para>
	<programlisting>
  program ControlDevice
  {
     const int par1 = 0
     const int par2 = 1
     do device.setParameter(par1, supervisor.par1 )
     do device.setParameter(par2, supervisor.par2 )

     while ( device.getError() == 0 ) 
     {
	if ( this.updateDevice("device") == true )
           do device.updateData() until {
	        if done || ( device.getError() != 0 ) then
	           continue
	   }
     }
     do this.handleError("device", device.getError() )
  }</programlisting>
	<para>To start this program from the TaskBrowser, browse to supervisor
	  and type the command :</para>
	<screen>
  device.programs.ControlDevice.start()
	</screen>
	<para>
	  When  the program "ControlDevice" is started,
	  it initialises some parameters from its own attributes.
	  Next, the program goes into a loop and sends updateData commands
	  to the device as long as underlying supervisor (ie "this") logic requests
	  an update and no error is reported. This code guarantees that
	  no two updateData commands will intervene each other since the
	  program waits for the commands completion or error.
	  When the device returns
	  an error, the supervisor can then handle the error of the
	  device and restart the program if needed.
	</para>
	<para>
	  The advantages of this program over classical C/C++ functions are :
	</para>
	<itemizedlist>
	  <listitem>
	    <para>If any error occurs (ie a command or method returns false),
	    the program stops and other programs or state contexts can
	    detect this and take apropriate action.</para>
	  </listitem>
	  <listitem>
	    <para>The  "<function>device.updateData()</function>" call waits
	    for completion of the remote command, but can be given other
	    completion or error conditions to watch for.</para>
	  </listitem>
	  <listitem>
	    <para>While the program waits for <function>updateData()</function>
	      to complete, it does not block other programs, etc within
	      the same TaskContext and thread.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      There is no need for additional synchronisation primitives
	      between the supervisor and the device since the commands
	      are queued and executed in the thread of the device, which
	      leads to :
	    </para>
	    <itemizedlist>
	      <listitem>
		<para>The command is executed at the priority of the device's
		  thread, and not the supervisor's priority.</para>
	      </listitem>
	      <listitem>
		<para>The command can never corrupt data of the device's thread,
		  since it is <emphasis>serialised</emphasis>(executed after)
		  with the programs running in that thread.
		</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</itemizedlist>
      </section>
    </section>
  </section>
</article>
