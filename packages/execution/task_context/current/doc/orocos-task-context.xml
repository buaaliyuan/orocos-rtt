<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.ac.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>
      The Orocos Task Infrastructure Manual
    </title>
    <subtitle>Designing Real-Time Orocos Applications</subtitle>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>2004,2005</year>
      <holder>Peter Soetens</holder>
    </copyright>
    
    <abstract>
      <para>
	This document describes the &orocos; Task Infrastructure, which
	allows to design Real-Time tasks which transparantly communicate
	with each other.
      </para>
    </abstract>
    
    <revhistory>
      <revision>
	<revnumber>0.18.0</revnumber>
	<date>19 Nov 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.20.0</revnumber>
	<date>1 May 2005</date>
	<authorinitials>PS</authorinitials>
	<revremark>Moved TaskBrowser to front and updated to ProgramLoader</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <sect1 id="task-context-intro">
    <title>Introduction</title>
    <para>
      This manual documents how multi-threaded tasks can be defined in &orocos;
      such that they form a thread-safe robotics/machine control application.
      The overall idea of the &taskpkg; and the mechanisms behind it are published in a 
      <ulink url="http://www.orocos.org/pub/task-infrastructure04.pdf">6 page technical report</ulink>
      which can be found on the Orocos website.  
    </para>
    <figure id="fig-task-peers">
      <title>
	Tasks Run in Threads
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="TaskPeers" />
	</imageobject>
	<caption>
	  <para>
	    Tasks may run in the same (periodic) thread, in which
	    case they may also share the same Processor.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      A task is a basic unit of functionality which executes one or more (realtime)
      programs in a single thread. 
      The program can vary from a mere C function over a realtime program script
      to a realtime hierarchical state machine. The focus is completely on 
      thread-safe time determinism. Meaning, that the system is free of priority-inversions,
      and all operations are lock-free (also data sharing and other forms of communication
      such as events and commands). This is done using the mechanisms of the &orocos;
      Real-Time CoreLib which allows each task to run in its own thread or share
      threads. Real-Time tasks can communicate with non Real-Time tasks (and vice versa)
      transparantly. 
    </para>
    <para>
      The Orocos Task Infrastructure enables :
      <itemizedlist>
	<listitem>
	  <para>Lock free, thread-safe, inter-thread function calls.</para>
	</listitem>
	<listitem>
	  <para>Communication between hard Real-Time and non Real-Time threads.</para>
	</listitem>
	<listitem>
	  <para>	  Deterministic execution time during communication
	  for the higher priority thread.</para>
	</listitem>
	<listitem>
	  <para>	  Synchronous and asynchronous communication between threads.</para>
	</listitem>
	<listitem>
	  <para>	  C++ class implementations for all the above.</para>
	</listitem>
      </itemizedlist>
    </para>
    <para>
      This document relates to other manuals as such :
      <glosslist>
	<glossentry>
	  <glossterm>CoreLib</glossterm>
	  <glossdef>
	    <para> provides the Event infrastructure,
	      Task-thread mapping, CommandInterface and lock-free queueing
	      implementations.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Program Processor</glossterm>
	  <glossdef>
	    <para> provides a binary program-tree, state machines and command
	      execution framework. In short, it can execute realtime programs
	      which are composed of command objects.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Program Parser</glossterm>
	  <glossdef>
	    <para> provides a scripting language which is convertible to
	    a binary form which can be accepted by the Program Processor.
	      Also provides usefull templates to create realtime command objects
	      with truely minimal effort.
	    </para>
	  </glossdef>
	</glossentry>
	<glossentry>
	  <glossterm>Control Kernel</glossterm>
	  <glossdef>
	    <para> is an application which uses all of the above
	      and provides an (although complex) example of how
	      the &taskpkg; can be used in practice.
	    </para>
	  </glossdef>
	</glossentry>
      </glosslist>
    </para>
    <para>
      You should read the Processor and Program Parser manuals
      for more technical (C++) details.
    </para>
  </sect1>
  <sect1>
    <title>An Introductory Example to TaskContexts</title>
    <para>
      This section introduces tasks through the "taskintro"
      application, which can be downloaded from Orocos.org.  It
      contains 3 TaskContexts, each showing some features and
      possibilities. The 'FactoringTask' waits for a command to factor
      a number in its primes. When done, it fires an event with the
      result.  The 'ReactiveTask' is a periodic task which waits for
      the events to happen when it is running. The 'PeriodicTask' can
      count to a certain number in each periodic step, when given the
      command to do so. We show some example commands, but the
      application has more methods and commands than presented here.
    </para>
    <para>
      The way we interact with TaskContexts during development of an
      Orocos application is through the TaskBrowser.  The
      <classname>TaskBrowser</classname> is a powerful console tool
      which helps you to explore, execute and debug
      <classname>TaskContext</classname>s in running programs. All you
      have to do is to instantiate a TaskBrowser and enter its loop()
      method. When the program is started from a console, the
      TaskBrowser takes over user input and output.
    </para>
    <note>
      <para>
	The <classname>TaskBrowser</classname> is located in the
	Orocos Program Parser package and not in the Task Context package.
      </para>
    </note>
    <programlisting>
  #include &lt;execution/TaskBrowser.hpp&gt;
  // ...

  int ORO_main( int, char** )
  {
      // Create your tasks
      TaskContext* task = ...

      // when all is setup :
      TaskBrowser tbrowser( task );

      tbrowser.loop();
      return 0;
  }
    </programlisting>
    <para>
      The TaskBrowser uses the GNU readline library to easily
      enter commands to the tasks in your system. This means you
      can press TAB to complete your commands and the up arrow
      to scroll through previous commands.
    </para>
    <screen>
$ ./taskintro
0.003 [Info] Parsing file CountingSM.osd
0.069 [Info] Loading StateMachine counterMachine
0.074 [Info] ReactiveTaskContext reacting to PrimeEvent !

  This console reader allows you to browse and manipulate TaskContexts.
  You can type in a command, datasource, method, expression or change variables.
  (type 'help' for instructions)
    TAB completion and HISTORY is available ('bash' like)

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :
    </screen>
    <para>
      The first lines are printed by the Orocos ORO_CoreLib::Logger, which has been
      configured to display informative messages to console. You can always
      watch the log file 'orocos.log' in the same directory to see all messages.
    </para>
    <para>
      Depending on what you type, the TaskBrowser will act differently.
      The builtin commands <command>cd</command>, <command>help</command>,
      <command>quit</command> and <command>ls</command> are seen as commands
      to the TaskBrowser itself, if you typed something else,
      it tries to evaluate your command to an expression and will
      print the result to the console. If you did not type an expression,
      it tries to parse it as a command to a (peer) task. If that also
      fails, it means you made a typo and it prints the syntax error
      to console.
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>1+1</command>
      Got :1+1
   = 2
    </screen>
    <para>To display the contents of the current task, type <command>ls</command>,
      and switch to one of the listed peers with <command>cd</command>, while
      <command>cd ..</command> takes you one peer back in history :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls</command>

PeriodicTask Attributes :
    (Attribute  ) int Counter
    (Property   ) PropertyBag ItemCollection
    (Property   ) std::string Parameter
    (Attribute  ) double SpeedOfLight
    (Attribute  ) int Target

PeriodicTask Objects    :  this
PeriodicTask Peers      :  FactoringTask ReactiveTask states

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>cd FactoringTask</command>
   Switched to : FactoringTask

 In Task FactoringTask. (Status of last Command : none )
 (type 'ls' for context info) :ls

FactoringTask Attributes :
    (Attribute  ) int Priority

FactoringTask Objects    :  this
FactoringTask Peers      :  PeriodicTask ReactiveTask

 In Task FactoringTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>cd ..</command>

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :
    </screen>
    <note>
    <para>To get a quick overview of the commands, type
      <command>help</command>.
    </para>
    </note>
    <para>
      Let's revisit the output of <command>ls</command> :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls</command>

PeriodicTask Attributes :
    (Attribute  ) int Counter
    (Property   ) PropertyBag ItemCollection
    (Property   ) std::string Parameter
    (Attribute  ) double SpeedOfLight
    (Attribute  ) int Target

PeriodicTask Objects    :  this
PeriodicTask Peers      :  FactoringTask ReactiveTask states
    </screen>
    <para>
      First you get a list of the Properties and Attributes (alphabetical) of
      the current TaskContext. Propeties can be written to disk, attributes
      are solely for script interaction. Each of them can be changed, except
      task constants. The current task has only one object: 'this'. The 'this'
      object serves like a public interface of the TaskContext. Objects can only contain
      methods, commands or datasources. Last, the peers are shown, two other tasks
      and 'states', which denotes that this TaskContext has a StateMachine. Likewise,
      a peer task 'programs' contains all loaded programs.
      To get a list of the Task's interface, you can always type an object name,
      for example 'this' :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) : <command>this</command>
      Got :this
  Command    : bool countTo( int Target )
   Count to a given number using a StateMachine program.
   Target : Number to count to.
  DataSource : bool isRunning( )
   Is this GenericTaskContext started ?
  Method     : bool assert( bool MustBeTrue )
   Assert will get your program in the error state if the argument is false.
   MustBeTrue : The result of a boolean expression which must be true.
  Method     : bool loadProgram( const&amp; std::string Filename )
   Load an Orocos Program Script from a file.
   Filename : An ops file.
  Method     : bool loadStateMachine( const&amp; std::string Filename )
   Load an Orocos State Description from a file.
   Filename : An osd file.
  Method     : bool readProperties( const&amp; std::string Filename )
   Read Properties from a file.
   Filename : A CPF formatted XML file.
  Method     : bool start( )
   Start this GenericTaskContext.
  Method     : bool stop( )
   Stop this GenericTaskContext.
  Method     : bool unloadProgram( const&amp; std::string ProgramName )
   Unload an Orocos Program Script from a file.
   ProgramName : The Program's name.
  Method     : bool unloadStateMachine( const&amp; std::string StateMachineName )
   Unload an Orocos State Description from a file.
   StateMachineName : A name of a Root StateMachine instantiation.
  Method     : bool writeProperties( const&amp; std::string Filename )
   Write or update Properties to a file.
   Filename : A CPF formatted XML file.
    </screen>
    <para>
      The 'this' object is special in that the command or method must
      not be prefixed by an object name and that it apears as if the
      method is called directly on the task :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :ReactiveTask.stop()
      Got :ReactiveTask.stop()
   = true
    </screen>
    <para>
      'Methods' and 'DataSources' are executed directly by the TaskBrowser itself,
      and then it prints the result. The return value of stop() was a boolean,
      which is 'true'.
    </para>
    <para>
      When a 'Command' is entered, it is sent to the TaskContext itself, which 
      will execute it in its own thread. The different stages of its lifetime are
      displayed by the prompt. Hitting enter will refresh the status line.
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : <emphasis>none</emphasis> )
 (type 'ls' for context info) :<command>countTo(1000)</command>
      Got :countTo(1000)

 In Task PeriodicTask. (Status of last Command : <emphasis>queued</emphasis>)
 (type 'ls' for context info) :2589.528 [Info] PeriodicTaskContext counts to 1000.


 In Task PeriodicTask. (Status of last Command : <emphasis>busy</emphasis> )
 (type 'ls' for context info) :

 In Task PeriodicTask. (Status of last Command : <emphasis>done</emphasis> )
 (type 'ls' for context info) :
    </screen>
    <para>
      A Command might be rejected (return false) by the receiving TaskContext :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : <emphasis>done</emphasis> )
 (type 'ls' for context info) :<command>countTo(-20)</command>
      Got :countTo(-20)

 In Task PeriodicTask. (Status of last Command : <emphasis>queued</emphasis> )
 (type 'ls' for context info) :

 In Task PeriodicTask. (Status of last Command : <emphasis>fail</emphasis> )
 (type 'ls' for context info) :         
    </screen>
    <para>
      Besides giving commands to tasks, you can alter the attributes of 
      any task, program or state machine. The TaskBrowser will confirm
      validity of the assignment with 'true' or 'false' :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>ls states.counterMachine</command>

counterMachine Attributes :
   int multiplier

counterMachine Objects    :  this
counterMachine Peers      :  states

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>states.counterMachine.multiplier = 20</command>
      Got :states.counterMachine.multiplier = 20
   = true

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>states.counterMachine.multiplier</command>
      Got :states.counterMachine.multiplier
   = 20

 In Task PeriodicTask. (Status of last Command : none )
 (type 'ls' for context info) :<command>countTo(200)</command>
      Got :countTo(200)

 In Task PeriodicTask. (Status of last Command : queued )
 (type 'ls' for context info) :60.272 [Info] PeriodicTaskContext counts to 200.


 In Task PeriodicTask. (Status of last Command : done )
 (type 'ls' for context info) :      
    </screen>
    <para>
      Last but not least, hitting TAB twice, will show you a list of
      possible completions, such as peers or commands :
    </para>
    <screen>
 In Task PeriodicTask. (Status of last Command : fail )
 (type 'ls' for context info) :
Counter             cd ..               readProperties
FactoringTask.      countTo             start
ItemCollection      help                states.
Parameter           isRunning           stop
ReactiveTask.       loadProgram         unloadProgram
SpeedOfLight        loadStateMachine    unloadStateMachine
Target              ls                  writeProperties
assert              peers
cd                  quit
 (type 'ls' for context info) : 
    </screen>
    <para>
      TAB completion works even across peers, such that you can type
      a TAB completed command to another peer than the current peer.
    </para>
    <para>
      The TaskBrowser is application independent, so that your enduser-application
      might need a more suitable interface. However, for testing and
      inspecting what is happening inside your realtime programs,
      it is a very useful tool. The next sections show how you can add
      properties, commands, methods etc to a TaskContext.
    </para>
  </sect1>
  <sect1 id="basic-task">
    <title>Setting Up a Basic Task</title>
    <para>
      Tasks are rather simple entities in &orocos; and are
      implemented by the <classname>TaskContext</classname> class,
      which should not be confused with the CoreLib periodic Task
      implementations.
      It is useful speaking of a context because it defines
      the context in which the task operates. 
      It defines the interface of the task, its attributes,
      its peer tasks and uses a 
      <classname>Processor</classname> to handle its
      programs and to accept commands from other tasks.
    </para>
    <para>
      A <classname>TaskContext</classname> is constructed as :
    </para>
    <para>
      <programlisting>
  #include &lt;execution/Processor.hpp&gt;
  #include &lt;execution/TaskContext.hpp&gt;

  // we assume this is done in all the following code listings :
  using namespace ORO_Execution;

  Processor   a_processor, b_processor;
  TaskContext a_task("ATask", &amp;a_processor);
  TaskContext b_task("BTask", &amp;b_processor);

  // task creates own (default) Processor :
  TaskContext c_task("CTask");
      </programlisting>
    </para>
    <para>
      The first argument is the (unique) name of the task,
      the second argument is its <classname>Processor</classname>, 
      which is optional. If none is given, the Processor will
      be constructed (and deleted) by the TaskContext itself.
    </para>
    <para>
      A task's interface consists of : Commands,
      Methods, DataSources and Attributes, which are all public.
      We will refer to them as members.
      The TaskContext exports the members (to other tasks)
      by means of object factories.
      Which members are exported is up to the application. Upon
      construction, all factories are empty. A task factory hosts
      object factories, that is, a TaskContext contains
      objects, which have Commands, Methods and/or DataSources,
      which all map to the C++ functions or variables of the task.
    </para>
    <figure id="fig-a-task-context">
      <title>
	Schematic Overview of a TaskContext
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="ATaskContext" />
	</imageobject>
	<caption>
	  <para>The Execution Flow is formed by Programs and
	    State Machines sending commands to Peer Tasks. The Data Flow
	    is the propagation of data from one task to another, where
	    one producer can have multiple consumers.
	  </para>
	</caption>
      </mediaobject>
    </figure>
    <para>
      The object factories can be accessed as such :
    </para>
    <para>
      <programlisting>
  a_task.commandFactory.getObjectFactory("objname");

  a_task.methodFactory.getObjectFactory("objname");
  a_task.dataFactory.getObjectFactory("objname");

  a_task.attributeRepository.getAttribute&lt;Type>("attrname");
      </programlisting>
    </para>
    <sect2>
      <title>The Method Factory</title>
      <para>
	The easiest way to access a TaskContext's interface
	is through Methods. They resemble very much normal C
	or C++ functions. They take arguments and return a value.
	The return value can in return be used as an argument
	for other Methods or stored in a variable. For
	all details, we refer to the &orocos; Program Parser
	Manual.
      </para>
      <para>
	To add a method to the Method Factory, one can use
	the <classname>TemplateMethodFactory</classname>,
	to easily create method factories :</para>
      <para>
	<programlisting>
  #include &lt;execution/TemplateFactories.hpp&gt;

  class ClassX
  {
    public:
    void reset() { ... }
    string getName() { ... }
    double changeParameter(double f) { ... }
    void passByArgument(int&amp; a1, vector&amp; v2) { a1 =...; v2=...; }
    // ...
  };

  ClassX xobj;

  TemplateMethodFactory&lt;ClassX&gt;* fact =
    newMethodFactory( &amp;xobj );
  fact-&gt;add( &quot;reset&quot;,
             method( &amp;ClassX::reset, &quot;Reset the system.&quot; ) );
  fact-&gt;add( &quot;name&quot;,
             method( &amp;ClassX::getName,
                     &quot;Read out the name of the system.&quot; ) );
  fact-&gt;add( &quot;changeP&quot;,
             method( &amp;ClassX::changeParameter,
                     &quot;Change a parameter, return the old value.&quot;,
	             &quot;New Value&quot;, &quot;The new value for the parameter.&quot; ) ); 
  fact-&gt;add( &quot;passByArgument&quot;,
             method( &amp;ClassX::passByArgument,
                     &quot;Method which passes results by argument.&quot;,
		     &quot;I&quot;,&quot;Integer passed by reference&quot;,
	             &quot;V&quot;,&quot;Vector passed by reference&quot; ) ); 

  a_task.methodFactory.registerObject("objname", fact);	</programlisting>
      </para>
      <para>
	The first statement 
	<programlisting>
  TemplateMethodFactory&lt;ClassX&gt;* fact =
    newMethodFactory( &amp;xobj );
	</programlisting>
	constructs a new TemplateMethodFactory, which will create methods
	for the <emphasis>object</emphasis> 'xobj'. A TemplateMethodFactory
	only provides access to one C++ object. 
	After this factory is constructed, we add
	methods to it using the add() function.  The add() function requires a
	name for the added method, and information on the method to be
	associated with that name.  The latter is generated using the
	function method().
      </para>
      <programlisting>
  fact-&gt;add( &quot;reset&quot;,
             method( &amp;ClassX::reset, &quot;Reset the system.&quot; ) );</programlisting>
      <para>
	The <function>method()</function> function requires a pointer to a
	class function having a number of
	arguments, and returning the appropriate result.  The function's
	signature will automatically define the signature in the
	exported API.  After the class function pointer follows a C
	string containing a description of the function, followed by a
	name and description for each of the arguments.
      </para>
<programlisting>
  a_task.methodFactory.registerObject("objname", fact);	</programlisting>
      <para>
	Finally, the factory is stored in the method interface of a_task,
	where it is <emphasis>added</emphasis> to the "objname" methods.
      </para>
      <important>
	<para>The methodFactory, and all other factories of a TaskContext
	take ownership of the registered or added objects. You are not
	allowed to delete them.</para>
      </important>
      <para>
	Using this mechanism, any method of any class can be added to a task's
	method interface. All methods are grouped in an object
	namespace ( here &quot;objname&quot; ), which can be served
	by different classes ( and thus factories ). To invoke this
	method from a script, one can then write :</para>
      <para>
	<programlisting>
  do ATask.objname.changeP( 0.1 )
  // or :
  set result = ATask.objname.changeP( 0.1 ) // store return value

  var int a
</programlisting></para>
      <para>
	If the method should
	belong to the task's interface without an object, the
	&quot;this&quot; object name may be given instead
	of &quot;objname&quot;. Applied to the
	above factory, this would result in :</para>
      <para>
	<programlisting>
  do ATask.changeP( 0.1 )  </programlisting></para>
      <para>
	Any number of methods and objects can be added to a
	TaskContext. Also the methods of the TaskContext
	itself (or its derived classes) may be added. The
	added methods keep their polymorphism, meaning that
	<emphasis>
	  you may add pure virtual methods to the factory.
	</emphasis>
      </para>
    <figure id="fig-task-factories">
      <title>
	  Template Factories and Classes UML Diagram
      </title>
      <mediaobject>
	<imageobject>
	  <imagedata fileref="TaskFactories" />
	</imageobject>
	<caption>
	  <para> This diagram demonstrates how TemplateFactories
	      can be flexibly applied to your class design. They
	      can represent a single object in the TaskContext
	      interface, while it is implemented in different classes
	      ( here : <classname>ClassX</classname> and <classname>YourTask</classname> ).
	      The "this" object stores the task's members.
	  </para>
	</caption>
      </mediaobject>
    </figure>
  </sect2>
  <sect2 id="method-args-types">
      <title>Method Argument and Return Types</title>
      <para>
	The arguments can be of any type. However, to be compatible with
	the Orocos Program Parser variables, it is best to follow the following 
	guidelines :
	<table id="method-args-table">
	  <title>Method Return &amp; Argument Types</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>C++ Type</entry>
		<entry>In C++ functions passed by</entry>
		<entry>Maps to Parser variable type</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Primitive C types : double, int, bool, char</entry>
		<entry><emphasis>value</emphasis> (no const, no reference )</entry>
		<entry>double, int, bool, char</entry>
	      </row>
	      <row>
		<entry>C++ Container types : std::string, std::vector&lt;double&gt;</entry>
		<entry><emphasis>const &amp;</emphasis></entry>
		<entry>string, array</entry>
	      </row>
	      <row>
		<entry>Orocos Fixed Container types : ORO_CoreLib::Double6D, ORO_Geometry::[Frame | Rotation | Twist | ... ]</entry>
		<entry><emphasis>value</emphasis> (no const, no reference )</entry>
		<entry>double6d, frame, rotation, twist, ...</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	Other types than these listed in <xref
	linkend="method-args-table" /> (such as : unsigned int, float,
	std::map, MyClass*, ... ) are allowed, but will be incompatible with
	parsed programs and state machines, meaning, the result or
	arguments can not be stored in a parser variable, but can be
	passed on from method to method, by using the return value of
	one method as argument of another method. Also, using dynamic allocating
	types, will cause memory allocation allong the path, unless proper
	action is taken since the parser copies all types <emphasis>by value</emphasis>.
      </para>
      <para>
	A method can also take pointers as arguments or return pointers to objects,
	but the parser will (unless properly extended) not be able to store them
	in a parser variable.
      </para>
  </sect2>
  <sect2 id="task-attr-rep">
    <title>The Attribute Repository</title>
    <para>
      A TaskContext may have any number of attributes,
      of any type. They can be used by programs in the
      TaskContext to get (and set) configuration data.
      The repository allows to store any C++ value type and
      also knows how to handle Property objects.
    </para>
    <sect3>
      <title>Adding Task Attributes</title>
      <para>
	An attribute can be added in the task's
	<classname>AttributeRepository</classname> like this :</para>
      <para>
	<programlisting>
  a_task.attributeRepository.addAttribute( "aflag", bool(false) );
  a_task.attributeRepository.addAttribute( "max",   int(5) );
      
  Property&lt;std::string&gt; param("Param","Param Description","Value");
  a_task.attributeRepository.addProperty( &amp;param );

  // Put param also in a PropertyBag :
  Property&lt;PropertyBag&gt; bagprop("Collection","Collection Description");
  bagprop.get().add( &amp;param );
  a_task.attributeRepository.addProperty( &amp;bagprop );</programlisting></para>
      <para>
	Which inserts an attribute of type bool and int, name 'aflag' and 'max' and initial
	value of false and 5 to the task's repository. Adding a Property
	is also straightforward. The same property is also added in a bag which
	can also be added to the repository.
	The methods return false if an attribute with that name already exists.
      </para>
      <para>
	You can also add constants, which can then no longer be
	changed :</para>
      <para>
	<programlisting>
  a_task.attributeRepository.addConstant( "pi", double(3.14) );</programlisting></para>
      <para>
	You should again be careful for duplicate entries.
      </para>
      <important>
	<para>The attributeRepository, and all other factories of a TaskContext
	take ownership of the registered or added objects. You are not
	allowed to delete them. Properties are an exception to this rule,
	they remain owned by you and you may only delete them after a removeProperty().</para>
      </important>
    </sect3>
    <sect3>
      <title>Accessing Task Attributes in C++</title>
      <para>
	To get a value from the repository,
      you can use :</para>
      <para>
	<programlisting>
  TaskAttribute&lt;bool&gt;* attrb 
       = a_task.attributeRepository.getAttribute&lt;bool&gt;( "aflag" );

  bool result = attrb->get();
  assert( result == false );

  TaskAttribute&lt;std::string&gt;* attrs 
       = a_task.attributeRepository.getAttribute&lt;std::string&gt;( "Param" );

  assert( attrs.get() == "Value" );</programlisting></para>
    </sect3>
    <sect3>
      <title>Accessing Task Attributes in Scripts</title>
      <para>
	A program script can access the above attributes as in</para>
      <para>
	<programlisting>  // a program in "ATask" does :
  var double pi2 = task.pi * 2.
  var int    myMax = 3
  set task.max = myMax

  // Both assignments below change the same Property !
  set task.Param = "B Value"
  set task.Collection.Param = "C Value"</programlisting>
	<programlisting>  // an external (peer task) program does :
  var double pi2 = ATask.pi * 2.
  var int    myMax = 3
  set ATask.max = myMax	</programlisting></para>
      <para>
	When trying to assign a value to a constant, the script parser
	will throw an exception, thus before the program is run.
	You must always specify the task's name (or 'task') when accessing a
	task's attribute, this is different from methods and commands,
	which may omit the task's name if the program is running within
	the task.
      </para>
      <important>
	<para>
	  The same restrictions of <xref linkend="method-args-types" /> hold for
	  the attribute types, when you want to access them from program scripts.
	</para>
      </important>
    </sect3>
    <sect3>
      <title>Storing and Loading Task Properties</title>
      <para>
	See <xref linkend="task-property-config" /> for storing and loading
	the Properties in a AttributeRepository to and from files, in order
	to save a TaskContext's state.
      </para>
    </sect3>
  </sect2>
  <sect2>
      <title>The Command Factory</title>
      <para>
	The next factory we discuss is the Command Factory,
	which produces C++ <classname>CommandInterface</classname>
	objects which encapsulate a command call to a TaskContext's
	interface. The philosophy behind commands is explained
	in the CoreLib, which defines the CommandInterface and
	in the Program Parser and Processor manuals, which 
	provide easy to use implementations of this interface.
      </para>
      <para>
	To add a command to the Command Factory, one can use
	the <classname>TemplateCommandFactory</classname>,
	to easily create command factories :</para>
      <para>
	<programlisting>
  #include &lt;execution/TemplateFactories.hpp&gt;

  class ClassX
  {
    public:
    bool startCycle() { ... }
    bool cycleDone() const { ... }

    bool cleanupMess(double f) { ... }
    bool isMessCleaned() { ... }
    // ...
  };

  Class_X x_obj;
  TemplateCommandFactory&lt;Class_X&gt;* fact =
    newCommandFactory( &amp;x_obj );
  fact-&gt;add( &quot;startCycle&quot;, 
            command( &amp;Class_X::startCycle,
                     &amp;Class_X::cycleDone,
                     &quot;Start a new cycle.&quot; ) );
  fact-&gt;add( &quot;cleanup&quot;,
            command( &amp;Class_X::cleanupMess,
                     &amp;Class_X::isMessCleaned,
                     &quot;Start cleanup operation.&quot;,
	             &quot;factor&quot;, &quot;A factor denoting the thoroughness.&quot; ) );

  a_task.commandFactory.registerObject("objname", fact);</programlisting></para>
      <para>
	Commands differ from Methods in that they take
	an extra function which is called the Completion
	Condition. It is a function which returns true
	when the command is done. The command itself
	also returns a boolean which indicates if it 
	was accepted or not. Reasons to be rejected
	can be faulty arguments or that the system
	is not ready to accept a new command.
      </para>
      <programlisting>
  fact-&gt;add( &quot;startCycle&quot;, 
            command( &amp;Class_X::startCycle,
                     &amp;Class_X::cycleDone,
                     &quot;Start a new cycle.&quot; ) );</programlisting>
      <para>
	Thus the <function>command()</function> function
	requires two member pointers instead of
	one.  The first one is a function that does the actual work
	that the command will invoke, and the second is a bool
	<emphasis>const</emphasis> function having :</para>
      <itemizedlist>
	<listitem>
	  <para>the same arguments as the command,</para>
	</listitem>
	<listitem>
	  <para>OR only the first argument of the command,</para>
	</listitem>
	<listitem>
	  <para>OR no arguments at all.</para>
	</listitem>
      </itemizedlist>
      <para>
	The second function (the completion condition)
	will be called to see whether the
	associated command is finished.  The rest of the arguments to
	the command function remain the same.  It also requires a
	constant C string describing the function, and two constant C
	strings giving a description and name for every argument.
      </para>
      <important>
	<para>The commandFactory, and all other factories of a TaskContext
	take ownership of the registered or added objects. You are not
	allowed to delete them.</para>
      </important>
      <para>
	The above lets you write in a program script :</para>
      <para>
	<programlisting>
  do objname.startCycle()
  do objname.cleanupMess( 0.1 )	</programlisting></para>
      <para>
	when the program is loaded in a_task.
      </para>
      <para>
	Commands returning false will propagate that error
	to the program or function calling that command, which
	will cause the program to enter an error state, ie
	it stops its execution.
      </para>
      <important>
	<para>
	  The same restrictions of <xref linkend="method-args-types"
	  /> hold for the command and condition types, when you want
	  to access them from program scripts.
	</para>
      </important>
    </sect2>
    <sect2>
      <title>The DataSource Factories</title>
      <para>
	DataSources are read-only objects which, when evaluated,
	return some data. The source of the data can be anything,
	as long as it takes finite time to get it. DataSources
	can be combined to new DataSources using algorithmic
	expressions. The only way they differ from Methods, is
	that the corresponding C++ function must be const.
      </para>
      <sect3>
	<title>The Template DataSource Factory</title>
	<para>
	  To add a method to the DataSource Factory, one can use
	  the <classname>TemplateDataSourceFactory</classname>,
	to easily create DataSource factories :</para>
	<para>
	<programlisting>
  #include &lt;execution/TemplateFactories.hpp&gt;

  class ClassX
  {
    public:
    int _number;
    string getName() const { ... }
    double power(double a, double b) const {}
    // ...
  };

  ClassX xobj;

  TemplateDataSourceFactory&lt;ClassX&gt;* fact =
    newDataSourceFactory( &amp;xobj );
  fact-&gt;add( &quot;number&quot;,
            data( &amp;ClassX::_number,
                  &quot;the number.&quot; ) );
  fact-&gt;add( &quot;name&quot;,
            data( &amp;ClassX::getName,
                  &quot;Read out the name.&quot; ) );
  fact-&gt;add( &quot;power&quot;,
            data( &amp;ClassX::power,
                  &quot;return a to the power of b&quot;,
	          &quot;a&quot;, &quot;the base&quot;, 
	          &quot;b&quot;, &quot;the exponent&quot; ) ); 

  a_task.dataFactory.registerObject("objname", fact);	</programlisting></para>
        <para>
	  which is dus nearly identical to using a method.
	  Notice the usage of the _number class member. The
	  factory also accepts class member variables instead
	  of const functions, but likewise, they are also
	  read-only.
	</para>
	<important>
	  <para>The dataFactory, and all other factories of a TaskContext
	  take ownership of the registered or added objects. You are not
	  allowed to delete them.</para>
	</important>
      </sect3>
      <sect3>
	<title>The Map DataSource Factory</title>
	<para>
	  If your application has set up DataSources itself (for example,
	  using CoreLib DataObjects ), the <classname>MapDataSourceFactory</classname>
	  can be used to add them to you TaskContext's DataSource interface.
	  For example, continued from the program listing of the previous
	  section :
	</para>
	<programlisting> DataObjectInterface&lt;MyDataType&gt;* myData 
     = new DataObjectLockFree&lt;MyDataType&gt;("MyData");

  MapDataSourceFactory::Map storemap;
  storemap["NewData_1"] = myData;
  // store other DataSources...

  // finally :
  MapDataSourceFactory* mdf 
     = new MapDataSourceFactory( storemap, "Thread-safe DataObjects");

  a_task.dataFactory.registerObject("dataobjs", mdf);
	</programlisting>
	<para>
	  Which uses the thread-safe DataObjectLockFree (which
	  implements DataSource) to exchange data between
	  TaskContexts. You must use DataObjectLockFree to exchange
	  any composite type between threads.
	</para>
      </sect3>
      <sect3>
	<title>Accessing DataSources from Scripts</title>
	<para>
	  In scripting, the braces are optional when no arguments must be
	  given. An external task might read the DataSources of "ATask" as such:
	</para>
	<para>
	  <programlisting>
  var int nb = ATask.objname.number
  var double result = ATask.objname.power( 5., 6.)

  task.newData = ATask.dataobjs.NewData_1</programlisting></para>
        <para>
	  Again, the &quot;this&quot; object can be used if the 
	  DataSource should belong to the task's interface.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Creating Commands Without the Factories</title>
      <para>
	It is possible to create a command without the
	Factory and DataSources. This is the prefered way
	if you only intend to use C++ commands and no
	Orocos Program Scripts, which is possible on some
	embedded systems.
      </para>
      <para>
	The key is to use the <classname>CommandFunctor</classname>,
	which is explained in detail in the &procman;. Commands
	created this way can be used analogously as in the next
	sections.
      </para>
      <important>
	<para>
	  The same restrictions of <xref linkend="method-args-types"
	  /> hold for the datasource types, when you want
	  to access them from program scripts.
	</para>
      </important>
    </sect2>
  </sect1>
  <sect1 id="connect-tasks">
    <title>Connecting Tasks</title>
    <para>
      A Real-Time system contains multiple concurrent
      tasks which must communicate to each other.
      TaskContext objects can be connected to each other
      so that they can communicate Real-Time data or commands.
      We call them &quot;Peers&quot; as there is no fixed
      hierarchy. A connection from one TaskContext to its
      Peer can be uni- or bi-directional. In a uni-directional
      connection, only one peer can send commands to the other, while
      in a bi-directional connection, both can send each other
      commands.
    </para>
    <para>
      Peers are connected as such (<methodname>hasPeer</methodname> takes a string 
      argument ):</para>
    <para>
      <programlisting>
  // bi-directional :
  a_task.connectPeers( &amp;b_task );
  assert( a_task.hasPeer( &amp;b_task.getName() ) 
          &amp;&amp; b_task.hasPeer( &amp;a_task.getName() );
  // uni-directional :
  a_task.addPeer( &amp;c_task );
  assert( a_task.hasPeer( &amp;c_task.getName() ) 
          &amp;&amp; ! c_task.hasPeer( &amp;a_task.getName() );</programlisting></para>
    <para>
      This allows to build strictly hierarchical topological
      networks as well as complete flat or circular networks or any
      kind of mixed network.
    </para>
    <para>
      From within a program script, peers can be accessed by
      merely prefixing their name to the member you want to
      access. A program within &quot;ATask&quot; could
      access its peers as such :</para>
    <para>
      <programlisting>
  do BTask.object.command()
  var int result = CTask.method() </programlisting></para>
    <para>
      The peer connection graph can be traversed at arbitrary
      depth. Thus you can access your peer's peers.
    </para>
  </sect1>
  <sect1 id="run-tasks">
    <title>Running Tasks</title>
    <para>
      When a TaskContext is running, it receives its commands from its Processor.
      The Processor will check periodically for new commands
      in it's queue
      and execute programs which are running in the task.
      Thus to start the task, one needs to start the Processor.
      As long as it is not started, it will accept no commands
      and run no programs.
    </para>
    <sect2>
      <title>Starting Periodic Task Execution</title>
      <para>
	To run a Processor, you need to use one of the Periodic
	Task classes from the CoreLib. ( See the &coreman;
	for more documentation. ) Continued from
	<xref linkend="basic-task"/> :</para>
      <para>
	<programlisting>
  #include &lt;corelib/TaskNonPreemptible.hpp&gt;

  using namespace ORO_CoreLib;

  // ... start the processor of a_task :
  TaskNonPreemptible periodicTask(0.001, &amp;a_processor);
  periodicTask.start(); </programlisting></para>
      <para>
	Which will start the processor of ATask with a timer frequency
	of 1kHz. This is the frequency at which state machines are
	evaluated, program steps taken and commands are accepted
	and executed. When the processor is stopped again, all programs
	are stopped, state machines are brought into the final state and
	no more commands are accepted.
      </para>
    </sect2>
    <sect2 id="task-property-config">
      <title>Task Property Configuration</title>
      <para>
	As was seen in <xref linkend="task-attr-rep" />, CoreLib Properties
	can be added to a task's AttributeRepository. To read and write
	properties from or to files, you can use the <classname>PropertyLoader</classname>
	class. It uses the XML Component Property Format such that it is human readable.
      </para>
      <programlisting>  #include &lt;execution/PropertyLoader.hpp&gt;
  // ...
  TaskContext a_task = ...
  PropertyLoader ploader;
  ploader.configure("PropertyFile.cpf", a_task );
  // ...
  ploader.save("PropertyFile.cpf", a_task ); </programlisting>
       <para>
	 Where 'configure' reads the file and configures updates the task's properties
	 and 'save' <emphasis>updates</emphasis> the given file with the properties
	 of the task. It is allowed to share a single file with multiple tasks or
	 update the task's properties from multiple files. The <classname>GenericTaskContext</classname>
	 has implemented this functionality also as script methods.
       </para>
    </sect2>
    <sect2>
      <title>Task Program Scripts</title>
      <para>
	Commands are a Real-Time means of communication between tasks.
	They are asynchronous method calls from one task to another,
	without caring for multi-threaded locking issues.
	A command can be rejected if the other task is not running, which 
	can be detected by the sending task.
      </para>
      <para>
	Commands can 
	be grouped into Orocos Program Scripts (ops), which allow
	programs to be loaded at runtime into a task. The
	program script is parsed to a command object tree,
	which can then be executed by the Processor of a task.
      </para>
      <sect3 id="task-context-functions">
	<title>Functions</title>
	<para>
	  A function is formed by a group of commands and
	  methods, which can be executed by a task.
	  The &parseman; defines functions as :</para>
	<para>
	  <programlisting>
  export function myFun( int arg1, double arg2 )
  {
    // Group commands and methods
    var ...
    do ...

  } 
  // repeat... </programlisting></para>
	<para>
	  where the optional export keyword makes the function
	  available as a task's command ( which will fail
	  if one of its contained commands fail ) :
	  <programlisting>  do ATask.myFun( 1, 2. )</programlisting>
	  If you omit the export keyword, then the function will not
	  become available as a command. To use such a function, you need to 
	  execute it in the Processor ( see below ), or call it in a program,
	  which was parsed in the same file (see <xref linkend="task-context-programs" /> ).
	</para>
	<para>
	  Functions must be parsed by the <classname>Parser</classname>,
	  before they can be executed by the Processor. The Processor
	  executes the Function until it finishes or it goes into error.
	  In both cases, the Function is removed from the Processor's queue
	  and can then safely be deleted (or re-run).</para>
	<note>
	  <para>
	    The <classname>Parser</classname> and <classname>ProgramLoader</classname> are located in the
	    Orocos Program Parser package and not in the Task Context package.
	  </para>
	</note>
	<para>
	  To directly execute any number of <emphasis>not exported</emphasis> functions in a file, 
	  or <emphasis>add</emphasis> an exported function in a TaskContext's Command API, do :
	  <programlisting>  #include &lt;execution/ProgramLoader.hpp&gt;

  TaskContext* a_task = ...
  ProgramLoader loader;
  ProgramLoader::Functions funcs;

  funcs = loader.loadFunction( "Functions.ops", a_task );</programlisting>
           funcs is an STL container wich contains all functions being executed.
	</para>
	<warning>
	  <para>
	    Using loadFunction with functions that require arguments will
	    execute the functions with default initialisation of the arguments.
	    Use the 'low-level' Orocos API (Parser and Processor) to initialise
	    and execute functions with arguments. Otherwise, use programs to
	    call such functions.
	  </para>
	</warning>
      </sect3>
      <sect3 id="task-context-programs">
	<title>Programs</title>
	<para>
	  Programs are special functions in that they
	  can be finely controlled by (and are owned by)
	  the Processor.
	  A program can be paused, it's variables inspected
	  and reset while it is loaded in the Processor.
	  Also, the Processor will delete the program upon
	  request.
	  A program script calling the previous function
	  would look like :</para>
	<para>
	  <programlisting> [ ... myFun() function definition ... ]

  program myBar
  {
    var int i = 1
    var double j = 2.0
    do myFun(i,j)
  }</programlisting>
	  As with functions, any number of programs may be listed in a file.
	</para>
	<para>
	  Orocos Programs are loaded a bit different into a TaskContext
	  :</para>
	<para>
	  <programlisting>
  #include &lt;execution/ProgramLoader.hpp&gt;

  TaskContext* a_task = ...
  ProgramLoader parser;

  loader.loadProgram( "ProgramBar.ops", a_task ); </programlisting></para>
	<para>
	  When the Program is loaded in the Task Context, it can
	  also be controlled from your scripts or TaskBrowser. Assuming
	  you have loaded a Program with the name 'foo', the
	  following commands are available :
	</para>
	<screen>
  do programs.foo.start()
  do programs.foo.pause()
  do programs.foo.step()
  do programs.foo.stop()
	</screen>
	<para>While you also can inspect its status :</para>
	<screen>
  programs.foo.isRunning()
  programs.foo.inError()
  programs.foo.isPaused()
	</screen>
	<para>You can also inspect and change the variables of a loaded program,
	but as in any application, this should only be done
	for debugging purposes.</para>
	<screen>
  set programs.foo.i = 3
  var double oldj = programs.foo.j
	</screen>
	<para>
	  Take a look at the &procman; and the Processor
	  class reference for more program related functions.
	</para>
      </sect3>
      <sect3>
	<title>State Machines</title>
	<para>
	  Hierarchical state machines are modelled in Orocos
	  with the <classname>StateMachine</classname> class.
	  They are like programs in that they can call a
	  peer task's members, but the calls are grouped
	  in a state and only executed when the state machine
	  is in that state. A detailed introduction can be found
	  in the &parseman;. This section limits to showing
	  how an Orocos State Description (osd) script can be loaded in a 
	  Task Context.
	</para>
	<para>
	  <programlisting>
  #include &lt;execution/ProgramLoader.hpp&gt;

  TaskContext* a_task = ...
  ProgramLoader loader;

  loader.loadStateMachine( "StateMachineBar.osd", a_task ); </programlisting></para>
	<para>
	  When the State Machine is loaded in the Task Context, it can
	  also be controlled from your scripts or TaskBrowser. Assuming
	  you have instantiated a State Machine with the name 'machine', the
	  following commands are available :
	</para>
	<screen>
  do states.machine.activate()
  do states.machine.start()
  do states.machine.pause()
  do states.machine.step()
  do states.machine.stop()
  do states.machine.deactivate()
  do states.machine.reset()
  do states.machine.requestMode()
  do states.machine.requestState("StateName")
  ...
	</screen>
	<para>As with programs, you can inspect and change the
	variables of a loaded StateMachine.</para>
	<screen>
  set programs.machine.myParam = ...
	</screen>
	<para>
	  Again, take a look at the &procman; and the Processor
	  class reference for more details about state context related functions.
	</para>
      </sect3>
      <sect3>
	<title>Further Reading</title>
	<para>
	  In addition to this text, be sure to read the &parseman;
	  such that you get a grip of the full power of Real-Time
	  Orocos scripts.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Adding Events</title>
      <para>Events are explained in detail in the &coreman;.
	To add Real-Time events to your task, you can simply 
	instantiate it with a given name :
      </para>
      <programlisting>
  #include &lt;execution/TaskContext.hpp&gt;
  #include &lt;corelib/Event.hpp&gt;

  class MyTask : public TaskContext
  {
     ORO_CoreLib::Event&lt; void( int ) &gt; myEvent;
     int data;
  public:
     MyTask()
	: TaskContext("myTask"),
	  myEvent("theEvent"), data(0)
     {}

     // ...
     void foo() 
     {
        myEvent.fire( data );
     }
  }; </programlisting>
      <para>
	Another Task can then subscribe a handler to that Event,
	and should provide its Processor's task as asynchronous
	completer using <methodname>getTask()</methodname> :
      </para>
      <programlisting>
  #include &lt;execution/TaskContext.hpp&gt;
  #include &lt;corelib/Event.hpp&gt;
  #include &lt;boost/bind.hpp&gt;

  class MyOtherTask : public TaskContext
  {
     ORO_CoreLib::TaskPreemptible ptask;
     int inputdata;
  public:
     MyOtherTask()
	: TaskContext("myTask"),
          ptask( 0.01, this->getProcessor() ),
	  inputdata(0)
     {
     }

     void setUpEvent()
     {
        assert( proc->getTask() != 0 );

	// connect bar with 'theEvent'
        ORO_CoreLib::Event&lt; void (int) &gt;::nameserver.getObject("theEvent")
           ->connect( boost::bind( &amp;MyOtherTask::bar, this), 
                      proc->getTask() );
     }
	
     // The event handler :
     void bar( int in ) 
     {
	this-&gt;inputdata = in;
     }
  }; </programlisting>
      <para>
	Anytime "theEvent" is fired, bar() will be called asynchronously
	in the Task's thread, guaranteeing thread-safe data exchange,
	thus not requiring any mutex locks.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>Applying the Task Infrastructure to Your Application</title>
    <para>
      In addition to the above methods of setting up tasks, this section
      gives some common uses for integrating your existing application
      framework in Orocos Tasks.
    </para>
    <sect2>
      <title>Using the <classname>GenericTaskContext</classname></title>
      <para>
	To help users in setting up quickly a TaskContext, the GenericTaskContext
	class has been made available which adds some standard methods and
	commands to its interface which are common to many tasks. It supports
	loading Programs and StateMachines, saving Properties to disk and reading
	them back in and stopping and starting the Task.
	You can download an introduction to setting up TaskContexts which
	uses this class from the Orocos.org download page.
      </para>
    </sect2>
    <sect2>
      <title>Wrapping Methods in Functions</title>
      <para>
	Methods are always executed in the thread of the caller. If a 
	method does non-realtime operations, like writing data to disk, 
	it should not be called by a realtime thread. However, if the
	thread which owns the method is itself not realtime, it can execute
	the method as a command in its own thread. This can easily be
	accomplished by writing a wrapper function ( or alternatively, 
	register the method as a command too ).
      </para>
      <programlisting>  export function domethod( int arg ) {
     do mymethod( arg )
  } </programlisting>
      <para>
	Load this function with the <classname>ProgramLoader</classname>
	in the TaskContext having 'mymethod', and hard realtime tasks
	can instruct it to execute that method, without jeopardizing 
	their own realtime behaviour.
      </para>
    </sect2>
    <sect2>
      <title>Waiting for Something : Synchronisation</title>
      <para>
	When tasks need to synchronise, you have a wide range of
	options to use. 
      </para>
<!--       <sect3> -->
<!-- 	<title>Waiting in States</title> -->
<!-- 	<para> -->
<!-- 	  A (sub-)State Machine can pause itself and an extra function -->
<!-- 	  in the task's interface can provide the key to progress to -->
<!-- 	  another state. First the StateMachine is loaded in an .osd file  : -->
<!-- 	</para> -->
<!-- 	<programlisting> -->
<!--   StateMachine X { -->
<!--      // ... -->
<!--      state y { -->
<!--         entry { -->
<!--            // pause myself, no transitions are checked. -->
<!--            do this.pause() -->
<!--         } -->
<!--         transitions { -->
<!-- 	   // guard this transition. -->
<!--            if task.checkSomeCondition() then -->
<!--               select z -->
<!--         } -->
<!--      } -->
<!--      state z { -->
<!--        // ... -->
<!--      } -->
<!--   } -->

<!--   RootMachine X x</programlisting> -->
<!-- 	<para>Then, load an ops file which contains :</para> -->
<!-- 	<programlisting> -->
<!--   export function progress() { -->
<!--     // Check if we may progress : -->
<!--     if this.states.x.inState("y") then { -->
<!--         // continue : -->
<!--         do this.states.x.start() -->
<!--         // OR try single transition : -->
<!--         do this.states.x.step() -->
<!--     } -->
<!--   }</programlisting> -->
<!-- 	<para> -->
<!-- 	  A peer task then calls <function>progress()</function> -->
<!-- 	  which in turn checks if the function is applicable. -->
<!-- 	  But even then, the responsibility of the transition -->
<!-- 	  lies within the State Machine. -->
<!-- 	</para> -->
<!-- 	<para> -->
<!-- 	  Off course, the example can be simplified by setting/ -->
<!-- 	  resetting a boolean flag between function and  -->
<!-- 	  State Machine. -->
<!-- 	</para> -->
<!-- 	<programlisting> -->
<!--   StateMachine X { -->
<!--      // ... -->
<!--      state y { -->
<!--         transitions { -->
<!--            if task.progressflag == true then -->
<!--                 select z -->
<!--         } -->
<!--      } -->
<!--      state z { -->
<!--        // ... -->
<!--      } -->
<!--   } -->

<!--   RootMachine X x</programlisting> -->
<!-- 	<para>Then, load an ops file which contains :</para> -->
<!-- 	<programlisting> -->
<!--   export function progress() { -->
<!--     // Check if we may progress : -->
<!--     if this.states.x.inState("y") then { -->
<!--           set task.progressflag = true -->
<!--     } -->
<!--   }</programlisting> -->
<!-- 	<para> -->
<!-- 	  When the user or another program calls the progress() command, -->
<!-- 	  the flag will be set. -->
<!-- 	</para> -->
<!--       </sect3> -->
      <sect3>
	<title>Requesting States</title>
	<para>
	  A State Machine can be used such that it waits for state
	  change requests instead of discovering itself to which 
	  state it makes a transition. This requires the State Machine to run in
	  another mode, the requestState mode ( as opposed to the automatic mode,
	  which is entered by start() ). 
	</para>
	<programlisting>
  StateMachine X {
     // ...
     state y {
        entry {
	   // ...
        }
        transitions {
	   // guard this transition.
           if task.checkSomeCondition() then
              select z
	   // always good to go to states :
	   select ok_1
           select ok_2
        }
     }
     state z {
       // ...
     }
     state ok_1 {
       // ...
     }
     state ok_2 {
       // ...
     }
  }

  RootMachine X x</programlisting>
	<para>Then, load an ops file which contains :</para>
	<programlisting>
  export function progress() {
       // request to enter anther state :
       do this.states.x.requestState("z")
    }
  export function progress_Ok() {
       // this will succeed always from state 'x' :
       do this.states.x.requestState("ok1")
    } </programlisting>
         <para>
	   This command will fail if the transition is not 
	   possible ( for example, the state machine is not in
	   state y, or task.checkSomeCondition() was not true ),
	   otherwise, the state machine will make the transition
	   and the command succeeds and completes when the z state
	   is fully entered (it's init program completed).
	 </para>
	 <para>
	   To merely request that a state is handled, one can
	   call requestState on the current state :
	 </para>
	<programlisting>
  export function handleState() {
       // request to handle current state :
       do this.states.x.requestState( this.states.x.getState() )
    }  </programlisting>
	 <para>
	   To request to go to the next possible state (or call handle if
	   none) and then wait again for requests, use 'step()' :
	 </para>
	<programlisting>
  export function evaluate() {
       // request go to the next state and wait :
       do this.states.x.step()
    }  </programlisting>
         <para>
	   Note that if the StateMachine happened to be paused, step() would
	   only progress one single statement. To check if the StateMachine
	   is waiting for requests, use the 'inRequest()' method :
	 </para>
	<programlisting>
  export function progress() {
       if ( this.states.x.inRequest() ) {
           // ... it's waiting
       } else {
          // was not waiting, possibly running, paused or non active
       }
    }  </programlisting>
        <para>
	  All these methods can of course also be called from parent
	  to child State Machine, or across tasks.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Polymorphism : Task Interfaces</title>
      <para>
	Most projects have define their own task interfaces in C++.
	Assume you have a class with the following interface :
      </para>
      <programlisting>
  class DeviceInterface
  {
  public:
    /**
     * Set/Get a parameter. Returns false if parameter is read-only.
     */
    virtual bool setParameter(int parnr, double value) = 0;
    virtual double getParameter(int parnr) const = 0;

    /**
     * Get the newest data.
     * Return false on error.
     */
    virtual bool updateData() = 0;
    virtual bool updated() const = 0;

    /**
     * Get Errors if any.
     */
    virtual int getError() const = 0;
  };</programlisting>
      <para>
	Now suppose you want to do make this interface available,
	such that program scripts of other tasks can access this 
	interface. Because you have many devices, you surely want
	all of them to be accessed transparantly from a supervising
	task. Luckily for you, C++ polymorphism can be transparantly
	adopted in Orocos TaskContexts. This is how it goes.
      </para>
      <sect3>
	<title>Step 1 : Export the interface</title>
	<para>We construct a TaskContext, which exports your
	C++ interface to a task's interface.
	</para>
	<programlisting>
  #include &lt;execution/TaskContext.hpp&gt;
  #include &lt;execution/TemplateFactories.hpp&gt;
  #include "DeviceInterface.hpp"

  class TaskDeviceInterface
    : public DeviceInterface,
      public TaskContext
  {
  public:
      TaskDeviceInterface()
        : TaskContext( "DeviceInterface" )
      {
         this->setup();
      }

      void setup() 
      {
         // Add Methods :
         TemplateMethodFactory&lt;DeviceInterface&gt;* mfact =
            newMethodFactory( this );
         mfact-&gt;add(&quot;setParameter&quot;,
                    method(&amp;DeviceInterface::setParameter,
	                   &quot;Set a device parameter.&quot;,
	                   &quot;Parameter&quot;, &quot;The number of the parameter.&quot;,
	                   &quot;New Value&quot;, &quot;The new value for the parameter.&quot;)); 
         this->methodFactory.registerObject("this", mfact);

         // Add Data Sources :
         TemplateDataSourceFactory&lt;DeviceInterface&gt;* dfact =
            newDataSourceFactory( this );
         dfact-&gt;add( &quot;getParameter&quot;,
                     data(&amp;DeviceInterface::getParameter,
	                  &quot;Get a device parameter.&quot;,
                          &quot;Parameter&quot;, &quot;The number of the parameter.&quot;));
         dfact-&gt;add(&quot;getError&quot;,
                    data(&amp;DeviceInterface::getError,
	                 &quot;Get device error status.&quot;));
         this->datasourceFactory.registerObject("this", dfact);

         // Add Commands :
         TemplateCommandFactory&lt;DeviceInterface&gt;* cfact =
            newCommandFactory( this );
         cfact-&gt;add( &quot;updateData&quot;,
                        command( &amp;DeviceInterface::updateData,
                                 &amp;DeviceInterface::updated,
                                 &quot;Command data acquisition.&quot; ) );
         this->commandFactory.registerObject("this", cfact);
      }
  };</programlisting>
	<para>
	  The above listing just combines all factories which were introduced
	  in the previous sections. Also note that the TaskContext's name
	  is fixed to "DeviceInterface". This is not obligatory though.
	</para>
      </sect3>
      <sect3>
	<title>Step 2 : Inherit from the new interface</title>
	<para>Your DeviceInterface implementations now
	  only need to inherit from <classname>TaskDeviceInterface</classname>
	  to instantiate a Device TaskContext :
	</para>
	<programlisting>
  #include "TaskDeviceInterface.hpp"

  class MyDevice_1 
    : public TaskDeviceInterface
  {
  public:

    bool setParameter(int parnr, double value) {
      // ...
    }
    double getParameter(int parnr) const {      // ...
    }
    // etc.
  };
	</programlisting>
      </sect3>
      <sect3>
	<title>Step 3 : Add the task to other tasks</title>
	<para>
	  The new TaskContext can now be added to other tasks.
	  If needed, an alias can be given such that the
	  peer task knows this task under another name.
	  This allows the user to access different incarnations
	  of the same interface from a task.
	</para>
	<programlisting>
	  // now add it to the supervising task :
  MyDevice_1 mydev;
  supervisor.addPeer( &amp;mydev, "device" );
	</programlisting>
	<para>
	  From now on, the "supervisor" task will be able to access
	  "device". If the implementation changes, the same interface
	  can be reused whithout changing the programs in the supervisor.
	</para>
	<para>
	  A big warning needs to be issued though : if you change a
	  peer at runtime (after parsing programs),
	  you need to reload all the programs, functions,
	  state contexts which use that peer so that they reference
	  the new peer and its C++ implementation.
	</para>
      </sect3>
      <sect3>
	<title>Step 4 : Use the task's interface</title>
	<para>To make the example complete, here is an example
	script which could run in the supervisor task :
	</para>
	<programlisting>
  program ControlDevice
  {
     const int par1 = 0
     const int par2 = 1
     do device.setParameter(par1, supervisor.par1 )
     do device.setParameter(par2, supervisor.par2 )

     while ( device.getError() == 0 ) 
     {
	if ( this.updateDevice("device") == true )
           do device.updateData() until {
	        if done || ( device.getError() != 0 ) then
	           continue
	   }
     }
     do this.handleError("device", device.getError() )
  }</programlisting>
	<para>To start this program from the TaskBrowser, browse to supervisor
	  and type the command :</para>
	<screen>
  device.programs.ControlDevice.start()
	</screen>
	<para>
	  When  the program "ControlDevice" is started,
	  it initialises some parameters from its own attributes.
	  Next, the program goes into a loop and sends updateData commands
	  to the device as long as underlying supervisor (ie "this") logic requests
	  an update and no error is reported. This code guarantees that
	  no two updateData commands will intervene each other since the
	  program waits for the commands completion or error.
	  When the device returns
	  an error, the supervisor can then handle the error of the
	  device and restart the program if needed.
	</para>
	<para>
	  The advantages of this program over classical C/C++ functions are :
	</para>
	<itemizedlist>
	  <listitem>
	    <para>If any error occurs (ie a command or method returns false),
	    the program stops and other programs or state contexts can
	    detect this and take apropriate action.</para>
	  </listitem>
	  <listitem>
	    <para>The  "<function>device.updateData()</function>" call waits
	    for completion of the remote command, but can be given other
	    completion or error conditions to watch for.</para>
	  </listitem>
	  <listitem>
	    <para>While the program waits for <function>updateData()</function>
	      to complete, it does not block other programs, etc within
	      the same TaskContext and thread.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      There is no need for additional synchronisation primitives
	      between the supervisor and the device since the commands
	      are queued and executed in the thread of the device, which
	      leads to :
	    </para>
	    <itemizedlist>
	      <listitem>
		<para>The command is executed at the priority of the device's
		  thread, and not the supervisor's priority.</para>
	      </listitem>
	      <listitem>
		<para>The command can never corrupt data of the device's thread,
		  since it is <emphasis>serialised</emphasis>(executed after)
		  with the programs running in that thread.
		</para>
	      </listitem>
	    </itemizedlist>
	  </listitem>
	</itemizedlist>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>Using Commands and Methods Directly in C++</title>
    <para>
      Besides using scripts, you can directly build C++ commands or
      methods, although it requires more &quot;red tape&quot;. The
      advantage is that you are not limited to the scripting
      language's syntax and do not need to use the script parsers.
    </para>
    <sect2>
      <title>Sending a Task a Command</title>
      <para>
	To request a command from one task to another task, the
	command must be fetched from the factories of a TaskContext
	and next passed to that TaskContext which has two methods to
	accept commands. In a C++ program, this would be : </para>
      <para>
	<programlisting>
  // for GenerateDataSource :
  #include &lt;execution/DataSourceGenerator.hpp&gt;

  //...
  TaskContext* peer = this->getPeer("ATask");

  // Create the command argument list.
  // up to 4 arguments can be given to GenerateDataSource()(...)
  std::vector&lt;DataSourceBase::shared_ptr&gt; args 
     = GenerateDataSource()(1.0); 

  // Create the command and condition :
  try {
     ComCon comcon =
        peer->commandFactory.getObjectFactory("objname")->
	     create("cleanupMess", args );
  } catch ( ... ) {
     // wrong arguments !
  }

  // Execute the command (real-time):
  if ( peer->executeCommand( comcon.first ) ==  false ) {
       // Processor does not accept commands !
  }

  // wait until done :
  while ( comcon.second->evaluate() == false )
     sleep(1);
  // command done, we can now delete it or keep it.	</programlisting></para>
      <para>
	The factory can throw exceptions if the number of arguments,
	the type of arguments or the command names are unknown.
	It returns a <classname>ComCon</classname> struct, where the
	<varname>first</varname> member contains a pointer to the
	CommandInterface and the <varname>second</varname> member
	contains a pointer to the ConditionInterface ( the Completion
	Condition ).
	<methodname>executeCommand</methodname> passes
	the command to the task's processor and returns true if
	accepted by the processor.
	The alternative is <methodname>queueCommand</methodname> :
      </para>
      <para>
	<programlisting>
  // ... see previous listing
  int qnb = peer->queueCommand( comcon.first );
  if ( qnb == 0 ) {
	// Error, not accepted !
  }
  while ( !peer->getProcessor()->isProcessed( qnb ) )
        sleep(1); // wait until the command is processed

  while ( comcon.second->evaluate() == false )
        sleep(1); // wait until the command is done
  // command done, we can now delete it or keep it.	</programlisting></para>
      <para>
	You only know if it got in the queue, but not if the command
	function itself returned true.
      </para>
    </sect2>
    <sect2>
      <title>Advanced Command Queueing</title>
      <para>
	The previous section showed how a command can be given to a
	task, but the return value of the Command was lost.  In some
	cases, this does not matter, but when the program logic needs
	to know the result, two options are possible. One can write a
	program script, which check command return values (and goes
	into error if the command fails) or wrap the command in a
	<classname>TryCommand</classname> .
      </para>
      <para>
	Assume you have a command,condition pair as above :</para>
      <para>
	<programlisting>
  ComCon comcon = ...;	</programlisting></para>
      <para>
	Before queueing, you can wrap both command and condition
	as such :</para>
      <para>
	<programlisting>
  #include &lt;execution/TryCommand.hpp&gt;
  // ...
  TryCommand* trycommand
     = new TryCommand( comcon.first );

  DataSource&lt;bool&gt;::shared_ptr executed
     = trycommand->executed();
  DataSource&lt;bool&gt;::shared_ptr accepted 
     = trycommand->result();

  peer->queueCommand( trycommand );
  
  while ( executed->get() == false )
     sleep(1); // wait for its execution
  if ( accepted->get() == false ) {
     // Error, Command returned false !
  }
  while ( comcon.second->evaluate() == false )
     sleep(1); // wait for its completion	</programlisting></para>
      <para>
	The DataSources are used by the TryCommand to
	store the result into. We use the <function>get()</function> function
	to inspect the results. If you want to reuse the
	trycommand, you need to <function>reset()</function>
	the trycommand such that <function>executed()</function> and
	<function>result()</function> functions are reset to their
	initial values.
      </para>
    </sect2>
    <sect2>
      <title>Calling a Task's Method</title>
      <para>
	To call a task's method, the method must be fetched from the
	factories of a TaskContext.  In a C++ program, this would be :
      </para>
      <para>
	<programlisting>
  // for GenerateDataSource() :
  #include &lt;execution/DataSourceGenerator.hpp&gt;
  // for AdaptDataSource() :
  #include &lt;execution/DataSourceAdaptor.hpp&gt;

  //...
  TaskContext* peer = this->getPeer("ATask");

  // Create the command argument list.
  // up to 4 arguments can be given to GenerateDataSource()(...)
  std::vector&lt;DataSourceBase::shared_ptr&gt; args 
     = GenerateDataSource()(0.1); 

  // Create the method object :
  try {
     DataSourceBase::shared_ptr meth =
        peer->methodFactory.getObjectFactory("objname")->
	     create("changeP", args );
  } catch ( ... ) {
     // wrong arguments !
  }

  // Call the method (always synchronously):
  meth->evaluate();

  // OR : to retrieve the return value you need to do :
  DataSource&gt;double&lt;::shared_ptr meth2 = AdaptDataSource&lt;double&gt;()( meth );

  double result = meth2->get(); // assert that meth2 != 0 !
</programlisting></para>
      <para>
	The method factory can throw exceptions if the number of
	arguments, the type of arguments or the command names are
	unknown.  It returns a <classname>DataSourceBase*</classname>
	pointer which you <emphasis>must</emphasis> store in a
	<classname>DataSourceBase::shared_ptr</classname> object, such
	that memory deallocation can be managed. If you want the return
	value of the method, you need to adapt it first to a DataSource
	of the correct type. <classname>AdaptDataSource&gt;T&lt;()(arg)</classname>
	will return null if the argument can not be converted to to T.
	Upon success you can then use the <function>get()</function>
	function to execute the method <emphasis>and</emphasis> collect
	the result; <function>evaluate()</function> on the other hand
	only executes the method and does not return the result.
      </para>
    </sect2>
    <sect2>
      <title>Passing results by argument</title>
      <para>
	The same rules apply for passing values by argument as with scripts.
	A method, command or completion condition may store the results in its arguments, given
	that the DataSources are of type <classname>AssignableDataSource</classname>.
	After the command or method finished, you find the new values in the objects
	referenced by <classname>vector&lt;DataSourceBase::shared_ptr&gt;</classname>.
      </para>
    </sect2>
  </sect1>
</article>
