<?xml version='1.0'?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd" 
[
<!ENTITY cvs         "<acronym>CVS</acronym>">
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY rtai        "<acronym>RTAI</acronym>">
<!ENTITY rtos        "<acronym>RTOS</acronym>">
<!ENTITY taskman     "<ulink url='http://people.mech.kuleuven.ac.be/~psoetens/orocos-packages/orocos-task-context.html'>Task Infrastructure Manual</ulink>">
]
>


<article>
  <articleinfo>
    <title>
      The Orocos Program Parser Manual
    </title>
    <subtitle><emphasis>Open RObot COntrol Software</emphasis></subtitle>
    <authorgroup>
      <author>
	<firstname>Dominique</firstname>
	<surname>Devriese</surname>
      </author>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>2003,2004</year>
      <holder>Herman Bruyninckx</holder>
    </copyright>
    
    <abstract>
      <para>
	This document describes the &orocos; Parser system, in the
	different ways it can be used and extended.
      </para>
    </abstract>
    
    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>20 Aug 2003</date>
	<authorinitials>DD</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.11.0</revnumber>
	<date>31 Oct 2003</date>
	<authorinitials>PS</authorinitials>
	<revremark>Updated to reflect new release</revremark>
      </revision>
      <revision>
	<revnumber>0.12.0</revnumber>
	<date>2 Feb 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>Support for functions and State Graph parsing</revremark>
      </revision>
      <revision>
	<revnumber>0.13.0</revnumber>
	<date>31 March 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>State Graph : Added Final_State</revremark>
      </revision>
      <revision>
	<revnumber>0.14</revnumber>
	<date>2 June 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>Corrected examples</revremark>
      </revision>
      <revision>
	<revnumber>0.16</revnumber>
	<date>July 2004</date>
	<authorinitials>DD</authorinitials>
	<revremark>New State Context syntax</revremark>
      </revision>
      <revision>
	<revnumber>0.18</revnumber>
	<date>21 Sept 2004</date>
	<authorinitials>PS</authorinitials>
	<revremark>Documented methods, 'and', 'try...catch'. Added exported
	functions, function arguments and TaskContext integration.</revremark>
      </revision>
	
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <sect1 id="intro">
    <title>Introduction</title>
    <para>
      The &orocos; Parser allows users of the &orocos; system to write
      programs and state machines controlling the system in a
      user-friendly script language.  The advantage of scripting is
      that it is easily extendible and does not need recompilation of
      the main program. It is implemented using the Boost.Spirit
      parser library, and should be fairly easy to work with.
    </para>
    <para>
      There are three ways that people need to use the &orocos; Parser
      framework, and this documentation is split up accordingly.  The
      following chapters each deal with one of these aspects, and can
      be read separately.  You are encouraged to skip ahead to the
      part that interests you.
      <itemizedlist>
	<listitem>
	  <para>
	    <link linkend="program-syntax">Writing &orocos; Programs and State Configurations.</link>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <link linkend="exporting-component-api">
	      Exporting the API of an &orocos; component to the
	      &orocos; Parser.
	    </link>
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <link linkend="extending-the-parser">
	      Extending the &orocos; parser to support extra types,
	      overload existing operators, and/or add new operators.
	    </link>
	  </para>
	</listitem>
      </itemizedlist>
      This documentation tackles only these three aspects.  If you
      want to do more advanced things with the &orocos; Parser system,
      you'll have to dig into the source code.  It should be fairly
      well documented.
    </para>
  </sect1>

  <sect1 id="program-syntax">
    <title>Orocos Program Scripts</title>
    <sect2 id="program-syntax-general-concepts">
      <title>General concepts</title>
      <para>
	Before starting to explain Program Syntax, it is necessary to
	explain some general concepts that are used throughout the
	program syntax.
      </para>
      <sect3 id="program-syntax-comments">
	<title>Comments</title>
	<para>
	  Various sorts of comments are supported in the syntax.  Here
	  is a small listing showing the various syntaxes:
	  <programlisting>
  # A perl-style comment, starting at a &apos;#&apos;, and running until
  # the end of the line.
  
  // A C++/Java style comment, starting at &apos;//&apos;, and running
  // until the end of the line.
  
  /* A C-style comment, starting at &apos;/*&apos;, and running until
     the first closing */ /* Nesting is not allowed, that&apos;s
     why I have to start a new comment here :-) 
  */
	  </programlisting>
	  Whitespace is in general ignored, except for the fact that it
	  is used to separate tokens.
	</para>
      </sect3>
      <sect3 id="program-syntax-identifiers">
	<title>Identifiers</title>
	<para>
	  Identifiers are names that the user can assign to variables,
	  constants, aliases, labels.  The same identifier can only be
	  used once, except that for labels you can use an identifier
	  that has already been used as a variable, constant or alias.
	  However, this is generally a bad idea, and you shouldn't do
	  it.
	</para>
	<para>
	  Some words cannot be used as identifiers, because they are
	  reserved by the &orocos; Scripting Framework, either for
	  current use, or for future expansions.  These are called
	  keywords.  The current list of reserved keywords is included
	  here:
	  <simplelist columns="7">
	    <member>alias</member>
	    <member>and</member>
	    <member>async</member>
	    <member>bool</member>
	    <member>char</member>
	    <member>catch</member>
	    <member>const</member>
	    <member>define</member>
	    <member>do</member>
	    <member>done</member>
	    <member>double</member>
	    <member>else</member>
	    <member>end</member>
	    <member>false</member>
	    <member>for</member>
	    <member>foreach</member>
	    <member>frame</member>
	    <member>if</member>
	    <member>include</member>
	    <member>int</member>
	    <member>next</member>
	    <member>not</member>
	    <member>nothing</member>
	    <member>or</member>
	    <member>rotation</member>
	    <member>set</member>
	    <member>stop</member>
	    <member>string</member>
	    <member>then</member>
	    <member>time</member>
	    <member>to</member>
	    <member>true</member>
	    <member>try</member>
	    <member>twist</member>
	    <member>until</member>
	    <member>var</member>
	    <member>vector</member>
	    <member>while</member>
	    <member>wrench</member>
	  </simplelist>
	  These, and all variations on the (upper- or lower-) case of
	  each of the letters are reserved, and cannot be used as
	  identifiers. 
	</para>
      </sect3>
      <sect3 id="program-syntax-expressions">
	<title>Expressions</title>
	<para>
	  Expressions are a general concept used throughout the Parser
	  system.  Expressions represent values that can be calculated
	  at runtime (like a+b).  They can be used as arguments to
	  functions, conditions and whatmore.  Expressions implicitly
	  are of a certain type, and the Parser system does strong
	  type-checking.  Expressions can be constructed in various
	  ways, that are described below...
	</para>
	<sect4>
	  <title>Task Data Sources</title>
	  <para>
	    Tasks can export read-only data.  This data can be of any
	    possible type, and the Parser system retains that type
	    information.  Getting component data is done using an
	    expression of the following form:</para>
	  <para>
	    <programlisting>
  task.dataname( argument1, argument2, ..., argumentN ) 	    </programlisting></para>
	  <para>
	    where "task" is the name of the <classname>TaskContext</classname> whose data
	    you want to access, dataname is the name of the data
	    member of the task you want to access.  "argument1"
	    through "argumentN" are the arguments you want to pass to
	    the data call, and can be any kind of expression.  If a
	    data call needs no arguments, the parentheses can be left
	    out, like this:</para>
	    <programlisting>
  // equivalent to task.dataname()
  task.dataname	    </programlisting>
	</sect4>
	<sect4>
	  <title>Task Methods</title>
	  <para>
	    Methods are analogous to the data in the previous section.
	    But they can be used in expressions and executed as a command.
	    For example, a method returning a boolean can be used
	    in an 'if' clause and in a 'do' statement (see below).
	  </para>
	    <programlisting>
  // executed as a method :
  bool result = task.methodname( argument1, argument2, ..., argumentN )

  // executed as a command :
  do task.methodname( argument1, argument2, ..., argumentN )	    </programlisting>
	</sect4>
	<sect4>
	  <title>Literals</title>
	  <para>
	    Literal values of various types are supported: string,
	    int, double, bool.  Boolean literals are either the word
	    "true" or the word "false".  Integer literals are normal,
	    positive or negative integers.  Double literals are C/C++
	    style double-precision floating point literals.  The only
	    difference is that in order for the Parser to be able to
	    see the difference with integers, we require a dot to be
	    present.  String literals are surrounded by double quotes,
	    and can contain all the normal C/C++ style escaped
	    characters.  Here are some examples:
	    <programlisting>
  // a string with some escaped letters:
  &quot;\&quot;OROCOS rocks, \&quot; my mother said...&quot;
  // a normal integer
  -123
  // a double literal
  3.14159265358979
  // and another one..
  1.23e10  	    </programlisting>
  	  </para>
	</sect4>
	<sect4>
	  <title>Constants, Variables and Aliases</title>
	  <para>
	    Constants, variables and aliases allow you to work with
	    data in an easier way.  A constant is a name which is
	    assigned a value at the place of its definition, and keeps
	    that value throughout the rest of the program.  A variable
	    is like a constant, but its value can be changed at other
	    places in the program.  An alias does not carry a value,
	    it is defined with an expression, for which it acts as an
	    alias or an abbreviation during the rest of the program.
	    All of them can always be used as expressions.  Here is
	    some code showing how to use them.
	  </para>
	    <programlisting>
  // define a constant of type double, with name "pi",
  // and value 3.14159265358979
  const double pi = 3.14159265358979
  // define a constant string and give it the initial
  // value "apples"
  const string applestring = &quot;apples&quot;
  
  // define a variable of type int, called counter,
  // and give it the initial value 0.
  var int counter = 0
  // add 1 to the counter variable
  set counter = counter + 1
  
  // make the name "counterPlusOne" an alias for the
  // expression counter + 1.  After this, using
  // counterPlusOne is completely equivalent to using
  // counter + 1
  alias int counterPlusOne = counter + 1
  // you can assign an arbitrarily complex expression
  // to an alias
  alias int reallycomplexalias = ( ( counter + 8 ) / 3 )*robot.position    </programlisting>
	  <para>
	    Variables, constants and aliases are only supported for
	    the following types: bool, int, double, string, rotation,
	    vector, frame, double6D.
	  </para>
	</sect4>
	<sect4>
	  <title>Operators</title>
	  <para>
	    Expressions can be combined using the c-style operators
	    that you are already familiar with if you have ever
	    programmed in C, C++ or Java.  All operators are
	    supported, except for the if-then-else operator ("a?b:c"),
	    and the precedence is the same as the one used in C, C++,
	    Java and similar languages.
	  </para>
	  <para>
	    However, the operators are only defined for a limited set
	    of types.  You can apply the usual operators to
	    expressions of types bool, int, double, bool and vector.
	    I'm not going to include an exhaustive list here of the
	    available operators, but in general all that you would
	    expect, is present.
	  </para>
	</sect4>
	<sect4>
	  <title>Constructors</title>
	  <para>
	    For some special types, a special kind of operator is
	    provided.  These are called constructors.  The simplest
	    example is the vector constructor, that looks like this:</para>
	  <para>
	    <programlisting>
  vector( arg1, arg2, arg3 )	    </programlisting></para>
	  <para>
	    where arg1, arg2 and arg3 are expressions which
	    <emphasis>must be of type double</emphasis>.
	    This returns an expression of type vector, with arg1 as
	    the x component, arg2 as the y component, and arg3 as the
	    z component.
	  </para>
	  <para>
	    Other constructors currently available are:
	  </para>
	    <programlisting>
  // alfa, beta and gamma are double expressions, this
  // returns a rotation, that is constructed using the
  // EulerZYZ convention:
  // First rotate around Z with alfa, then around the
  // new Y with beta, then around new Z with gamma.
  var rotation rot = rotation( alfa, beta, gamma )
  
  // Vect is a vector expression, rot is a rotation
  // expression.  This returns a frame, constructed
  // using the vector x as the origin, and rotation
  // rot as the rotation..
  var frame f = frame( vect, rot )
  
  // Double6D is a commonly used type in Orocos
  // and has been recently introduced in the parser
  var double6d d6 = double6d(0.0)
  set d6[0] = 1.0
  var double d0 = d6[0]
  set d6 = double6d( 1., 2., 3., 4., 5., 6. ) </programlisting>
	</sect4>
      </sect3>
    </sect2>
    <sect2>
      <title>Parsing and Loading Programs</title>
      <para>
	Before we go on describing the details of the programs syntax,
	we show how you can load a program in your Real-Time Task.
      </para>
      <para>
	Assume that you have a program "progname"
	in a file <filename>program.ops</filename>.
	You've read the Orocos Task Infrastructure manual and constructed
	a <classname>TaskContext</classname> which has some methods and is connected to its
	Peer TaskContexts. Parsing the program is then straightforward :
      </para>
      <programlisting>
  #include &lt;corelib/TaskPreemptible.hpp&gt;
  #include &lt;execution/TaskContext.hpp&gt;
  #include &lt;execution/Parser.hpp&gt;
  #include &lt;iostream&gt;      // std::ifstream
  #include &lt;functional&gt;    // std::for_each
  #include &lt;boost/bind.hpp&gt;// boost::bind

  using namespace ORO_CoreLib;

  TaskContext   tc;
  ORO_CoreLib::TaskPreemptible ptask(0.01, tc->getProcessor() );
  Parser        parser;

  std::vector&lt;ProgramGraph*&gt; pg_list;
  try {
      pg_list = parser.parseProgram( std::ifstream("program.ops"), &amp;tc );
  }
  catch( const file_parse_exception&amp; exc )
  {
     std::cerr &lt;&lt; exc.what() &lt;&lt; endl;
  }
  if ( pg_list.empty() )
  {
     // no programs were listed, but functions might
     // have been exported into tc's command interface
  } else {
     // Load all listed programs in the TaskContext's Processor:
     std::for_each( pg_list.begin(), pg_list.end(),
         boost::bind( &amp;Processor::loadProgram, tc.getProcessor(), _1));

     // start the task :
     ptask->start();

     // start a program :
     tc.getProcessor()->startProgram("progname");
  }</programlisting>
      <para>
	The parser returns a vector of <classname>ProgramGraph</classname>'s.
	It will throw a <classname>file_parse_exception</classname>
	if a parse error occured.
	It is possible that the returned list is empty, but that 
	exported functions were loaded in the TaskContext's command interface.
	If it's not empty, we load all the programs in the Processor using
	the boost::bind function. Next we start the task's processor
	and finally, the program "progname" is started.
      </para>
    </sect2>
    <sect2 id="program-syntax-specifics">
      <title>Program Syntax</title>
      <para>
	An &orocos; program is a list of statements, quite similar
	to a C program. Programs can call functions and functions
	can be loaded into the system, such that other programs
	can call them.
      </para>
      <sect3>
	<title><symbol>program</symbol></title>
	<para> A program is formed like this: </para>
	<programlisting>
  program prog_name {
    // an arbitrary number of statements
  }	</programlisting>
	<para>
	  The statements are executed in order, starting at the first.
	  One statement is executed per tick.  There are currently three
	  kinds of statements, they are explained below. A program takes
	  no arguments and is executed by the Program <classname>Processor</classname>.
	</para>
	<para>
	  If any of the statements causes a run-time error, the Program Processor
	  will put the program in the error state and stop executing it.
	  It is the task of other logic (like state machines, see below)
	  to detect such failures. 
	</para>
      </sect3>
      <sect3>
	<title><symbol>function</symbol></title>
	<para>Statements
	can be grouped in functions. A function can only call a function
	which is earlier defined. Thus recursive function calling is not allowed.
	</para>
	<programlisting>
  function func_name( int arg1, double arg2 ) {
    // an arbitrary number of statements
  }
  
  export function func_nameN(bool arg) {
    // ...
  }</programlisting>
        <para>
	  A function can have any number of arguments, which are passed
  	  by value, but it returns no value.
  	  A function can be exported, in which case it becomes a public
	  available command (see below), which will fail if one of its
	  commands fails. Exporting functions is a powerfull means to
	  build reusable code in the scripting framework, since an
	  external task can not see if it is calling a function or
	  calling a C++ command.
	</para>
      </sect3>
      <sect3>
	<title>Command Call Statements</title>
	<para>
	  A command call statement is a statement that calls a certain
	  command, and defines some reactions. It looks like:
	  <programlisting>
  do comp.action( args ) until {
    if condition then continue
    if condition2 then call func()
    if condition3 then return
  }  	  </programlisting>
  	  It calls the command "action", on the component "comp", with
  	  the comma-separated list of expressions args as the
  	  arguments.  The Processor executes the command once, and
  	  then checks where to go next using the "completion clauses"
	  in the until part.  If none are true, then it waits another
	  tick, and checks them again..
	</para>
	<note>
	  <para>
	    These if .. then clauses are different from the
	    if/then/else statement later in this tekst and purely
	    meant to detect alternative end conditions of a command.
	  </para>
	</note>
	<para>
	  Sometimes, you want to continue executing the command, while
	  checking the completion conditions, instead of only
	  executing it the first time..  In that case, you can put the
	  keyword "sync" before the command call.
	  <programlisting>
  // continue moving to the right until you hit the wall..
  do sync robot.move( robot.position + vector( 1.0, 0.0, 0.0 ) )
      until { if robot.hitWall() then return }  </programlisting>
	  The example above may be a bit stupid, but it only serves to
	  show the use of the sync keyword..
	</para>
	<para>
	  A completion clause always looks like</para>
	  <programlisting>
  if condition then continue
  // or
  if condition then call func_name
  // or
  if condition then return  </programlisting>
	<para>
	  condition can be any kind of expression, that is of type
	  boolean.  One special condition is provided, the keyword
	  "done".  Every command has an associated "implicit
	  completion condition", and the condition "done" is
	  equivalent to that condition.  You can also combine the
	  "done" condition with other expressions, as if it were a
	  normal boolean expression. "continue" means to go to the
	  next statement, return means to end the current program
	  or function.
	  The "call func_name" statement calls a function and is explained 
	  in the next section
	</para>
	<para>
	  If a completion list is left out, then an implicit one is
	  generated.  This means that the two following statements are
	  equivalent:
	</para>
	  <programlisting>
  do comp.action( args )
  // the implicitly generated completion list always looks like
  // "if done then continue"
  do comp.action( args ) until { if done then continue }
	  </programlisting>
	<sect4>
	  <title>Accepting and Rejecting Commands</title>
	  <para>
	    A command can be accepted or rejected by a component.
	    When it returns false, this is seen as a reject and
	    the program goes into an error state. The user
	    can then stop the program or try to continue
	    the program again, which will lead to a re-issuing
	    of the command, which may lead again to the error state.
	  </para>
	</sect4>
	<sect4>
	  <title>Try ... Catch Commands</title>
	<para>
	  When a command is rejected ( the C++ method returns false ),
	  the program goes into an error state and waits for user
	  intervention. This can be bypassed by using a 
	  <emphasis>try...catch</emphasis> statement. It tries
	  to execute the command, and if it is rejected,
	  the optional catch clause is executed :</para>
	    <programlisting>
  // just try it :
  try comp.action( args )
  
  // When rejected, execute the catch clause :
  try comp.action( args ) catch { 
      // statements...
  } </programlisting>
	  <para>
	    You may place completion conditions between try
	    and catch :
	  </para>
	    <programlisting>
  try comp.action( args ) 
  until {
      if comp.evaluate() then continue
  }
  catch { 
      // statements...
  }
  // next statement </programlisting>
	  <para>
	    If the command was accepted, the next statement is executed.
	  </para>
	</sect4>
	<sect4>
	  <title>Parallel Commands with 'and'</title>
	  <para>
	    When it is desired to execute commands as one command
	    ( in one time ), they can be combined with an
	    'and' operator :</para>
	    <programlisting>
  do comp.action1() and comp.action2() and comp.action3()
	    </programlisting>
	  <para>
	    The implicit completion condition (i.e. 'done') is when all
	    listed actions are done. This can be overridden
	    by defining a completion condition with 'until'.
	  </para>
	  <para>
	    The 'and' operator can also be used with 'try'.
	    In that case, the catch clause will be executed in
	    case any of the listed commands fails.
	  </para>
	</sect4>
      </sect3>
      <sect3>
	<title>Method Call Statements</title>
	<para>
	  Methods behave like traditional functions. They take
	  arguments and return a value immediately. They can be
	  used in expressions or stand alone in a do statement :</para>
	  <programlisting>
  // ignore the return value :
  do comp.method( args )
  
  // this will only work if the method returns a boolean :
  if ( comp.method( args ) ) {
  	    // ...
  }
  
  // use another method in an expression :
  set data = comp.getResult( args ) * 20. / comp.dataValue 
	  </programlisting>
	<para>
	  A method can thus transparantly be used like a
	  command, which implicit completion condition
	  is always true.
	</para>
	<warning>
	  <para>
	    A method returning a boolean result, will
	    behave like a command. This means that if
	    it returns false, it will be seen as a
	    reject. If this is not wanted, use 'try'
	    instead of 'do'. If the method returns
	    nothing or something else than bool, 
	    the result will be ignored in a do
	    statement.
	  </para>
	</warning>
      </sect3>
      <sect3>
	<title>Calling functions</title>
	<para>
	  A function can be called by writing :
	</para>
	  <programlisting>
  do foo(arg)
  call foo(arg) // equivalent to 'do foo(arg)'</programlisting>
	<para>
	  The arguments are passed by value and no return value
	  is possible. If one of the commands of the functions
	  returns error, the calling program goes in error.
	  A function may also be called in a completion 
	  clause. If the function returns, the next statement
	  of the calling function or program is executed.
	</para>
      </sect3>
      <sect3>
	<title>Variable Set Statements</title>
	<para>
	  A variable set statement is a statement that sets a variable
	  to a certain value.  It looks like this:
	  <programlisting>
  set variablename = expression
	  </programlisting>
	  Variablename is the name of the variable you want to assign
	  to.  It should already have been defined.  Expression is an
	  expression of the same type as the type of the variable.
	</para>
      </sect3>
      <sect3>
	<title>The if then else Statement</title>
	<para>	A Program script can contain if..then..else blocks, very similar
	to C syntax.
</para>	  <programlisting>
  if <emphasis>condition</emphasis> then <emphasis>statement</emphasis> 
  [ else <emphasis>statement</emphasis> ]
  // or :
  if <emphasis>condition</emphasis> then {
    <emphasis>statement</emphasis>
    // ...
  } [ else {
    <emphasis>statement</emphasis>
    // ...
  } ]	  </programlisting>
	<para>
	  It is thus possible to group statements. Each statement can
	  be another if clause. An else is always referring to the last
	  if, just like in C/C++. If you like, you can also write
	  parentheses around the condition. The else statement is
	  optional.
	</para>
      </sect3>
      <sect3>
	<title>The for Statement</title>
	<para>
	  The for statement is almost equal to the C language.
	  The first statement initialises a variable or is empty.
	  The condition contains a boolean expression (use 'true'
	  to simulate an empty condition).
	  The second statement changes a variable or is empty.
	  <programlisting>
  for ( <emphasis>statement</emphasis>; <emphasis>condition</emphasis>; <emphasis>statement</emphasis> )
        <emphasis>statement</emphasis>
  // or :
  for ( <emphasis>statement</emphasis>; <emphasis>condition</emphasis>; <emphasis>statement</emphasis> ) {
        <emphasis>statement</emphasis>
        // ...
  }  </programlisting>
	</para>
      </sect3>
      <sect3>
	<title>The while Statement</title>
	<para>
	  The while statement is another looping primitive in 
	  the Orocos script language. A do statement is not
	  ( yet ) implemented</para>
	  <programlisting>
  while <emphasis>condition</emphasis> 
      <emphasis>statement</emphasis>
  // or :
  while <emphasis>condition</emphasis> {
      <emphasis>statement</emphasis>
      // ...
  }  </programlisting>
	<para>
	  As with the if statement, you can optionally put
	  parentheses around the condition.
	</para>
      </sect3>
      <sect3>
	<title>The 'nothing' Command</title>
	<para>
	  A special command 'nothing' is provided, and I'm sure you
	  can already guess what it does..  It is useful to implement
	  statements, where the completion list is really the only
	  useful thing to do.  Control structures can be implemented
	  this way.
	</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>Orocos State Descriptions : The Real-Time State Machine</title>
      <sect2>
	<title>Introduction</title>
	<para>
	  A StateContext is a kind of state machine used in the &orocos;
	  system.  It contains a collection of states, and each state
	  defines what to do on entry of the state, when it is handled
	  and on exit.  It also defines all transitions to a next
	  state.  A StateContext must be loaded in the Processor ( see
	  <ulink url="orocos-program-processor.html"> The Online
	  Processor Manual</ulink> ). The Orocos Control Kernel uses
	  the ExecutionExtension to manage parsing and loading State
	  Contexts.
	</para>
      </sect2>
      <sect2>
	<title>StateContext Workings</title>
	<para>
	  A StateContext is composed of a set of states.  A running
	  StateContext is always in exactly one of its states.  One
	  time per period, it checks whether it can transition from
	  that state to another state, and if so makes that
	  transition.
	</para>
	<para>
	  Every state also has a set of preconditions that need to
	  hold at its entry.  If these don't hold, the StateContext
	  will enter into an error state.
	</para>
	<para>
	  Besides a list of the possible transitions, every state also
	  keeps record of programs to be executed at certain
	  occasions.  There are exactly three programs in every state:
	  the entry program ( which will be executed the first time
	  that the state becomes active ), the handle program ( which
	  will be executed every time the state is the active state )
	  and the exit program ( which will be executed when the state
	  is left and another state is entered ).
	</para>
	<para>
	  There can be more than one StateContext.  If there are more
	  than one, then every StateContext keeps working as if it was
	  the only StateContext available.  They separately keep track
	  of their own current state, etc. 
	</para>
	<para>
	  A StateContext can have any number of states.  It needs to
	  have exactly one "initial state" ( which is the state that
	  will be entered when the StateContext is first started ) and
	  one "final state".  The final state is the state that is
	  entered when the processor is asked to stop the
	  StateContext.  This means that the transition from any state
	  to the final state must always be meaningful.
	</para>
	<sect3>
	  <title>Precise State Change Semantics</title>
	  <para>
	    At the start of every execution cycle of the Program
	    Processor, the transition table of the current state is
	    evaluated.  If a transition succeeds, the exit function is
	    called of the current state, then the entry function of the
	    next state and then the handle function of the latter. If no
	    transition evaluated to true, the handle function of the
	    current state is called.
	  </para>
	</sect3>
      </sect2>
    <sect2>
      <title>Parsing and Loading State Contexts</title>
      <para>
	Analogous to the Program section, we first show how 
	you can load a State Context in your Real-Time Task.
      </para>
      <para>
	Assume that you have a State Context "statename"
	in a file <filename>state-machine.osd</filename>.
	You've read the Orocos Task Infrastructure manual and constructed
	a <classname>TaskContext</classname> which has some methods and is connected to its
	Peer TaskContexts. Parsing the State Context is very analogous
	to parsing Programs:
      </para>
      <programlisting>
  #include &lt;corelib/TaskPreemptible.hpp&gt;
  #include &lt;execution/TaskContext.hpp&gt;
  #include &lt;execution/Parser.hpp&gt;
  #include &lt;iostream&gt;      // std::ifstream
  #include &lt;functional&gt;    // std::for_each
  #include &lt;boost/bind.hpp&gt;// boost::bind

  using namespace ORO_CoreLib;

  TaskContext   tc;
  ORO_CoreLib::TaskPreemptible ptask(0.01, tc->getProcessor() );
  Parser        parser;

  std::vector&lt;ParsedStateContext*&gt; sc_list;
  try {
      sc_list = parser.parseStateContext( std::ifstream("state-machine.osd"), &amp;tc );
  }
  catch( const file_parse_exception&amp; exc )
  {
     std::cerr &lt;&lt; exc.what() &lt;&lt; endl;
  }
  if ( sc_list.empty() )
  {
     // No states were 'instantiated', nothing can be loaded.
  } else {
     // Load all listed programs in the TaskContext's Processor:
     std::for_each( sc_list.begin(), sc_list.end(),
         boost::bind( &amp;Processor::loadStateContext, tc.getProcessor(), _1));

     // start the task :
     ptask->start();

     // activate a state context :
     tc.getProcessor()->activateStateContext("statename");
     // start a state context :
     tc.getProcessor()->startStateContext("statename");
  }</programlisting>
      <para>
	The parser returns a vector of <classname>ParsedStateContext</classname>'s.
	It will throw a <classname>file_parse_exception</classname>
	if a parse error occured.
	If the returned vector is not empty, we load all the StateContexts in the Processor using
	the boost::bind function. Next we start the task's Processor
	and finally. StateContexts have a more complex lifetime than
	Programs. They need first to be activated, upon which they
	enter a fixed initial state. When they are started, state
	transitions to other states can take place.
      </para>
    </sect2>
      <sect2>
	<title>Defining StateContexts</title>
  	<para>
	  You can think of StateContexts somewhat like C++ classes.  You
	  first need to define a type of StateContext, and you can then
	  instantiate it any number of times afterwards.  A StateContext
	  ( the type ) can have parameters, so every instantiation can
	  work differently based on the parameters it got in its
	  instantiation.
	</para>
	<para>
	  A StateContext definition looks like this :
	</para>
	<example>
	  <title>State Context Definition Format</title>
	  <programlisting>
StateContext MyStateContext
{
    initial state myInit 
    {
        entry {
	    // entry method: statements and event configuration
	}
	handle {
	    // handle method: statements
	}
	exit {
	    // exit method: statements and event configuration
	}
	preconditions {
	    // ordered select statements
        }
	transitions {
	    // Ordered (conditional) select statements
	}
    }

    final state myExit {
	entry {
	    // put everything in a safe state.
	}
	handle {
	}
	exit {
        }
	// no transitions in the final state...
    }

    state Waiting {
        // ...
    }

    // ... repeat
}
	  </programlisting>
	  <para>
	    A StateContext definition: a StateContext can have any
	    number of states.  It needs to have exactly one "initial
	    state" ( which is the state that will be entered when the
	    StateContext is first started ).  Within a state, any
	    method is optional, and a state can even be defined empty.
	  </para>
	</example>
	<sect3>
	  <title>The <function>state</function> Statement</title>
	  <para>
	    A state context can have an unlimited number of states.  A
	    state contains optionally 5 functions : preconditions, entry, handle,
	    exit and transitions.  Any one of them is optional, and a
	    state can even conceivably be defined empty.
	  </para>
	</sect3>
	<sect3>
	  <title>The <function>entry</function> and
	    <function>exit</function> Statements</title>
	  <para>
	    When a state is entered for the first time, the entry
	    function is called. When it is left, the exit function is
	    called. They both contain unconditional component commands
	    and event configuration statements. The component commands
	    are the same as in programs. There are two event
	    configuration statements : <function>connect</function>
	    and <function>disconnect</function>. They have the
	    following syntax :
	    <programlisting>
StateContext SomeStateContext
{
    Event_Handle handle_name

    // ...
    state someState
    {
        entry {
	    connect handle_name( "EventName", Component.command( args ) )
	}
        exit {
	    disconnect handle_name
        }
    }
}
	    </programlisting>
	    The event name must correspond to the identifier of a
	    nameserved Event&lt;void(void)&gt;. The command is any valid component
	    command with its arguments. The arguments will be
	    evaluated when the command is called. From that moment on,
	    whenever the event "EventName" is raised (this is done
	    inside the component or kernel implementation), the
	    command will be executed synchronically. The disconnect
	    statement cancels a previously connected handle and may be
	    called at any time on any handle. Each handle must be
	    declared beforehand on top of the state script, before any
	    state is defined.
	  </para>
	</sect3>
	<sect3>
	  <title>The <function>handle</function> and
	    <function>transitions</function> Statement</title>
	  <para>
	    The handle function is called directly after the entry
	    function or when no transition can be found to another state
	    in the next execution step.  The handle function contains
	    only component commands.  To leave a state, the transitions
	    function defines <function>select</function>
	    statements. These can be guarded by if...then clauses :
	    <programlisting>
// In state XYZ :
transitions {
    // conditionally select the START state
    if HMI.startPushed then
	select START
    // Fall through state
    select WAIT
}
	    </programlisting>
	    The transitions are checked in the same order as listed.
	    A transition is allowed to select the current state, but
	    the onExit and onEntry functions will not be called in that
	    case.
	  </para>
	</sect3>
	<sect3>
	  <title>State Preconditions</title>
	  <para>
	    Often it's useful to specify some preconditions that need
	    to hold before entering a state.  &orocos; states
	    explicitly allow for this.  A state's preconditions will
	    be checked before the state is entered.
	  </para>
	  <para>
	    Preconditions are specified as follows:
	    <programlisting>
// In state XYZ
preconditions {
    // make sure the robot is not moving axis 1 when entering this state
    if robot.movingAxis( 1 ) then
        select ERROR_STATE
}
	    </programlisting>
	    As you may have noticed, the syntax for preconditions is
	    the same as for transitions.  It's simply a set of
	    conditional select statements.  The only difference is
	    that preconditions are checked once before entry of the
	    state, whereas transitions are checked every time the
	    state is handled.
	  </para>
	</sect3>
      </sect2>
      <sect2>
	<title>Instantiating Contexts: SubContexts and RootContexts</title>
	<para>
	  As mentionned before: you can look at a SubContext
	  definition as the definition of a C++ class.  It is merely
	  the template for its instantiations, and you have to
	  instantiate it to actually be able to do anything with it.
	  There is also a mechanism for passing parameter values to
	  the StateContexts on instantiation.
	</para>
	<para>
	  Note that you always need to write the instantiation after
	  the definition of the StateContext you're instantiating.
	</para>
	<sect3>
	  <title>Root Contexts</title>
	  <para>
	    A Root Context is a normal instantiation of a
	    StateContext, one that does not depend on a parent
	    StateContext ( see below ).  They are defined as follows:
	    <programlisting>
StateContext SomeStateContext
{
    initial state initState
    {
        // ...
    }
    final state finalState
    {
        // ...
    }
}

RootContext SomeStateContext someSCinst
	    </programlisting>
	    This makes an instantiation of the StateContext type
	    SomeStateContext by the name of 'someSCinst'.
	  </para>
	</sect3>
	<sect3>
	  <title>Parameters and public variables</title>
	  <sect4>
	    <title>StateContext public variables</title>
	    <para>
	      You can define variables at the StateContext level.
	      These variables are then accessible to the StateContext
	      methods (entry, handle, exit), the preconditions, the
	      transitions and ( in the case of a SubContext, see below
	      ) the parent Context.
	    </para>
	    <para>
	      You can define a StateContext public variable as follows:
	      <programlisting>
StateContext SomeStateContext
{
    // a public constant
    const double pi = 3.1415926535897
    var int counter = 0
    alias string errorText = "Error in SomeStateContext: " +
		someComponent.errorStatement()

    initial state initState
    {
	handle
	{
            // change the value of counter...
            set counter = counter + 1
            // use the handy alias defined above...
	    do someComponent.informUserOfError( errorText )
        }
        // ...
    }
    final state finalState
    {
	entry
        {
            do someComponent.doSomethingWithThisCounter( counter )
        }
        // ...
    }
}
	      </programlisting>
	      This example creates some handy public variables in the
	      StateContext SomeStateContext, and uses them throughout
	      the state context.
	    </para>
	  </sect4>
	  <sect4>
	    <title>StateContext parameters</title>
	    <para>
	      A StateContext can have parameters that need to be set
	      on its instantiation.  Here's an example:</para>
	      <programlisting>
  StateContext AxisController
  {
      // a parameter specifying which axis this Controller controls
      param int axisNumber
      initial state init
      {
          entry
          {
              var double power = someComponent.getPowerForAxis( axisNumber )
  	    // do something with it...
          }
      }
  }
  
  RootContext AxisController axiscontroller1( axisNumber = 1 )
  RootContext AxisController axiscontroller2( axisNumber = 2 )
  RootContext AxisController axiscontroller3( axisNumber = 3 )
  RootContext AxisController axiscontroller4( axisNumber = 4 )
  RootContext AxisController axiscontroller5( axisNumber = 5 )
  RootContext AxisController axiscontroller6( axisNumber = 6 )</programlisting>
	    <para>
	      This example creates an AxisController StateContext with
	      one integer parameter called axisNumber.  When the
	      StateContext is instantiated, values for all of the
	      parameters need to be given in the form "oneParamName=
	      'some value', anotherParamName = 0,
	      yetAnotherParamName=some_other_expression + 5".  Values
	      need to be provided for all the parameters of the
	      StateContext. As you see, a StateContext can of course
	      be instantiated multiple times with different parameter
	      values.
	    </para>
	  </sect4>
	</sect3>
	<sect3>
	  <title>SubContexts</title>
	  <para>
	    A SubContext is a StateContext that is instantiated within
	    another StateContext ( which we'll call the parent
	    StateContext ).  The parent StateContext is owner of its
	    child, and can decide when it needs to be started and
	    stopped, by calling the processor's startStateContext and
	    stopStateContext methods.
	  </para>
	  <sect4>
	    <title>Instantiating SubContexts</title>
	    <para>
	      An instantiation of a SubContext is written as follows:
	      <programlisting>
  StateContext ChildStateContext
  {
      initial state initState
      {
          // ...
      }
      final state finalState
      {
          // ...
      }
  }
  
  StateContext ParentStateContext
  {
      SubContext ChildStateContext childcontext1
      SubContext ChildStateContext childcontext2
      initial state initState
      {
  	entry
          {
  	    Execution.startStateContext(childcontext1)
  	    Execution.startStateContext(childcontext2)
          }
          exit
          {
              Execution.stopStateContext(childcontext2)
          }
      }
  
      final state finalState
      {
          entry
          {
              Execution.stopStateContext(childcontext1)
          }
      }
  } </programlisting>
	      Here you see a ParentStateContext which has two
	      ChildStateContexts.  One of them is started in the
	      initial state's entry method and stopped in its exit
	      method.  The other one is started in the initial state's
	      entry method and stopped in the final state's entry
	      method.
	    </para>
	  </sect4>
	  <sect4>
	    <title>SubContext manipulating</title>
	    <para>
	      In addition to starting and stopping a SubContext, a
	      parent StateContext can also inspect its public
	      variables, change its parameters, and check what state
	      it is in...
	    </para>
	    <para>
	      Inspecting StateContext public variables is simply done
	      using the syntax "someSubContextInstName.someValue",
	      just as you would do if someSubContextInstName were an
	      &orocos; kernel component.  Like this, you can inspect
	      all of a subcontext's public variables.
	    </para>
	    <para>
	      Setting a StateContext parameter must be done at its
	      instantiation.  However, you can still change the values
	      of the parameters afterwards.  The syntax is: "set
	      someSubContext.someParam = someExpression".  Here's an
	      elaborate example:</para>
	      <programlisting>
StateContext ChildStateContext
{
    param int someValue
    const double pi = 3.1415926535897
    initial state initState
    {
        // ...
    }
    final state finalState
    {
        // ...
    }
}

StateContext ParentStateContext
{
    SubContext ChildStateContext childcontext1 ( someValue = 0 )
    SubContext ChildStateContext childcontext2( someValue = 0 )

    var int counter = 0
    initial state initState
    {
	entry
        {
	    Execution.startStateContext(childcontext1)
	    Execution.startStateContext(childcontext2)
            // set the subcontext's parameter
            set childcontext1.someValue = 2
        }
        handle
        {
            set counter = counter + 1
	    // set the subcontext's parameters
            set childcontext2.someValue = counter
            // use the subcontext's public variables
            someComponent.doSomethingCool( childcontext1.someValue )
        }
        exit
        {
            Execution.stopStateContext(childcontext2)
        }
    }

    final state finalState
    {
        entry
        {
            Execution.stopStateContext(childcontext1)
        }
    }
}
	      </programlisting>
	    <para>
	      One more thing you can do with a subcontext is checking
	      if it is in a certain state.  The syntax looks like:
	      'someSubContext.inState( "someStateName" )'.  It should
	      be straightforward to use...
	    </para>
	  </sect4>
	</sect3>
      </sect2>
  </sect1>
  <sect1>
    <title>Kernel and Processor Commands</title>
    <para>
      Anything can act as a component towards
      the Parser. When the parser is used
      in the Orocos Control Kernel framework,
      the Kernel and the Processor expose themselves
      as the 'Execution' component. We refer to the control kernel
      documentation for a detailed list of commands,
      but here are a few examples :</para>
      <programlisting>
  do Kernel.selectGenerator( "CartesianGenerator" )
  do Kernel.selectController( "CartesianController" )
  // ...
  do Execution.startProgram( "name" )
  do Execution.stopProgram( "name" )
  // ..
  do Execution.startStateContext( "name" )
  do Execution.stopStateContext( "name" )       </programlisting>
    <para>
      The selectX commands are instructing the kernel
      itself while the start/stopProgram commands
      instruct the processor to start or stop a loaded
      program.
      They can be called from within Programs and States.
    </para>
  </sect1>
  <sect1>
    <title>Program and State Example</title>
    <para>
      This sections shows the listings of an Orocos State
      Description and an Orocos Program Script. They are
      fictitious examples (but with valid syntax) which may
      differ from actual available components. The example
      tries to exploit all available functions.
    </para>
    <example>
      <title>State Context Example (state.osd)</title>
      <programlisting>
  StateContext MachineContext
  {
      Event_Handle home_switch1
      Event_Handle home_switch2
  
      /**
       * This state is entered when the StateContext is loaded.
       * The kernel is not running yet...
       */
      initial state init_state {
  	transitions {
  	    select startup_state
  	}
      }
  
      /**
       * Kernel is running, select the components.
       */
      state startup_state {
  	entry {
  	    do Kernel.selectSensor("HWSensor")
  	    do Kernel.selectGenerator("MoveToGenerator")
  	    }
  	transitions {
  	    select stop_state
  	    }
      }
  
      /**
       * This state is only reached when the State Context
       * is stopped.
       */
      final state fini_state {
  	entry {
  	    do Kernel.selectSensor("Default")
  	    do Kernel.selectGenerator("Default")
  	    }
      }
  
      /**
       * This state is the 'turn off' state of the
       * machine.
       */
      state stop_state {
  	entry {
  	    // The Default Effector and Controller do nothing
  	    do Kernel.selectController("Default")
  	    do Kernel.selectEffector("Default")
  	transitions {
  	    if HMI.start_pushed() then
  		 select run_state
  	    }
      }
  
      /**
       * This state puts the machine under 'control'
       * effectively accepting commands and driving
       * the machine.
       */
      state run_state {
  	entry {
  	    // make sure we are not moving
  	    do MoveToGenerator.safeStop()
  	    // Select components controlling the machine
  	    do Kernel.selectController("PID")
  	    do Kernel.selectEffector("HWEffector")
  	    }
  
  	transitions {
  	    if HMI.stop_pushed() then
  		 select stop_state
  	    if HMI.start_program() then
  		 select exec_state
  	    }
      }
  
      /**
       * This state starts a previously loaded
       * program.
       */
      state exec_state {
  	entry {
  	    do Execution.startProgram("MyProgram")
  	    }
  
  	exit {
  	    do Execution.stopProgram("MyProgram")
  	    }
  
  	transitions {
  	    if HMI.stop_program() then
  		 select run_state
  	    }
      }
  }
  
  RootContext MainContext mainContext
      </programlisting>
    </example>
    <example>
      <title>Program example (program.ops)</title>
      <programlisting>
  /**
   * This program is executed in the exec_state.
   */
  
  /**
   * Request the HMI to load the user selected
   * trajectory into the kernel.
   */
  function HMILoadTrajectory {
  	// request a 'push' of the next
  	// trajectory :
  	do HMI.requestTrajectory
  	// when the HMI is done :
  	do Generator.loadTrajectory
  }
  
  /**
   * Do a Homing (reset) of the axes.
   * This could also be done using a Homing state,
   * without a program.
   */
  function ResetAxes {
  	do Kernel.selectGenerator("HomingGenerator")
  	do HomingGenerator.home()
  }
  
  /**
   * Request the Generator to use the current
   * trajectory.
   */
  function runTrajectory {
  	do Generator.startTrajectory
  	// this function returns when the
  	// trajectory is done.
  }
  
  function ExitProgram {
  	do HMI.display("Program Ended\n")
  	stop
  }

  program DemoRun {
  	do HMI.display("Program Started\n")
  	var int cycle = 0
  
  	// We actually wait here until a 
  	// Trajectory is present in the HMI.
  	do nothing until {
  	   if HMI.trajectoryPresent then continue
  	}
  
  	while HMI.cycle {
  	    do HMI.display("Cycle nr: %d.\n", cycle )
  	    call ResetAxes
  	    call HMIRequestTrajectory
  	    call runTrajectory
  
  	    do HeartBeat.sleep( 5.0 ) // wait 5s
  	}
  
  	call ExitProgram
  }  </programlisting>
    </example>
  </sect1>
  <sect1 id="exporting-component-api">
    <title>The Parser and Orocos ControlKernel</title>
    <para>
      This section explains how the Orocos ControlKernel
      Components can be set up to export their interface
      to the ControlKernel infrastructure. The
      &taskman; gives a more general introduction to
      this topic, while this section is ControlKernel specific.
    </para>
    <sect2 id="exporting-component-api-data-and-commands">
      <title>Data, Methods and Commands</title>
      <para>
	A Component's API can consist of three things: Data, Methods and
	Commands. Data should be accessible without any side effects
	( it is const ), thus many readouts do not influence the data
	or other data, although the data may change because of other reasons.
	Methods can have side effects, but have always immediate result,
	thus they can still be used in expressions.
	Commands are specifically meant to generate side effects
	<emphasis>over time</emphasis>.  Suppose you're
	writing a robot task, then an example of a command would
	be: "robot.moveTo", telling the robot to move to the specified
	position, and an example of a data value would be
	"robot.isAtPosition", checking whether the robot has already
	reached the specified position.  "robot.position" could also
	be a data value. A method could be the setting of the controller
	parameters.
      </para>
      <para>
	An &orocos; program is not executed at the same time it is
	parsed.  It is first parsed, and compiled down to an object
	representation of it, allowing the program to be executed in a
	realtime environment. 
      </para>
      <para>
	Specifically, Commands are represented by child classes of 
	the C++ class CommandInterface, and Data is represented by
	child classes of the C++ class DataSource. A method
	can be both. There
	is a different DataSource type for every type used in the
	&orocos; Parser system.  This is accomplished by making
	DataSource a template class, parametrized by its result
	value.
      </para>
      <para>
	Command calls, methods and data calls are translated to
	CommandInterface and DataSource classes by respectively
	CommandFactory's, MethodFactory's and DataSourceFactory's.
	These are provided
	by the various tasks.  Every task can have one
	CommandFactory, one MethodFactory and one DataSourceFactory.
	Continue reading
	for more information on how to add one to your own components. 
      </para>
    </sect2>
    <sect2 id="exporting-api-the-extension">
      <title>The ExecutionExtension</title>
      <para>
	The part of the kernel that the parser talks to to get hold of
	the API's of the components is the ExecutionExtension.
	It is an &orocos; kernel extension that talks to the kernel
	components and keeps a list of their data and command
	factories.  If you are composing an &orocos; kernel, then you
	need to make the ExecutionExtension part of the kernel
	in the normal way.  Check the control kernel documentation for
	more details.
      </para>
    </sect2>
    <sect2 id="exporting-api-getting-to-it">
      <title>Getting to it</title>
      <para>
	In order for a component to export its API, it can
	implement three virtual methods: 
	<programlisting>
virtual CommandFactoryInterface* createCommandFactory();
virtual MethodFactoryInterface* createMethodFactory();
virtual DataSourceFactoryInterface* createDataSourceFactory();
	</programlisting>
	These will each be called once during the startup of the
	kernel, and they should return a CommandFactory, a MethodFactory and a
	DataSourceFactory containing information on how to construct
	the Command's, Method's and DataSource's that the component supports.
      </para>
      <para>
	It is possible to write the DataSourceFactory and
	CommandFactory for your component yourself, but this would
	require a pretty large amount of work consisting mostly of
	boilerplate code.  Therefore, standard factories have been
	written to take care of most of the process.
      </para>
      <para>
	Suppose the API of your component looks like this:
	<programlisting>
class Robot
{
public:
  void moveToHomePosition();
  // A Completion condition must be const :
  bool isAtHomePosition() const;
  
  void moveTo( const Vector&amp; position );
  bool isAtPosition( const Vector&amp; position ) const;
  
  // A DataSource must be const :
  Vector position() const;
  double movingSpeed() const;
  
  // A Method must not be const :
  double calibrate( const Vector&amp; position );
};
	</programlisting>
	Then the code needed to export this API to the &orocos;
	scripting framework would look like this:
	<programlisting>
#include &lt;execution/Factories.hpp&gt;

using namespace ORO_CoreLib;
using namespace ORO_Execution;

class Robot
{
public:
// ...

DataSourceFactoryInterface* createDataSourceFactory()
{
  TemplateDataSourceFactory&lt;Robot&gt;* ret =
    newDataSourceFactory( this );
  ret-&gt;add( &quot;position&quot;, 
            data( &amp;Robot::position, &quot;The current position &quot;
                                    &quot;of the robot.&quot; ) );
  ret-&gt;add( &quot;movingSpeed&quot;,
            data( &amp;Robot::movingSpeed, 
                  &quot;The speed at which the robot is &quot;
                  &quot;currently moving.&quot; ) );
  return ret;
}

MethodFactoryInterface* createMethodFactory()
{
  TemplateMethodFactory&lt;Robot&gt;* ret =
    newMethodFactory( this );
  ret-&gt;add( &quot;calibrate&quot;,
            method( &amp;Robot::calibrate,
                  &quot;Calibrate the distance between the current &quot;
                  &quot;position of the robot and pos.&quot;, &quot;pos&quot;,
                  &quot;Calibration position&quot; ) ); 
  return ret;
}

CommandFactoryInterface* createCommandFactory()
{
  TemplateCommandFactory&lt;Robot&gt;* ret =
    newCommandFactory( this );
  ret-&gt;add( &quot;moveToHomePosition&quot;, 
            command( &amp;Robot::moveToHomePosition,
                     &amp;Robot::isAtHomePosition,
                     &quot;Move the robot to its home position&quot; ) );
  ret-&gt;add( &quot;moveTo&quot;,
            command( &amp;Robot::moveTo,
                     &amp;Robot::isAtPosition,
                     &quot;Move the Robot to a specified position.&quot;, &quot;pos&quot;,
                     &quot;The position to move the robot to.&quot; ) );
  return ret;
}

// ...
};
	</programlisting>
	This probably deserves some explanation...
      </para>
      <para>
	The first statement 
	<programlisting>
TemplateDataSourceFactory&lt;Robot&gt;* ret =
  newDataSourceFactory( this );
	</programlisting>
	constructs a new TemplateDataSourceFactory, this should be
	straightforward.  After this factory is constructed, we add
	data to it using the add() method.  This method requires a
	name for the added data, and information on the data to be
	associated with that name.  The latter is generated using the
	function data().
      </para>
      <para>
	The data function requires a pointer to a
	<emphasis>const</emphasis> member function having a number of
	arguments, and returning the appropriate data.  The function's
	signature will automatically define the signature in the
	exported API.  After the member function pointer follows a C
	string containing a description of the function, followed by a
	name and description for each of the arguments.  An extra
	feature is that instead of a pointer to a member function, you
	can also pass a pointer to a member variable to the data
	function.  This will then simply be read out, instead of
	called.
      </para>
      <para>
	Methods work the same way like DataSources, except that
	they do not need to be const and the factories have
	different names.
      </para>
      <para>
	The command factory is created in a similar way.  The first
	statement is almost the same, and the next are also similar.
	The only difference with the DataSource factory creation is
	that in place of the data function, the command function is
	used, which requires some different arguments.
      </para>
      <para>
	The command function requires two member pointers instead of
	one.  The first one is a function that does the actual work
	that the command will invoke, and the second is a bool
	<emphasis>const </emphasis>function having the same arguments
	as the first one, the first argument or no arguments at all.
	This last function will be called to see whether the
	associated command is finished.  The rest of the arguments to
	the command function remain the same.  It also requires a
	constant C string describing the function, and two constant C
	strings giving a description and name for every argument.
      </para>
      <para>
	If a component has only commands, or only data, or only methods, the unneeded
	factory function can be left out and the parser will not query
	the component for the left out factory.
      </para>
    </sect2>
  </sect1>
      
  <sect1 id="extending-the-parser">
    <title>Extending the parser</title>
    <sect2 id="parser-limitations">
      <title>Parser Limitations</title>
      <para>
	For various reasons, during the development of the &orocos;
	parser, it has proven necessary to hard-code various things,
	mostly relating to the defined types, and the operations
	supported on them.  The parser supports using different types
	of objects than the predefined ones, but the major limitations
	are:
	<itemizedlist>
	  <listitem>
	    <para>
	      It does not know of <type>unsigned int</type>. It can not call
	      component methods with <type>unsigned int</type> arguments.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Only a hardcoded set of types can be used as variables,
	      constants and aliases.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      Operators like +, *, >= etc. are only supported for a
	      hardcoded set of types.
	    </para>
	  </listitem>
	  <listitem>
	    <para>
	      For some types like vectors, rotations and frames,
	      special syntax was added.  Currently, this is limited to
	      the so-called constructors, that allow you to construct
	      e.g. a vector from three doubles.
	    </para>
	  </listitem>
	</itemizedlist>
      </para>
    </sect2>
    <sect2 id="alleviating-parser-limitations">
      <title>Alleviating the Limitations</title>
      <para>
	We will address the ways to address the various limitations in
	the same order as they were given above..
      </para>
      <sect3 id="adding-types">
	<title>Adding value types</title>
	<para>
	  Adding types that can be used as variables, constants or
	  aliases should be very trivial.  It should suffise to simply
	  add a single line to a single file.
	</para>
	<para>
	  The value types supported are kept in the TypesRepository
	  class in orocos-tree/parser/src/Types.hpp.  The list of
	  value types is constructed in the TypesRepository
	  constructor in the Types.cpp file.  It looks something like
	  the following:
	  <programlisting>
data[&quot;int&quot;] = new TemplateTypeInfo&lt;int&gt;();
data[&quot;string&quot;] = new TemplateTypeInfo&lt;std::string&gt;();
data[&quot;double&quot;] = new TemplateTypeInfo&lt;double&gt;();
data[&quot;bool&quot;] = new TemplateTypeInfo&lt;bool&gt;();
	  </programlisting>
	  Adding your own type comes down to just adding a similar
	  line there.  There are however some restrictions on what
	  types can be used (like having a proper, publically
	  accessible copy constructor, e.g. ), but if you have
	  properly designed your class as a normal C++ value-based
	  class, then there should be no problem.
	</para>
      </sect3>
      <sect3 id="overloading-operators">
	<title>Overloading operators</title>
	<para>
	  Operator overloads are stored in the class OperatorRegistry
	  in orocos-tree/parser/src/Operators.hpp.  The list of
	  supported operators is built up in the OperatorRegistry
	  constructor in the Operators.cpp file.  It looks something
	  like this:
	  <programlisting>
// boolean stuff:
add( newUnaryOperator( &quot;!&quot;, std::logical_not&lt;bool&gt;() ) );
add( newBinaryOperator( &quot;&amp;&amp;&quot;, std::logical_and&lt;bool&gt;() ) );
add( newBinaryOperator( &quot;||&quot;, std::logical_or&lt;bool&gt;() ) );
add( newBinaryOperator( &quot;==&quot;, std::equal_to&lt;bool&gt;() ) );
add( newBinaryOperator( &quot;!=&quot;, std::not_equal_to&lt;bool&gt;() ) );
	  </programlisting>
	  Adding your own should not be terribly hard.  The hardest
	  part is that as the second argument to newUnaryOperator,
	  newBinaryOperator or newTernaryOperator, you need to specify
	  a STL Adaptable Functor, and even though the STL provides
	  many predefined one's, it does not provide all possible
	  combinations, and you might end up having to write your
	  own..  The STL does not at all provide any "ternary
	  operators", so if you need one of those, you'll definitely
	  have to write it yourself.
	</para>
	<para>
	  Note that this section is only about adding overloads for
	  existing operators, if you want to add new operators, you
	  should look at the <link linkend="adding-syntax">next
	  section</link>.
	</para>
      </sect3>
      <sect3 id="adding-syntax">
	<title>Adding special syntax</title>
	<para>
	  This section will explain how to add a custom constructor,
	  or a custom operator, that you will then be able to use in
	  expressions..  The operator can take one to three arguments
	  of any type, and can return any type..
	</para>
	<para>
	  You need to do two things in order to do this: 
	  <itemizedlist>
	    <listitem>
	      <para>make the parser know about the new syntax</para>
	    </listitem>
	    <listitem>
	      <para>tell the parser what the new syntax means</para>
	    </listitem>
	  </itemizedlist>
	</para>
	<para>
	  You should make the parser aware of the new syntax in the
	  file execution/program-parser/src/ExpressionParser.cxx.  There, in
	  the ExpressionParser constructor, the syntax of an
	  expression is defined.  There, you should add the new
	  syntax.  I'm afraid I can't explain you other than either
	  copying from an existing syntax or reading the Boost.spirit
	  documentation.  You need to couple your new syntax with a
	  semantic action like &quot;bind(
	  &amp;ExpressionParser::seen_binary, this, &quot;%&quot; )
	  for a binary action that you want to give the name "%".  The
	  name &quot;%&quot; is just an identifier that should be
	  unique to your new operator, it can be any string you want.
	</para>
	<para>
	  Next, you need to define the operator in Operators.cpp, in
	  much the same way as you should do for <link
	  linkend="overloading-operators">overloading an existing
	  operator</link>.  However, instead of then using an existing string
	  like "+", you should use the string you chose while defining
	  your new syntax above.
	</para>
      </sect3>
    </sect2>
  </sect1>
</article>
