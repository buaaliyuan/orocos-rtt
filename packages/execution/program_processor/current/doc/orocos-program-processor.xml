<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY interf  "<acronym>Program Processor</acronym>">
]
>

<book>
  <bookinfo>
  <title>The Orocos Program Processor Manual</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002, 2003, 2004</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

  <abstract>
      <para>
	This document explains the design and implementation of the
	Program Processor.
      </para>
    </abstract>

  <revhistory>
  <revision>
    <revnumber>0.9</revnumber>
    <date>14 Nov 2002</date>
    <authorinitials>ps</authorinitials>
    <revremark>Updated for release</revremark>
  </revision>
  <revision>
    <revnumber>0.11</revnumber>
    <date>31 Okt 2003</date>
    <authorinitials>ps</authorinitials>
    <revremark>Adapted documentation to comply with 0.11 release</revremark>
  </revision>
  <revision>
    <revnumber>0.12</revnumber>
    <date>19 Jan 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Programs are Boost::Graphs now.</revremark>
  </revision>
  <revision>
    <revnumber>0.13</revnumber>
    <date>2 Feb 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>States workings updated</revremark>
  </revision>
  <revision>
    <revnumber>0.14</revnumber>
    <date>31 March 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>New Program and StateContext implementation</revremark>
  </revision>
  <revision>
    <revnumber>0.16</revnumber>
    <date>06 July 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Added CommandFunctor docs</revremark>
  </revision>
  </revhistory>

  <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>
  

  
  <chapter>
    <title>Introduction</title>
    <para>
      This chapter explains installation, and gives an overview of the
features and interface of the &orocos; &interf; package.
    </para>
    <sect1>
      <title>What is Orocos Execution : Program Processor ?</title>
      <para>
	&orocos; is meant for building realtime systems. You will find
	all necessary components in other &orocos; packages to build
	them, but they would only act as a noninteractive whole. The
	Execution package allows a user to configure a system and execute
	user-defined programs on that system. A
	<classname>StateContext</classname> will hold the
	user-programmable state machine (representing the system
	logic). A <classname>ProgramGraph</classname> will hold the
	user-defined program to be executed. A
	<classname>Processor</classname> will then represent an
	execution engine which loads the sytem configuration and
	program definition and executes that program. While a big part
	of &interf; will run close to the realtime system, loading
	will be a non-realtime operation, since it performs dynamic
	memory allocations. Execution will happen in real time.
      </para>
      <para>
	The Program Processor is not what the user will use directly.
	The user will mainly use the <ulink url="orocos-program-parser.html">
	  Orocos Program Parser</ulink>. The Parser
	generates ProgramGraphs and StateGraphs from user friendly
	text files, which can then be executed in realtime.
      </para>
    </sect1>

    <sect1>
      <title>Installation</title>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
      <para>
      Further information can be found in the &orocos; installation documentation.
      </para>
    </sect1>
</chapter>

  <chapter>
    <title>Processing Programs and StateContexts</title>
      <sect1>
	<title>Processor</title>
	<para>
	  The <classname>Processor</classname> is the core component
	  of &interf;. It represents an execution engine which is
	  capable of loading a system configuration and loading and
	  executing programs on that configured system. A system
	  configuration (or part of) is defined in a State Context
	  ( a State Context is a collection of Orocos States ).
	  Multiple State Contexts can be loaded and started/stopped in
	  parallel. A Program is a sequence of commands, connected
	  to each other through condition evaluation. Also programs
	  can be loaded and run in parallell.
	</para>
	<para>
	  The Processor is commanded to do things with Programs
	  and State Contexts. The available commands are presented
	  in the figures in the next sections.
	</para>
      </sect1>
      <sect1>
	<title>State Context and State</title>
	<para>
	  The <classname>StateContext</classname> is a collection
	  of states, linked to each other and is defined in
	  the <ulink url="orocos-corelib.html">Orocos CoreLib</ulink>
	  . It represents a  state machine of the
	  system logic. Every device has physical and logical
	  configurations in which a specific action must be taken
	  (on entry, during or on exit) and transitions between states are defined
	  by boundary conditions. Every such state is defined by
	  the <classname>StateInterface</classname> in the CoreLib
	  API. A state itself is defined by three methods : 
	  onEntry(), handle() and onExit(). They are called by
	  the Processor when this state is entered, handled or 
	  left. There is always exactly one handle called 
	  in each execution step, also when a state transition
	  takes place. In that case, first the onExit() method
	  of the old state is called, then the onEntry() method
	  of the new state and as last in that step, the handle()
	  method.
	</para>
	<para>To see how a state can be entered in Orocos, we refer
	  to the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	  convert Orocos State Descriptions to a State Context
	  wich can be loaded in the Processor.
	</para>
	<figure><title>Using a StateContext</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="ContextStates.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="ContextStates.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect1>
      <sect1>
	<title>State Transitions</title>
	<para>
	  State Transitions are the edges of the state diagram. They
	  define a condition on which a new state is entered. The
	  processor expects an instance of
	  <classname>ConditionInterface</classname> which encapsulates
	  the logic (see also in CoreLib and below). Transitions
	  can be ordered by priority, so that it is defined in which
	  order they are checked. A multiple of
	  conditions can lead to the same state.
	</para>
      </sect1>
      <sect1>
	<title>A Program</title>
	<para>
	  A Program is defined by the ProgramInterface. A Program
	  implementation also provides an interface to build a program.
	</para>
	<para>
	  The <classname>ProgramGraph</classname> is a tree composed
	  of command nodes.  A Program keeps track of the start node
	  and the node to be executed next. As such a program can be
	  executed in steps, and reset to the beginning. The
	  ProgramGraph has a builder interface for constructing
	  programs, which is used by other packages to construct valid
	  programs.
	</para>
	<para>
	  Programs are generated from a script, this is explained in 
	  the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	  convert Orocos Program Scripts to a Program which can
	  be loaded in the Processor.
	</para>
	<figure><title>Using a Program</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="ProgramStates.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="ProgramStates.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect1>

      <sect1>
	<title>The Command Node</title>
	<para>
	  The <classname>CommandNode</classname> contains a
	  <classname>Command</classname> and is connected by edges of
	  the type <classname>ConditionEdge</classname>, these edges
	  are connect one node with another and allow the transition
	  if the contained condition evaluates to true. When a program
	  is executed, it executes the command and runs through the
	  list of edges, checking until a <classname>
	    Condition</classname> is found valid and the next program
	  node to be executed is thus found. If no condition is
	  fulfilled, the same command node will be executed again.
	  Also a line number can be associated with each command node,
	  as a reference to the input file formatted by the user.
	</para>
      </sect1>
      <sect1>
	<title>The Command class</title>
	<para>
	  The <classname>Command</classname> is the abstraction of a
	  user directive that has to be executed. A Command can be
	  execute()'ed and reset()'ed. For each action exists one
	  Command, but a Command can be composed of other Commands.
	  The basic interface, CommandInterface, is provided by the
	  Orocos CoreLib.
	</para>
      </sect1>
      <sect1>
	<title>The Condition class</title>
	<para>
	  The <classname>Condition</classname> is the abstraction of a
	  user expression that has to be evaluated. A Condition can be
	  evaluated()'ed and reset()'ed. Many primitive expressions
	  can be evaluated and a Condition can be composed of other
	  Conditions. The basic interface, ConditionInterface, is
	  provided by the Orocos CoreLib
	</para>
      </sect1>
  </chapter>
  <chapter>
    <title>Using Commands</title>
    <para>
      Apart from the Program and State Context Commands, the application
      can generate commands for the Processor to execute. This is usefull
      if a function must be called at a later moment.
    </para>
    <sect1>
      <title>Generic Functors</title>
      <para>
	Orocos uses the 'Generic Functor' paradigm to encapsulate Commands.
	This means that an object (the functor) is created which holds a
	pointer to the function to be executed. If this function needs
	arguments, these are also stored in the functor. The object
	can then be passed around until another object decides to execute
	the functor. Execution of a functor leads to the original function
	to be called, together with the arguments.
      </para>
	<figure><title>A Generic Functor</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="Functor.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="Functor.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
    </sect1>
    <sect1>
      <title>Creating a CommandFunctor</title>
      <para>
	The CommandFunctor is the object used to store the function
	pointer in. It implements the CommandInterface such that
	it can be execute()'ed by the Processor :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  void foo();

  CommandInterface* command = newCommandFunctor( &amp;foo );

  command->execute(); // calls foo()

  delete command;
	</programlisting>
	notice that we use a factory-function <function>newCommandFunctor</function>
	in order to avoid providing a template parameter.
      </para>
      <para>
	It is possible to wrap more complex functions in a CommandFunctor,
	if the boost::bind library is used :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  #include &lt;boost/bind.hpp&gt;
  
  void foo( int x, int y );

  CommandInterface* command = newCommandFunctor( boost::bind( &amp;foo, 1, 2 ) );

  command->execute(); // calls foo(1,2)

  delete command;
	</programlisting>
	Argument 'binding' is a very powerfull feature of C++. It allows to 
	provide the arguments of a function in advance and execute the function
	lateron.
      </para>
      <para>
	It is also possible to call the memberfunction of an object. In that
	case, the first parameter of the function becomes the pointer to the
	object, followed by the arguments of the function :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  #include &lt;boost/bind.hpp&gt;
  
  class X {
  public:
    void foo( int x, int y );
  };

  X x_object;
  CommandInterface* command = newCommandFunctor( boost::bind( &amp;X::foo, x_object, 1, 2 ) );

  command->execute(); // calls x_object.foo(1,2)

  delete command;
	</programlisting>
	notice that the foo function is now prefixed by the class scope 'X::'.
      </para>
      <para>
	The CommandFunctor allows us to bind a function to a CommandInterface.
	Since the Program Processor can execute CommandInterface objects,
	it is a powerfull way to delay calling of a function to a later moment.
      </para>
    </sect1>
    <sect1>
      <title>Processing a Command</title>
      <para>
	Using the CommandFunctor from the previous section, we can pass
	the command to the processor :
	<programlisting>
  CommandInterface* command = ...
  Processor* proc = ...

  bool result = proc->process( command );
	</programlisting>
	If result is true, the command was accepted, if false, the command
	fifo is full and a new process attempt must be made. The Processor
	can be easily extended to have better queueing semantics.
      </para>
      <para>
	Another thread instructs the processor to execute all queued commands
	(and programs) synchronically calling the
	<programlisting>
  proc->doStep();
	</programlisting>
	function. This must happend periodically to empty the command
	queue and advance the program execution.
      </para>
    </sect1>
    <sect1>
      <title>Common Usage Examples</title>
      <para>
	The CommandFunctor can be used when a separate thread of
	execution wants to execute a function in the Processor thread.
	In Orocos, this happens when an external commando must be
	processed by the realtime control kernel. In one thread,
	the CommandFunctor is created (which contains the function
	to be called) and is passed to the Processor of the
	ExecutionExtension, which is part of the control kernel.
	The control kernel thread executes all queued
	commands in the Processor after the control calculations
	are done. In this way, safe data access can be guaranteed.
      </para>
    </sect1>
  </chapter>
</book>
