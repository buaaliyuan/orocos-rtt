<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY interf  "<acronym>Program Processor</acronym>">
]
>

<book>
  <bookinfo>
  <title>The Orocos Program Processor Manual</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002, 2003, 2004</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

  <abstract>
      <para>
	This document explains the design and implementation of the
	Program Processor.
      </para>
    </abstract>

  <revhistory>
  <revision>
    <revnumber>0.9</revnumber>
    <date>14 Nov 2002</date>
    <authorinitials>ps</authorinitials>
    <revremark>Updated for release</revremark>
  </revision>
  <revision>
    <revnumber>0.11</revnumber>
    <date>31 Okt 2003</date>
    <authorinitials>ps</authorinitials>
    <revremark>Adapted documentation to comply with 0.11 release</revremark>
  </revision>
  <revision>
    <revnumber>0.12</revnumber>
    <date>19 Jan 2003</date>
    <authorinitials>ps</authorinitials>
    <revremark>Programs are Boost::Graphs now.</revremark>
  </revision>
  </revhistory>

  <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>


  
  <chapter>
    <title>Introduction</title>
    <para>
      This chapter explains installation, and gives an overview of the
features and interface of the &orocos; &interf; package.
    </para>


    <sect1>
      <title>What is Orocos Execution : Program Processor ?</title>
      <para>
	&orocos; is meant for building realtime systems. You will find
	all necessary components in other &orocos; packages to build
	them, but they would only act as a noninteractive whole. The
	Interfacing allows a user to configure a system and execute
	user-defined programs on that system. A
	<classname>SystemContext</classname> will hold the
	user-programmable state machine (representing the system
	logic). A <classname>ProgramGraph</classname> will hold the
	user-defined data to be executed. A
	<classname>Processor</classname> will then represent an
	execution engine which loads the sytem configuration and
	program definition and executes that program. While a big part
	of &interf; will run close to the realtime system, loading
	will be a non-realtime operation, since it performs dynamic
	memory allocations. Execution will happen in real time.
      </para>
      <para>
	The Program Processor is not what the user will use directly.
	The user will mainly use the Program Parser. The Parser
	generates ProgramGraphs which can then be executed in
	realtime.
      </para>
    </sect1>

    <sect1>
      <title>Installation</title>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
      <para>
      Further information can be found in the &orocos; installation documentation.
      </para>
    </sect1>
</chapter>

  <chapter><title>Short Introduction</title>
    <sect1>
      <title>Main Components</title>
      <para>
	This section gives an overview of the services used for
	&interf;.
      </para>
      <note>
	<para>	We refer to the source code documentation or the
	doxygen generated files for the	most recent
	documentation about which functions exist and do what. 
	</para>
      </note>
      <sect2>
	<title>Processor</title>
	<para>
	  The <classname>Processor</classname> is the core component
	  of &interf;. It represents an execution engine which is
	  capable of loading a system configuration and loading and
	  executing programs on that configured system.  Thus the
	  Processor is always associated with 3 variables, namely the
	  state of the system, the data to be executed and its own
	  state. The Processor is at all times in one of the following
	  <classname>ProcessorStates</classname>: initialisation
	  state, system configuration state, load program state and
	  execution state.
	</para>
	<figure><title>States of the Program Processor</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="PPstates.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="PPstates.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect2>

      <sect2>
	<title>System Context</title>
	<para>
	  The <classname>System Context</classname> is the gateway to
	  the configuration of the state machine representing the
	  system logic. A user can define possible system states,
	  state rules and state transitions which will be translated
	  by the parser into a valid system configuration. Each
	  <classname>SystemState</classname> can be configured with a
	  set of rules. A <classname>Rule</classname> is an if-then
	  clause (Condition-Command), when the condition is violated,
	  the corresponding command will be executed. A difference has
	  been made between strong rules and weak rules.  When a
	  strong rule is violated, the only concern is to execute its
	  command as soon as possible and abort the rest of the rules.
	  Weak rules on the other hand, are checked sequentially, have
	  their commands executed (if any) and don't cause a state
	  change.
	</para>
      </sect2>

      <sect2>
	<title>A Program</title>
	<para>
	  A Program is defined by the ProgramInterface. A Program
	  implementation also provides an interface to build a program.
	</para>
	<para>
	  The <classname>ProgramGraph</classname> is a tree composed
	  of command nodes.  A Program keeps track of the start node
	  and the node to be executed next. As such a program can be
	  executed in steps, and reset to the beginning. The
	  ProgramGraph has a builder interface for constructing
	  programs, which is used by other packages to construct valid
	  programs.
	</para>
      </sect2>

      <sect2>
	<title>The Command Node</title>
	<para>
	  The <classname>CommandNode</classname> contains a
	  <classname>Command</classname> and is connected by edges of
	  the type <classname>ConditionEdge</classname>, these edges
	  are connect one node with another and allow the transition
	  if the contained condition evaluates to true. When a program
	  is executed, it executes the command and runs through the
	  list of edges, checking until a <classname>
	    Condition</classname> is found valid and the next program
	  node to be executed is thus found. If no condition is
	  fulfilled, the same command node will be executed again.
	  Also a line number can be associated with each command node,
	  as a reference to the input file formatted by the user.
	</para>
      </sect2>
      <sect2>
	<title>The Command class</title>
	<para>
	  The <classname>Command</classname> is the abstraction of a
	  user directive that has to be executed. A Command can be
	  execute()'ed and reset()'ed. For each action exists one
	  Command, but a Command can be composed of other Commands.
	  The basic interface, CommandInterface, is provided by the
	  Orocos CoreLib.
	</para>
      </sect2>
      <sect2>
	<title>The Condition class</title>
	<para>
	  The <classname>Condition</classname> is the abstraction of a
	  user expression that has to be evaluated. A Condition can be
	  evaluated()'ed and reset()'ed. Many primitive expressions
	  can be evaluated and a Condition can be composed of other
	  Conditions. The basic interface, ConditionInterface, is
	  provided by the Orocos CoreLib
	</para>
      </sect2>
    </sect1>
  </chapter>

</book>
