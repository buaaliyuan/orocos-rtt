<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY interf  "<acronym>Program Processor</acronym>">
]
>

<book>
  <bookinfo>
  <title>The Orocos Program Processor Manual</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002, 2003, 2004</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

  <abstract>
      <para>
	This document explains the design and implementation of the
	Program Processor.
      </para>
    </abstract>

  <revhistory>
  <revision>
    <revnumber>0.9</revnumber>
    <date>14 Nov 2002</date>
    <authorinitials>ps</authorinitials>
    <revremark>Updated for release</revremark>
  </revision>
  <revision>
    <revnumber>0.11</revnumber>
    <date>31 Okt 2003</date>
    <authorinitials>ps</authorinitials>
    <revremark>Adapted documentation to comply with 0.11 release</revremark>
  </revision>
  <revision>
    <revnumber>0.12</revnumber>
    <date>19 Jan 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Programs are Boost::Graphs now.</revremark>
  </revision>
  <revision>
    <revnumber>0.13</revnumber>
    <date>2 Feb 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>States workings updated</revremark>
  </revision>
  <revision>
    <revnumber>0.14</revnumber>
    <date>31 March 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>New Program and StateContext implementation</revremark>
  </revision>
  </revhistory>

  <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>


  
  <chapter>
    <title>Introduction</title>
    <para>
      This chapter explains installation, and gives an overview of the
features and interface of the &orocos; &interf; package.
    </para>
    <sect1>
      <title>What is Orocos Execution : Program Processor ?</title>
      <para>
	&orocos; is meant for building realtime systems. You will find
	all necessary components in other &orocos; packages to build
	them, but they would only act as a noninteractive whole. The
	Execution package allows a user to configure a system and execute
	user-defined programs on that system. A
	<classname>StateContext</classname> will hold the
	user-programmable state machine (representing the system
	logic). A <classname>ProgramGraph</classname> will hold the
	user-defined program to be executed. A
	<classname>Processor</classname> will then represent an
	execution engine which loads the sytem configuration and
	program definition and executes that program. While a big part
	of &interf; will run close to the realtime system, loading
	will be a non-realtime operation, since it performs dynamic
	memory allocations. Execution will happen in real time.
      </para>
      <para>
	The Program Processor is not what the user will use directly.
	The user will mainly use the <ulink url="orocos-program-parser.html">
	  Orocos Program Parser</ulink>. The Parser
	generates ProgramGraphs and StateGraphs from user friendly
	text files, which can then be executed in realtime.
      </para>
    </sect1>

    <sect1>
      <title>Installation</title>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
      <para>
      Further information can be found in the &orocos; installation documentation.
      </para>
    </sect1>
</chapter>

  <chapter>
    <title>Processing Programs and StateContexts</title>
    <sect1>
      <title>Main Components</title>
      <para>
	This section gives an overview of the services used for
	&interf;.
      </para>
      <sect2>
	<title>Processor</title>
	<para>
	  The <classname>Processor</classname> is the core component
	  of &interf;. It represents an execution engine which is
	  capable of loading a system configuration and loading and
	  executing programs on that configured system. A system
	  configuration (or part of) is defined in a State Context
	  ( a State Context is a collection of Orocos States ).
	  Multiple State Contexts can be loaded and started/stopped in
	  parallel. A Program is a sequence of commands, connected
	  to each other through condition evaluation. Also programs
	  can be loaded and run in parallell.
	</para>
	<para>
	  The Processor is commanded to do things with Programs
	  and State Contexts. The available commands are presented
	  in the figures in the next sections.
	</para>
      </sect2>
      <sect2>
	<title>State Context and State</title>
	<para>
	  The <classname>StateContext</classname> is a collection
	  of states, linked to each other and is defined in
	  the <ulink url="orocos-corelib.html">Orocos CoreLib</ulink>
	  . It represents a  state machine of the
	  system logic. Every device has physical and logical
	  configurations in which a specific action must be taken
	  (on entry, during or on exit) and transitions between states are defined
	  by boundary conditions. Every such state is defined by
	  the <classname>StateInterface</classname> in the CoreLib
	  API. A state itself is defined by three methods : 
	  onEntry(), handle() and onExit(). They are called by
	  the Processor when this state is entered, handled or 
	  left. There is always exactly one handle called 
	  in each execution step, also when a state transition
	  takes place. In that case, first the onExit() method
	  of the old state is called, then the onEntry() method
	  of the new state and as last in that step, the handle()
	  method.
	</para>
	<para>To see how a state can be entered in Orocos, we refer
	  to the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	  convert Orocos State Descriptions to a State Context
	  wich can be loaded in the Processor.
	</para>
	<figure><title>Using a StateContext</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="ContextStates.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="ContextStates.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect2>
      <sect2>
	<title>State Transitions</title>
	<para>
	  State Transitions are the edges of the state diagram. They
	  define a condition on which a new state is entered. The
	  processor expects an instance of
	  <classname>ConditionInterface</classname> which encapsulates
	  the logic (see also in CoreLib and below). When multiple
	  conditions are true, an arbitrary one will be choosen to
	  make the transition to the next state. A multiple of
	  conditions can lead to the same state.
	</para>
      </sect2>
      <sect2>
	<title>A Program</title>
	<para>
	  A Program is defined by the ProgramInterface. A Program
	  implementation also provides an interface to build a program.
	</para>
	<para>
	  The <classname>ProgramGraph</classname> is a tree composed
	  of command nodes.  A Program keeps track of the start node
	  and the node to be executed next. As such a program can be
	  executed in steps, and reset to the beginning. The
	  ProgramGraph has a builder interface for constructing
	  programs, which is used by other packages to construct valid
	  programs.
	</para>
	<para>
	  Programs are generated from a script, this is explained in 
	  the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	  convert Orocos Program Scripts to a Program which can
	  be loaded in the Processor.
	</para>
	<figure><title>Using a Program</title>
	  <mediaobject>
	    <imageobject role="html">
	      <imagedata fileref="ProgramStates.png" format="PNG"/>
	    </imageobject>
	    <imageobject role="fo">
	      <imagedata fileref="ProgramStates.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </sect2>

      <sect2>
	<title>The Command Node</title>
	<para>
	  The <classname>CommandNode</classname> contains a
	  <classname>Command</classname> and is connected by edges of
	  the type <classname>ConditionEdge</classname>, these edges
	  are connect one node with another and allow the transition
	  if the contained condition evaluates to true. When a program
	  is executed, it executes the command and runs through the
	  list of edges, checking until a <classname>
	    Condition</classname> is found valid and the next program
	  node to be executed is thus found. If no condition is
	  fulfilled, the same command node will be executed again.
	  Also a line number can be associated with each command node,
	  as a reference to the input file formatted by the user.
	</para>
      </sect2>
      <sect2>
	<title>The Command class</title>
	<para>
	  The <classname>Command</classname> is the abstraction of a
	  user directive that has to be executed. A Command can be
	  execute()'ed and reset()'ed. For each action exists one
	  Command, but a Command can be composed of other Commands.
	  The basic interface, CommandInterface, is provided by the
	  Orocos CoreLib.
	</para>
      </sect2>
      <sect2>
	<title>The Condition class</title>
	<para>
	  The <classname>Condition</classname> is the abstraction of a
	  user expression that has to be evaluated. A Condition can be
	  evaluated()'ed and reset()'ed. Many primitive expressions
	  can be evaluated and a Condition can be composed of other
	  Conditions. The basic interface, ConditionInterface, is
	  provided by the Orocos CoreLib
	</para>
      </sect2>
    </sect1>
  </chapter>

</book>
