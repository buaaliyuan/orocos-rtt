<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
  <title>The Orocos Program Processor Manual</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002, 2003, 2004</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

    <abstract>
      <para>
	The Program Processor is the 'execution engine'
	of Programs and State Machines. It can execute
	any number of Programs and State Machines in parallel.
      </para>
    </abstract>

  <revhistory>
  <revision>
    <revnumber>0.9</revnumber>
    <date>14 Nov 2002</date>
    <authorinitials>ps</authorinitials>
    <revremark>Updated for release</revremark>
  </revision>
  <revision>
    <revnumber>0.11</revnumber>
    <date>31 Okt 2003</date>
    <authorinitials>ps</authorinitials>
    <revremark>Adapted documentation to comply with 0.11 release</revremark>
  </revision>
  <revision>
    <revnumber>0.12</revnumber>
    <date>19 Jan 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Programs are Boost::Graphs now.</revremark>
  </revision>
  <revision>
    <revnumber>0.13</revnumber>
    <date>2 Feb 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>States workings updated</revremark>
  </revision>
  <revision>
    <revnumber>0.14</revnumber>
    <date>31 March 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>New Program and StateMachine implementation</revremark>
  </revision>
  <revision>
    <revnumber>0.16</revnumber>
    <date>06 July 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Added CommandFunctor docs</revremark>
  </revision>
  <revision>
    <revnumber>0.17</revnumber>
    <date>13 August 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Change in StateMachine start/stop semantics</revremark>
  </revision>
  <revision>
    <revnumber>0.18</revnumber>
    <date>7 December 2004</date>
    <authorinitials>ps</authorinitials>
    <revremark>Refer to Task Contexts</revremark>
  </revision>
  <revision>
    <revnumber>0.19</revnumber>
    <date>7 March 2005</date>
    <authorinitials>ps</authorinitials>
    <revremark>New StateMachine semantics, dumped old StateContext</revremark>
  </revision>
  </revhistory>

  <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>
  

  
  <sect1>
    <title>Introduction to the Program Processor</title>
    <para>
      &orocos; is meant for building realtime systems. You will find
      many usefull classes in the Orocos CoreLib to build
      them, but they would only act as a noninteractive whole. The
      Execution package allows a user to configure a system, execute
      user-defined programs on that system and interactively
      accept commands. A
      <classname>StateMachine</classname> will hold the
      user-programmable state machine (representing the system
      logic). A <classname>ProgramGraph</classname> will hold the
      user-defined program to be executed. A
      <classname>Processor</classname> will then represent an
      execution engine which loads the state machine and
      program definitions and executes them. Loading
      a program is however a non-realtime operation, since it performs dynamic
      memory allocations. Execution of the programs and state machines
      will happen in real time. The StateMachine executes programs according
      to an user defined logic, so if we write about program semantics, they
      hold in plain programs and state machines.
    </para>
    <para>
      The Program Processor is not what the user will use directly.
      The user will mainly use the <ulink url="orocos-program-parser.html">
	Orocos Program Parser</ulink> with the <ulink url="orocos-task-context.html">
	Orocos Task Infrastructure</ulink>. The Parser
      generates ProgramGraphs and StateGraphs from user friendly
      text files, which can then be executed in realtime.
    </para>
  </sect1>
  
  <sect1>
    <title>Executing Commands, Programs and Hierarchical StateMachines</title>
    <sect2>
      <title>The Processor</title>
      <para>
	The <classname>Processor</classname> is the core class of this package
	It is capable of loading and processing a state machine and
	loading and executing additional programs on that system. A
	system's configuration (or part of) can be defined in a State
	Machine ( a State Machine is a real-time state machine which
	iterates over a collection of Orocos States ).  Multiple State
	Machines can be loaded and started/stopped in parallel. A
	Program is a sequence of commands and methods, connected to each other
	through condition evaluation. Also programs can be loaded and
	run in parallel.
      </para>
    </sect2>
    <sect2>
      <title>Running the Processor</title>
      <para>
	The Processor is responsible for accepting command requests
	from other (realtime) tasks. It uses a non-blocking atomic queue
	to store incomming requests and fetch-and-execute them in its periodic loop,
	which can be synchronised with tasks of the same priority. It offers
	thus a thread-safe realtime means of message passing between threads,
	without intervention of the Operating System.
	However, before it will accept commands, it must be attached
	to a periodic task and be started. It implements the
	<classname>ORO_CoreLib::RunnableInterface</classname> class,
	which allows it to be run by periodic tasks :
      </para>
      <programlisting>
  #include &lt;execution/Processor.hpp&gt;
  #include &lt;corelib/TaskNonPreemptible.hpp&gt;

  ORO_Execution::Processor proc;
  ORO_CoreLib::TaskNonPreemptible ptask( 0.01, proc); // see CoreLib doc

  ptask.start();

  CommandInterface* com = ... // See the last section

  assert ( proc.getTask()->isRunning() );
  int ticket = proc.process( com ); </programlisting>
      <para>
	If <parameter>ticket</parameter> is zero, the command was
	not accepted by the processor, possibly the queue was full
	or it was not running. You can query if a command has been
	fetched and executed by calling :
      </para>
      <programlisting>
  if ( proc.isProcessed( ticket ) )
     // done !
  else
     // still busy ! </programlisting>
      <para>
	The commands this Processor accepts must be for tasks of the
	same priority, and each Processor can only be run in one
	thread. Orocos provides a mechanism to transparantly serialise
	tasks of equal priority in the same thread, this is explained
	in the Orocos CoreLib documentation. Take a look at the Task
	Infrastructure Manual for more elaborate examples of Command
	queueing. 
      </para>
      <figure><title>Threads Sending Commands</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="Commands" />
	  </imageobject>
	  <caption>
	    <para>
	      Tasks of different threads communicate by sending
	      commands to each others Processors.
	    </para>
	  </caption>
	</mediaobject>
      </figure>
      <para>
	In addition to command processing, the Processor provides
	functions to manipulate Programs and
	State Machines. The available commands are presented in the
	figures in the next sections. 
      </para>
    </sect2>
    <sect2>
      <title>Programs</title>
      <para>
	The <classname>ProgramGraph</classname> is a tree composed
	of command nodes ( See : <classname>CommandInterface</classname> class ),
	where each node contains one or more
	statements. A ProgramGraph keeps track of the start node
	and the node to be executed next. As such a program is executed
	one node at a time and the transition to the next node
	is done on a given boolean condition ( See :
	<classname>ConditionInterface</classname> class). The
	ProgramGraph has a builder interface for constructing
	nodes and conditions, which is used by other packages to construct valid
	programs.
      </para>
	<figure><title>Executing Program Statements</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="ProgramTransitions" />
	    </imageobject>
	  </mediaobject>
	</figure>
      <para>
	Programs are generated from a script, this is explained in 
	the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	convert Orocos Program Scripts to a Program which can
	be loaded in the Processor.
      </para>
	<figure><title>Using a Program</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="ProgramStates" />
	    </imageobject>
	  </mediaobject>
	</figure>
      <para>
	Loading, unloading and deleting a Program may throw
	an exception. The <exceptionname>program_load_exception</exceptionname>
	and <exceptionname>program_unload_exception</exceptionname>
	should be try'ed and catch'ed on load and unload or deletion
	of a Program in the Processor.
      </para>
    </sect2>
    <sect2>
      <title>State Machine and State</title>
      <para>
	The <classname>StateMachine</classname> is a collection of
	states, linked to each other and is defined in the <ulink
	  url="orocos-corelib.html">Orocos CoreLib</ulink> . It
	represents a state machine of the realtime system's logic and
	may access internal and external data for deciding on its
	state transitions. Every 'device' has some states or
	configurations in which a specific action must be taken (on
	entry, during or on exit) and transitions between states are
	defined by boundary conditions (guards). Every such state is defined by
	the <classname>StateInterface</classname>.
	A state itself is defined by three methods : onEntry(),
	handle() and onExit(). They are called by the Processor when
	this state is entered, handled or left. When no state transition
	took place, handle() is called in a periodic execution step
	of the Processor. Otherwise, first the onExit() method of the current
	state is called and then the onEntry() method of the new state
	is called. The next periodic step will evaluate transition conditions,
	and if none succeeds, handle() will be called, and so on.
      </para>
      <para>
	As transitions define when a state will be left, preconditions
	are used to define when a state should not be entered, and
	an alternative must be provided.
      </para>
	<figure><title>Executing a StateMachine</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="StateTransitions" />
	    </imageobject>
	  </mediaobject>
	</figure>
      <para>To see how a State Machine can be used in Orocos, we refer
	to the <ulink url="orocos-program-parser.html">Orocos
	  Program Parser</ulink> Manual. The Parser is able to
	convert Orocos State Descriptions to a State Machine
	wich can be loaded in the Processor.
      </para>
	<figure><title>Using a StateMachine</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="MachineStates" />
	    </imageobject>
	</mediaobject>
	</figure>
      <para>
	Loading, unloading and deleting a State Machine may throw
	an exception. The <exceptionname>program_load_exception</exceptionname>
	and <exceptionname>program_unload_exception</exceptionname>
	should be try'ed and catch'ed on load and unload or deletion
	of a State Machine in the Processor.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>StateMachine and Program Implementation Details</title>
    <para>
      This section gives a short description of the inside
      of Programs and StateMachines, and can be skipped by most users.
    </para>
    <sect2 id="progproc-condition">
      <title>( State ) Transitions : Condition Edge</title>
      <para>
	The <classname>ConditionEdge</classname> defines an edge
	of the state diagram. It contains
	a condition on which a next state is entered. The 
	<classname>ConditionInterface</classname> encapsulates
	that logic. Conditions
	can be ordered by priority, so that it is defined in which
	order they are checked. A multiple of
	conditions can lead to the same state.
      </para>
      </sect2>
      <sect2 id="progproc-command">
	<title>Statements : Command Node</title>
	<para>
	  The <classname>CommandNode</classname> contains a
	  <classname>Command</classname> and is connected by edges of
	  the type <classname>ConditionEdge</classname>, these edges
	  connect one node with another and allow the transition
	  if the contained condition evaluates to true. When a program
	  is executed, it executes the command and runs through the
	  list of edges of that node. When a <classname>
	    Condition</classname> is found valid, the next program
	  node to be executed is found. If no condition is
	  fulfilled, the same command node will be executed again.
	  Also a line number can be associated with each command node,
	  as a reference to the input file formatted by the user.
	</para>
      </sect2>
      <sect2>
	<title>The Command class</title>
	<para>
	  The <classname>Command</classname> is the abstraction of a
	  user directive that has to be executed. A Command can be
	  execute()'ed and reset()'ed. For each action exists one
	  Command, but a Command can be composed of other Commands.
	  The basic interface, CommandInterface, is provided by the
	  Orocos CoreLib.
	</para>
      </sect2>
      <sect2>
	<title>The Condition class</title>
	<para>
	  The <classname>Condition</classname> is the abstraction of a
	  user expression that has to be evaluated. A Condition can be
	  evaluated()'ed and reset()'ed. Many primitive expressions
	  can be evaluated and a Condition can be composed of other
	  Conditions. The basic interface, ConditionInterface, is
	  provided by the Orocos CoreLib
	</para>
    </sect2>
  </sect1>
  <sect1>
    <title>Creating Commands</title>
    <para>
      Apart from the Program and State Machine Commands (which are
      generated by the Parsers), the user can convert C/C++ functions in commands for
      the Processor to execute. This is usefull if a function must be
      called at a later moment.
    </para>
    <sect2>
      <title>Generic Functors</title>
      <para>
	Orocos uses the 'Generic Functor' paradigm to encapsulate Commands.
	This means that an object (the functor) is created which holds a
	pointer to the function to be executed. If this function needs
	arguments, these are also stored in the functor. The object
	can then be passed around until another object decides to execute
	the functor. Execution of a functor leads to the original function
	to be called, together with the arguments.
      </para>
	<figure><title>A Generic Functor</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="Functor" />
	    </imageobject>
	  </mediaobject>
	</figure>
    </sect2>
    <sect2>
      <title>Creating a CommandFunctor</title>
      <para>
	The CommandFunctor is the object used to store the function
	pointer in. It implements the CommandInterface such that
	it can be execute()'ed by the Processor :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  void foo();

  CommandInterface* command = newCommandFunctor( &amp;foo );

  command->execute(); // calls foo()

  delete command;
	</programlisting>
	notice that we use a factory-function <function>newCommandFunctor</function>
	in order to avoid providing a template parameter.
      </para>
      <para>
	It is possible to wrap more complex functions in a CommandFunctor,
	if the boost::bind library is used :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  #include &lt;boost/bind.hpp&gt;
  
  void foo( int x, int y );

  CommandInterface* command = newCommandFunctor( boost::bind( &amp;foo, 1, 2 ) );

  command->execute(); // calls foo(1,2)

  delete command;
	</programlisting>
	Argument 'binding' is a very powerfull feature of C++. It allows to 
	provide the arguments of a function in advance and execute the function
	lateron.
      </para>
      <para>
	It is also possible to call the memberfunction of an object. In that
	case, the first parameter of the function becomes the pointer to the
	object, followed by the arguments of the function :
	<programlisting>
  #include &lt;corelib/CommandFunctor.hpp&gt;
  #include &lt;boost/bind.hpp&gt;
  
  class X {
  public:
    void foo( int x, int y );
  };

  X x_object;
  CommandInterface* command = newCommandFunctor( boost::bind( &amp;X::foo, x_object, 1, 2 ) );

  command->execute(); // calls x_object.foo(1,2)

  delete command;
	</programlisting>
	notice that the foo function is now prefixed by the class scope 'X::'.
      </para>
      <para>
	The CommandFunctor allows us to bind a function to a CommandInterface.
	Since the Program Processor can execute CommandInterface objects,
	it is a powerfull way to delay calling of a function to a later moment.
      </para>
    </sect2>
    <sect2>
      <title>Processing a Command</title>
      <para>
	Using the CommandFunctor from the previous section, we can pass
	the command to the processor :
	<programlisting>
  CommandInterface* command = ...
  Processor* proc = ...

  int nr = proc->process( command );
	</programlisting>
	If nr is non-zero, the command was accepted, if zero, the command
	fifo is full and a new process attempt must be made.
      </para>
      <para>
	Another thread instructs the processor to execute all queued commands
	(and programs) synchronically calling the
	<programlisting>
  proc->step();
	</programlisting>
	function. The easiest way to do this is to create a Task which
	runs the Processor.
      </para>
    </sect2>
    <sect2>
      <title>Common Usage Examples</title>
      <para>
	The CommandFunctor can be used when a separate thread of
	execution wants to execute a function in the Processor thread.
	In Orocos, this happens when an external commando must be
	processed by the realtime control kernel. In one thread,
	the CommandFunctor is created (which contains the function
	to be called) and is passed to the Processor of the
	ExecutionExtension, which is part of the control kernel.
	The control kernel thread executes all queued
	commands in the Processor after the control calculations
	are done. In this way, safe data access can be guaranteed.
      </para>
    </sect2>
  </sect1>
</article>
