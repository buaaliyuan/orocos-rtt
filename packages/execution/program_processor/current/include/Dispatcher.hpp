/***************************************************************************
  tag: Peter Soetens  Thu Oct 10 16:19:04 CEST 2002  Dispatcher.hpp 

                        Dispatcher.hpp -  description
                           -------------------
    begin                : Thu October 10 2002
    copyright            : (C) 2002 Peter Soetens
    email                : peter.soetens@mech.kuleuven.ac.be
 
 ***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
 
 
#ifndef DISPATCHER_HPP
#define DISPATCHER_HPP

#include <os/cpp.hpp>
#include <rtstl/rtstl.hpp>

#include <corelib/EventInterfaces.hpp>
#include <corelib/NameServerRegistrator.hpp>

#include "DispatcherInterface.hpp"
#include "ORO_ExecutionPC.hpp"
#include "ProcessorInterface.hpp"

namespace ORO_Execution
{
    using namespace std;

    using namespace ORO_CoreLib;

    class ORO_ExecutionInterface;

    /**
     * An implementation of DispatcherInterface. 
     * Every std::string that has to be processed is send to each registered 
     * ORO_ExecutionInterface where further processing is done
     *
     * The Dispatcher has an ProcessorInterface registered in it, whereto commands,
     * generated by the different ORO_ExecutionInterfaces are sent
     */
    class Dispatcher: public DispatcherInterface,
                public NameServerRegistrator<Dispatcher *>
    {

        public:

            /**
             * Creates a new Dispatcher with a name
             *
             * @param name
             *     the name of this Dispatcher
             * @pre  name != 0
             * @post Dispatcher is created
             * @post this is registered as the Dispatcher of <PI>
             * @post this is registered with the nameserver with name <name>
             */
            Dispatcher( std::string name );

            virtual ~Dispatcher()
            {}

            /**
             * Registers a ORO_ExecutionInterface to this Dispatcher
             *
             * @param parser
             *     the ORO_ExecutionInterface to be registered
             * @pre  <parser> != 0
             * @post if <parser> wasn't already registered, it is now 
             */
            void registerORO_Execution( ORO_ExecutionInterface *parser )
            {
                parsers.push_back( parser );
            }

            /**
             * Unregisters a ORO_ExecutionInterface from this Dispatcher
             *
             * @param parser
             *     the ORO_ExecutionInterface to be unregistered
             * @post every occurrence of <parser> in the list of parserInterfaces 
             *     is unregistered, nothing happens if <parser> isn't registered
             */
            void unregisterORO_Execution( ORO_ExecutionInterface *parser )
            {
                typedef vector<ORO_ExecutionInterface*>::iterator vpi;

                for ( vpi it = parsers.begin(); it != parsers.end(); ++it )
                {
                    if ( ( *it ) == parser )
                    {
                        parsers.erase( it );
                    }
                }
            }

            /**
             * Processes the given std::string, the std::string is sent to every registered
             * ORO_ExecutionInterface for further processing
             *
             * @param toProcess
             *     the std::string that has to be processed
             * @post <toProcess> is sent to every registered ORO_ExecutionInterface
             */
            void process( std::string toProcess );

            /**
             * Registers <PI> as this Dispatchers ProcessorInterface
             *
             * @param PI
             *     the ProcessorInterface to be registered
             * @pre  PI != 0
             * @post <PI> is registered as this Dispatchers Processorinterface
             */
            void registerProcessorInterface( ProcessorInterface* PI )
            {
                procInt = PI;
            }


            /**
             * The nameserver that registers Dispatchers
             */
            static NameServer<Dispatcher *> nameserver;

        private:

            // forbidden
            Dispatcher();

            /**
             * A vector with registered ORO_ExecutionInterfaces
             */
            vector<ORO_ExecutionInterface*> parsers;

            /**
             * The ProcessorInterface that belongs with this Dispatcher
             */
            ProcessorInterface* procInt;

    };

}

#endif
