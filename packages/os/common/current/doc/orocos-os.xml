<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title>Orocos Operating System Abstraction</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2003, 2004</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document gives a short overview of the 
	philosophy and available classes for Operating
	System ( threads, mutexes, etc ) interaction within &orocos;
      </para>
    </abstract>
    
    <revhistory>
      <revision>
	<revnumber>0.1</revnumber>
	<date>28 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Initial version copied from corelib documentation.</revremark>
      </revision>
      <revision>
	<revnumber>0.16</revnumber>
	<date>31 March 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>PeriodicThread and SingleThread.</revremark>
      </revision>
      <revision>
	<revnumber>0.18</revnumber>
	<date>10 Dec 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>Review of all sections. I have removed the kernel space
	  sections, since it is no longer maintained. Everything in this
	manual now applies to the GNU/Linux and RTAI/LXRT targets.</revremark>
      </revision>
      <revision>
	<revnumber>0.19</revnumber>
	<date>16 Feb 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Introduction cleanup, restructuring.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <sect1>
    <title>Introduction</title>
    <sect2>
      <title>Realtime OS Abstraction</title>
      <para>
	The OS package makes an abstraction of the operating system on
	which it runs. It provides C++ interfaces to only the
	<emphasis>minimal set</emphasis> of operating system
	primitives that it needs: mutexes, condition variables and
	threads. This is in accordance with the general developers
	requirements of the project: a minimalistic approach is much
	easier to scale, to maintain, and to port. The abstraction
	also allows &orocos; users to build their software on all
	supported systems with only a recompilation step. The OS
	Abstraction layer is not directly being used by the
	application writer. Basic OS primitives are leading
	programmers to often to pitfalls which can be avoided using
	well known solutions. These solutions are implemented in the
	CoreLib classes and allow the programmer to think in a more
	natural way about the problem.
      </para>
      <para>
	The abstractions cause (almost) no execution overhead, because
	the wrappers can be called inline. See the <option>OROBLD_OS_AGNOSTIC</option>
	option in the configuration tool to control inlining.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>The Operating System Interface</title>
    <sect2>
      <title>Basics</title>
      <para>
	Keeping the &orocos; core portable requires an extra
	abstraction of some operating system (OS) functionalities. For
	example, a thread can be created, started, paused, scheduled,
	etc., but each OS uses other function calls to do this.
	&orocos; prefers C++ interfaces, which led to the
	<classname>PeriodicThreadInterface</classname> interface and
	<classname>PeriodicThread</classname> class as the
	abstractions of a periodic thread. The
	<classname>SingleThread</classname> is a non periodic thread
	which executes the functionality once each time it is started.
	Each OS implements in its <filename
	  class="directory">os/&lt;OS-name-here&gt;</filename>
	directory the specific system calls to get the desired effect.
	The <classname>Mutex</classname> and
	<classname>MutexRecursive</classname> classes in combination
	with the <classname>MutexLock</classname> and
	<classname>MutexTryLock</classname> classes are also commonly
	used abstractions in multithreaded frameworks.
      </para>
      <para>
	This drawing situates the Operating System abstraction with
	respect to device driver interfacing (DI) and the rest of
	&orocos; <figure><title>OS Interface overview</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="FDIvsFOSI" />
	    </imageobject>
	  </mediaobject>
      </figure>
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>OS Package Structure</title>
      <para>
      The OS package has always a <filename>common</filename>
      directory for all common interfaces and configuration options.
      This directory is OS independent but may contain assembler
      instructions ( such as Compare And Swap ) for spicific processor
      architectures. However, if Orocos grows to support many
      different architectures, an <filename>arch</filename> directory
      will most likely be introduced to sort files for specific
      architectures. Next to the common directory is a
      <filename>&lt;target></filename> directory which contains the
      abstraction implementations for a specific OS. Multiple OS
      abstractions may be available, but only one can be configured
      and compiled in one configuration.
    </para>

<!--     <sect2> -->
<!--       <title>Using the OS abstraction in the Linux kernel </title> -->
<!--       <para> -->
<!-- 	When building kernel space applications, the realtime code -->
<!-- 	does not run in a C++ friendly environment and we had to wrap -->
<!-- 	some libraries with our own headers to guarantee correct -->
<!-- 	functioning. If you want to use the Standard C++ library -->
<!-- 	(without iostreams), you can include the desired header, but -->
<!-- 	not a full implementation will be provided. The following -->
<!-- 	table contains the latest kernel-approved header files: -->
<!--       </para> -->
<!--       <note> -->
<!-- 	See the next section if you want full availability of -->
<!-- 	all libraries. -->
<!--       </note> -->
<!--       <table frame="all"> -->
<!-- 	<title>Header Files for Kernel Applications</title> -->
<!-- 	<tgroup cols="3" colsep="1" rowsep="1"> -->
<!-- 	  <thead > -->
<!-- 	    <row> -->
<!-- 	      <entry>Library</entry> -->
<!-- 	      <entry>Which file to include</entry> -->
<!-- 	      <entry>Remarks</entry> -->
<!-- 	    </row> -->
<!-- 	  </thead> -->
<!-- 	  <tbody> -->
<!-- 	    <row> -->
<!-- 	      <entry align="center" valign="middle">OS -->
<!-- 		functionality</entry> -->
<!-- 	      <entry align="center" -->
<!-- 		  valign="middle">os/fosi.h</entry> -->
<!-- 	      <entry align="left" valign="middle">Include this file if -->
<!-- 		you want to make system calls to the underlying -->
<!-- 		operating system ( RTLinux, RTAI ) .</entry></row> -->
<!-- 	    <row> -->
<!-- 	      <entry align="center" valign="middle">Standard Template -->
<!-- 		Library (STL) and Standard C++ Library</entry> -->
<!-- 	      <entry align="center" -->
<!-- 		  valign="middle">&lt;any_header&gt;</entry> -->
<!-- 	      <entry align="left" valign="middle">No iostream support, -->
<!-- 		limited support of other standard library classes for -->
<!-- 		RTAI. RTLinux only supports string and -->
<!-- 		vector.</entry></row> -->
<!-- 	    <row> -->
<!-- 	      <entry align="center" valign="middle">Streams</entry> -->
<!-- 	      <entry align="center" -->
<!-- 		  valign="middle">os/rtstreams.hpp</entry> -->
<!-- 	      <entry align="left" valign="middle">Defines rt_std::cout -->
<!-- 		which allows realtime printing, with limited -->
<!-- 		functionality</entry></row> -->
<!-- 	    <row> -->
<!-- 	      <entry align="center" valign="middle">C Math -->
<!-- 		Library</entry> -->
<!-- 	      <entry align="center" valign="middle">math.h</entry> -->
<!-- 	      <entry align="left" valign="middle">not all functions -->
<!-- 		supported in RTLinux (i.e. log() )</entry></row> -->
<!-- 	    <row> -->
<!-- 	      <entry align="center" valign="middle">OS Abstraction -->
<!-- 		classes</entry> -->
<!-- 	      <entry align="center" valign="middle"> -->
<!-- 		Mutex.hpp, MutexLock.hpp, PeriodicThread.hpp, -->
<!-- 		EvenInterrupt.hpp -->
<!-- 	      </entry> -->
<!-- 	      <entry align="left" valign="middle"> -->
<!-- 		The standard provided C++ OS primitives.</entry></row> -->
<!-- 	  </tbody> -->
<!-- 	</tgroup> -->
<!--       </table>  -->
<!--       <para> -->
<!-- 	OSs implementing the POSIX Threads API -->
<!-- 	<emphasis>correctly</emphasis> greatly eases porting. Since -->
<!-- 	this api is not present in the Linux kernel itself, only -->
<!-- 	limited support is available for most functions. The next -->
<!-- 	sections provides an alternative. -->
<!--       </para> -->
<!--     </sect2> -->
    <sect2>
      <title>The RTAI/LXRT OS target</title>
      <para>
	<!-- 	The previous section explained which headers to include -->
<!-- 	when building Linux kernel applications. Fortunately, an -->
<!-- 	application does not need to run in the Linux kernel -->
<!-- 	to be realtime. Some OSes (like VxWorks) don't even have -->
<!-- 	the notion of a kernel application. --> 
	RTAI/LXRT is an
	environment that allows user programs to run with realtime
	determinism next to the normal programs. The advantage is
	that the realtime application can use normal system libraries
	for its functioning, like showing a graphical user interface.
      </para>
      <para>
	An introduction to RTAI/LXRT can be found in the <ulink
	  url="http://people.mech.kuleuven.ac.be/~psoetens/lxrt/portingtolxrt.html"> 
	  Porting to LXRT HOWTO</ulink>, which is a must- read if you
	don't know what LXRT is.
      </para>
      <para>
	The common rule when using such an OS as a target is
	that any present library can be used and any header included
	as long as not realtime functionality is not called from
	within a hard realtime thread. For LXRT specifically, 
	this means that all the RTAI (and Orocos) OS primitives
	may be used, but not the native Linux ones from within
	a hard realtime thread. Fortunately these system calls
	can be done from a not hard realtime thread within the
	same program. <emphasis>Using the Orocos provided C++ primitives
	is in any case correct.</emphasis>
      </para>
    </sect2>
    <sect2>
      <title>OS Header Files</title>
      <para>
	The following table gives a short overview of the available
	headers in the OS package.
      </para>
      <table frame="all">
	<title>Header Files</title>
	<tgroup cols="3" colsep="1" rowsep="1">
	  <thead >
	    <row>
	      <entry>Library</entry>
	      <entry>Which file to include</entry>
	      <entry>Remarks</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry align="center" valign="middle">OS
		functionality</entry>
	      <entry align="center"
		  valign="middle">os/fosi.h</entry>
	      <entry align="left" valign="middle">Include this file if
		you want to make system calls to the underlying
		operating system ( LXRT, GNU/Linux ) .</entry></row>
	    <row>
	      <entry align="center" valign="middle">Standard Template
		Library (STL) and Standard C++ Library</entry>
	      <entry align="center"
		  valign="middle">&lt;any_header&gt;</entry>
	      <entry align="left" valign="middle">All headers
		can be included, exceptions and iostreams
		can not be used from a hard realtime thread.</entry>
	    </row>
	    <row>
	      <entry align="center" valign="middle">Streams</entry>
	      <entry align="center"
		  valign="middle">os/rtstreams.hpp</entry>
	      <entry align="left" valign="middle">Defines rt_std::cout
		which allows realtime printing, with limited
		functionality</entry></row>
	    <row>
	      <entry align="center" valign="middle">C Math
		Library</entry>
	      <entry align="center" valign="middle">math.h</entry>
	      <entry align="left" valign="middle"> Fully supported
		</entry></row>
	    <row>
	      <entry align="center" valign="middle">OS Abstraction
		classes</entry>
	      <entry align="center" valign="middle">
		Mutex.hpp, MutexLock.hpp, PeriodicThread.hpp, SingleThread.hpp,
		main.h
	      </entry>
	      <entry align="left" valign="middle">
		The standard provided C++ OS primitives. main.h
		is required to be included in your main program file.
	      </entry></row>
	  </tbody>
	</tgroup>
      </table> 
    </sect2>
  </sect1>
  <sect1>
    <title>Using Threads and Realtime Execution of Your Program</title>
    <sect2>
      <title>Writing the Program main()</title>
      <para>
	All tasks in the realtime system have to be performed by some
	thread.  The OS abstraction expects an <function>int
	  ORO_main(int argc, char** argv)</function> function (which
	the user has written) and will call that after all system
	initialisation has been done, meaning thread creation or
	setting up the realtime primitives. Inside ORO_main() the user
	may expect that the system is properly set up and can be used.
	The resulting libtarget.a library will contain the real main()
	function which will call the ORO_main() function.
      </para>
      <note>
	<para>
	  Do not forget to include
	  <filename>&lt;os/main.h&gt;</filename> in the main program
	  file, or the linker will not find the ORO_main function.
	</para>
      </note>
      <note>
	<para>
	  Using global objects ( or <emphasis>static</emphasis> class
	  members ) which use the OS functions before ORO_main() is
	  entered (because they are constructed before main() ), can
	  come into conflict with an uninitialised system. It is
	  therefor advised not to use static global objects which use
	  the OS primitives. <classname>Event</classname>s in the
	  CoreLib are an example of objects which should not be
	  constructed as global static. You can use dynamically
	  created (i.e. created with <emphasis>new</emphasis> ) global
	  events instead.
	</para>
      </note>
<!--       <sect3> -->
<!-- 	<title>Starting Kernel Applications</title> -->
<!-- 	<para> -->
<!-- 	<emphasis> Starting an application is a bit more complex in -->
<!-- 	  the kernel (RTAI, RTLinux)</emphasis>. For a program to be -->
<!-- 	executed in kernelspace-realtime, it has to be compiled into a -->
<!-- 	kernel module. Each kernel module needs exactly one -->
<!-- 	<function>init_module()</function> and -->
<!-- 	<function>cleanup_module()</function> function call. The -->
<!-- 	former will be called when the module is loaded, the latter -->
<!-- 	will be called when the module is unloaded. Our policy is to -->
<!-- 	put these functions in a <filename>module.c</filename> -->
<!-- 	file, which will call then our real C++ functions, which -->
<!-- 	reside in another file.  -->
<!-- 	</para> -->
<!-- 	<para> -->
<!-- 	  First, a special function is called to -->
<!-- 	  initialize all static variables your program might have. -->
<!-- 	  When this is done the real initialisation function is -->
<!-- 	  called. There we instantiate all objects we need, and -->
<!-- 	  finally start the services. Each service is now running as a -->
<!-- 	  realtime thread, using the data you provided on -->
<!-- 	  instantiation. Be warned that when this function exits, all -->
<!-- 	  local data is destroyed, that is why we allocate global -->
<!-- 	  variables. -->
<!-- 	</para> -->
<!-- 	<note> -->
<!-- 	  Writing kernel applications is doing it the hard way and -->
<!-- 	  is not advised for beginners. Use RTAI/LXRT instead. -->
<!-- 	</note> -->
<!--       </sect3>     -->
    </sect2>
    <sect2>
      <title>The Orocos Thread System</title>
      <sect3>
	<title>Periodic Threads</title>
	<para>
	  An &orocos; thread, which must execute a task periodically,
	  is defined by the
	  <classname>PeriodicThreadInterface</classname>. The most
	  common operations are <methodname>start()</methodname>,
	  <methodname>stop()</methodname> and setting the periodicity.
	  What is executed is defined in the <classname>
	    RunnableInterface</classname>. It contains three methods :
	  <methodname>initialize()</methodname>,
	  <methodname>step()</methodname> and
	  <methodname>finalize()</methodname>. You can inherit from
	  this interface to implement your own functionality. In
	  initialize(), you put the code that has to be executed once
	  when the component is start()'ed. In step(), you put the
	  instructions that must be executed periodically. In
	  finalize(), you put the instructions that must be executed
	  right after the last step() when the component is stop()'ed.
	</para>
	<para>
	  &orocos; delivers one implementation of the
	  <classname>PeriodicThreadInterface</classname> : <classname>
	    PeriodicThread</classname>, which creates a thread
	  according to the operating system you are compiling for.
	  However, you are encouraged <emphasis>NOT</emphasis> to use
	  it! The CoreLib uses this class as a basis to provide a more
	  fundamental task-based (as opposite to thread based)
	  execution mechanism which will insert your periodic tasks in
	  a periodic thread. It is provided in the corelib/task
	  package.
	</para>
	<para>
	  Common uses are :
	  <itemizedlist>
	  <listitem>
	    <para>Running periodic control tasks.</para>
	  </listitem>
	  <listitem>
	    <para>Fetching periodic progress reports.</para>
	  </listitem>
	  <listitem>
	    <para>Running the corelib periodic tasks.</para>
	  </listitem>
	</itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>Non Periodic Threads</title>
	<para>
	  For non-periodic threads, which block or do lenghty calculations in their step() method,
	  the <classname>SingleThread</classname> class can be used.
	  The corelib/task package does not use the SingleThread.
	  Porting applications to Orocos might benifit this class
	  in a first adaptation step. It only has a start()
	  method, which will provoke one single call to step() (see
	  above). It can be re-started each time the step
	  function returns. The initialise() and finalise() functions
	  are called as above.
	</para>
	<para>
	  Common uses are :
	  <itemizedlist>
	  <listitem>
	    <para>Listening for data on a network socket.</para>
	  </listitem>
	  <listitem>
	    <para>Reading a file or files from harddisk.</para>
	  </listitem>
	  <listitem>
	    <para>Waiting for user input.</para>
	  </listitem>
	</itemizedlist>
	</para>
	<para>
	  The user of this class must be aware that he must provide himself
	  the locking primitives (like ORO_OS::Mutex) to provide thread safety.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Synchronisation Primitives</title>
      <para>
	Orocos OS only provides a few synchronisation primitives,
	mainly for guarding critical sections.
      </para>
      <sect3>
	<title>Mutexes</title>
	<para>
	  There are two kinds of Mutexes : <classname>Mutex</classname>
	  and <classname>MutexRecursive</classname>. To lock a mutex, it
	  has a method <methodname>lock()</methodname>, to unlock, the method is <methodname>unlock()</methodname> and to
	  try to lock, it is <methodname>trylock()</methodname>.
	  A lock() and trylock() on a recursive mutex from the same
	  thread will always succeed, otherwise, it blocks.
	</para>
	<para>
	  For ease of use, there is a <classname>MutexLock</classname> which
	  gets a Mutex as argument in the contstructor. As long as the
	  MutexLock object exists, the given Mutex is locked. This is
	  called a scoped lock.
	</para>
	<example>
	  <title>Locking a Mutex</title>
	  <para>The first listing shows a complete lock over a function :</para>
	  <programlisting>
  Mutex m;
  void foo() {
     int i;
     MutexLock lock(m);
     // m is locked.
     // ...
  } // when leaving foo(), m is unlocked.
	  </programlisting>
	  <para>
	    Any scope is valid, so if the critical section is smaller than
	    the size of the function, you can :
	  </para>
	  <programlisting>
  Mutex m;
  void bar() {
     int i;
     // non critical section
     {
        MutexLock lock(m);
        // m is locked.
        // critical section
     } //  m is unlocked.
     // non critical section
     //...
  }
	  </programlisting>
	</example>
      </sect3>
      <sect3>
	<title>Signals and Semaphores</title>
	<para>
	  Orocos does not yet provide a C++ semaphore abstraction. The
	  <filename>os/fosi.h</filename> file provides os independent C
	  functions for semaphores. The higher level Event
	  implementation in CoreLib can be used for thread safe
	  signalling and data exchange.
	</para>
      </sect3>
      <sect3>
	<title>Compare And Swap ( CAS )</title>
	<para>
	  CAS is a fundamental building block of the CoreLib package
	  for inter-thread communication and must be implemented for
	  each OS target. See the Lock-Free sections of the CoreLib manual
	  for Orocos classes which use this primitive.
	</para>
      </sect3>
    </sect2>
  </sect1>
</article>
