<?xml version='1.0'?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY rtai        "<acronym>RTAI</acronym>">
<!ENTITY rtos        "<acronym>RTOS</acronym>">
]
>

<article>
  <articleinfo>
    <title>Orocos Operating System Abstraction</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2003, 2004</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document gives a short overview of the 
	philosophy and available classes for Operating
	System interaction within &orocos;
      </para>
    </abstract>
    
    <revhistory>
      <revision>
	<revnumber>0.1</revnumber>
	<date>28 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Initial version copied from corelib documentation.</revremark>
      </revision>
      <revision>
	<revnumber>0.2</revnumber>
	<date>31 March 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>PeriodicThread and SingleThread.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

<sect1>
    <title>Introduction</title>
    <sect2>
      <title>Realtime OS Abstraction</title>
      <para>
	The OS package makes an abstraction of the operating system on
	which it runs. It provides C++ interfaces to only the
	<emphasis>minimal set</emphasis> of operating system
	primitives that it needs: mutexes, condition variables and
	threads. This is in accordance with the general developers
	requirements of the project: a minimalistic approach is much
	easier to scale, to maintain, and to port. The abstraction
	also allows &orocos; users to build their software on all
	supported systems with only a recompilation step. The OS
	Abstraction layer is not directly being used by the
	application writer. Basic OS primitives are leading
	programmers to often to pitfalls which can be avoided using
	well known solutions. These solutions are implemented in the
	CoreLib classes and allow the programmer to think in a more
	natural way about the problem.
      </para>
      <para>
	The abstractions cause (almost) no execution overhead, because
	the wrapping is solved at compile or configuration time, i.e.,
	before the hard realtime tasks are running.
      </para>
    </sect2>
    <sect2>
      <title>Beyond Realtime</title>
      <para>Not everything must be executed in realtime in a control
	system, on the contrary. User interaction, some environment
	interaction, and system configuration can not execute within
	deterministic time limits. &orocos; also provides this
	interaction and configuration without disturbing the
	determinism of the control task execution.
      </para>
    </sect2>
  </sect1>
  <sect1>
    <title>The Operating System Interface</title>
    <sect2>
      <title>Basics</title>
    <para>
      Keeping the &orocos; core portable requires an extra abstraction
      of some operating system (OS) functionalities. For
      example, we all know that a thread can be created, started,
      paused, scheduled, etc., but each OS uses other function calls
      to do this. &orocos; prefers C++ interfaces, which led to the
      <classname>PeriodicThread</classname> class interface as the
      abstraction of a thread.  Each OS implements in its <filename
	class="directory">os/&lt;OS-name-here&gt;</filename> directory
      the specific system calls to get the desired effect. The
      Mutex and MutexRecursive with MutexLock class are also commonly
      used abstractions. 
    </para>
    <para>
      This drawing situates the Operating System abstraction
      with respect to device driver interfacing (DI) and the
      rest of &orocos;
      <figure><title>OS Interface overview</title>
	<mediaobject>
	  <imageobject role="html">
	    <imagedata fileref="FDIvsFOSI.png" format="PNG"/>
	  </imageobject>
	  <imageobject role="fo">
	    <imagedata fileref="FDIvsFOSI.eps" format="EPS"/>
	  </imageobject>
	</mediaobject>
      </figure>
      </para>
    </sect2>
    
    <sect2>
      <title>Using the OS abstraction in the Linux kernel</title>
      <para>
	When building kernel space applications, the realtime code
	does not run in a C++ friendly environment and we had to wrap
	some libraries with our own headers to guarantee correct
	functioning. If you want to use the Standard C++ library
	(without iostreams), you can include the desired header, but
	not a full implementation will be provided. The following
	table contains the latest kernel-approved header files:
      </para>
      <note>
	See the next section if you want full availability of
	all libraries.
      </note>
      <table frame="all">
	<title>Header Files for Kernel Applications</title>
	<tgroup cols="3" colsep="1" rowsep="1">
	  <thead >
	    <row>
	      <entry>Library</entry>
	      <entry>Which file to include</entry>
	      <entry>Remarks</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry align="center" valign="middle">OS
		functionality</entry>
	      <entry align="center"
		  valign="middle">os/fosi.h</entry>
	      <entry align="left" valign="middle">Include this file if
		you want to make system calls to the underlying
		operating system ( RTLinux, RTAI ) .</entry></row>
	    <row>
	      <entry align="center" valign="middle">Standard Template
		Library (STL) and Standard C++ Library</entry>
	      <entry align="center"
		  valign="middle">&lt;any_header&gt;</entry>
	      <entry align="left" valign="middle">No iostream support,
		limited support of other standard library classes for
		RTAI. RTLinux only supports string and
		vector.</entry></row>
	    <row>
	      <entry align="center" valign="middle">Streams</entry>
	      <entry align="center"
		  valign="middle">os/rtstreams.hpp</entry>
	      <entry align="left" valign="middle">Defines rt_std::cout
		which allows realtime printing, with limited
		functionality</entry></row>
	    <row>
	      <entry align="center" valign="middle">C Math
		Library</entry>
	      <entry align="center" valign="middle">math.h</entry>
	      <entry align="left" valign="middle">not all functions
		supported in RTLinux (i.e. log() )</entry></row>
	    <row>
	      <entry align="center" valign="middle">OS Abstraction
		classes</entry>
	      <entry align="center" valign="middle">
		Mutex.hpp, MutexLock.hpp, PeriodicThread.hpp,
		EvenInterrupt.hpp
	      </entry>
	      <entry align="left" valign="middle">
		The standard provided C++ OS primitives.</entry></row>
	  </tbody>
	</tgroup>
      </table> 
      <para>
	OSs implementing the POSIX Threads API
	<emphasis>correctly</emphasis> greatly eases porting. Since
	this api is not present in the Linux kernel itself, only
	limited support is available for most functions. The next
	sections provides an alternative.
      </para>
    </sect2>
    <sect2>
      <title>Using the OS Abstraction in Fully Supported OSes</title>
      <para>
	The previous section explained which headers to include
	when building Linux kernel applications. Fortunately, an
	application does not need to run in the Linux kernel
	to be realtime. Some OSes (like VxWorks) don't even have
	the notion of a kernel application. RTAI/LXRT is an
	environment that allows user programs to run with realtime
	determinism next to the normal programs. The advantage is
	that the realtime application can use normal system libraries
	for its functioning, like showing a graphical user interface.
      </para>
      <para>
	An introduction to RTAI/LXRT can be found in the <ulink
	  url="http://people.mech.kuleuven.ac.be/~psoetens/lxrt/portingtolxrt.html"> 
	  Porting to LXRT HOWTO</ulink>, which is a must- read if you
	don't know what LXRT is.
      </para>
      <para>
	The common rule when using such an OS as a target is
	that any present library can be used and any header included
	as long as not realtime functionality is not called from
	within a hard realtime thread. For LXRT specifically, 
	this means that all the RTAI (and Orocos) OS primitives
	may be used, but not the native Linux ones from within
	a hard realtime thread. Fortunately these system calls
	can be done from a not hard realtime thread within the
	same program. Using the Orocos provided C++ primitives
	is always correct.
      </para>
      <table frame="all">
	<title>Header Files for Fully Supported Applications</title>
	<tgroup cols="3" colsep="1" rowsep="1">
	  <thead >
	    <row>
	      <entry>Library</entry>
	      <entry>Which file to include</entry>
	      <entry>Remarks</entry>
	    </row>
	  </thead>
	  <tbody>
	    <row>
	      <entry align="center" valign="middle">OS
		functionality</entry>
	      <entry align="center"
		  valign="middle">os/fosi.h</entry>
	      <entry align="left" valign="middle">Include this file if
		you want to make system calls to the underlying
		operating system ( LXRT, GNU/Linux ) .</entry></row>
	    <row>
	      <entry align="center" valign="middle">Standard Template
		Library (STL) and Standard C++ Library</entry>
	      <entry align="center"
		  valign="middle">&lt;any_header&gt;</entry>
	      <entry align="left" valign="middle">All headers
		can be included, exceptions should not be used. iostreams
		can not be used from a hard realtime thread.</entry>
	    </row>
	    <row>
	      <entry align="center" valign="middle">Streams</entry>
	      <entry align="center"
		  valign="middle">os/rtstreams.hpp</entry>
	      <entry align="left" valign="middle">Defines rt_std::cout
		which allows realtime printing, with limited
		functionality</entry></row>
	    <row>
	      <entry align="center" valign="middle">C Math
		Library</entry>
	      <entry align="center" valign="middle">math.h</entry>
	      <entry align="left" valign="middle"> Fully supported
		</entry></row>
	    <row>
	      <entry align="center" valign="middle">OS Abstraction
		classes</entry>
	      <entry align="center" valign="middle">
		Mutex.hpp, MutexLock.hpp, PeriodicThread.hpp, SingleThread.hpp,
		EvenInterrupt.hpp, main.h
	      </entry>
	      <entry align="left" valign="middle">
		The standard provided C++ OS primitives. main.h
		is required to be included in your main program file.
	      </entry></row>
	  </tbody>
	</tgroup>
      </table> 
    </sect2>
  </sect1>
  <sect1>
    <title>Threads and Realtime Execution of Your Program</title>
    <sect2>
      <title>Starting your program</title>
      <sect3>
	<title>Normal Usage</title>
	<para>
	  All tasks in the realtime system have to be performed by
	  some thread.  The OS abstraction expects an
	  <function>int ORO_main(int argc, const char** argv)</function> 
	  function (which the user has
	  written) and will call that after all system initialisation
	  has been done, meaning thread creation or setting
	  up the realtime primitives. Inside ORO_main() the user may
	  expect that the system is properly set up and can be used.
	  The resulting libtarget.a library will contain the real
	  main() function which will call the ORO_main() function.
	</para>
	<note>
	  <para>
	    Do not forget to include <filename>&lt;os/main.h&gt;</filename>
	    in the main program file, or the linker will not
	    find the ORO_main function.
	  </para>
	</note>
	<note>
	  Using global objects which use the OS functions before 
	  ORO_main() entered (because they are constructed before
	  main() ), can come into conflict with an uninitialised system.
	  It is therefor advised not to use static global objects which
	  use the OS primitives. Events in the CoreLib 
	  are an example of objects which should not be constructed 
	  as global static. Dynamic (i.e. created with new ) 
	  global events are ok.
	</note>
      </sect3> 
      <sect3>
	<title>Starting Kernel Applications</title>
	<para>
	<emphasis> Starting an application is a bit more complex in
	  the kernel (RTAI, RTLinux)</emphasis>. For a program to be
	executed in kernelspace-realtime, it has to be compiled into a
	kernel module. Each kernel module needs exactly one
	<function>init_module()</function> and
	<function>cleanup_module()</function> function call. The
	former will be called when the module is loaded, the latter
	will be called when the module is unloaded. Our policy is to
	put these functions in a <filename>module.c</filename>
	file, which will call then our real C++ functions, which
	reside in another file. 
	</para>
	<para>
	  First, a special function is called to
	  initialize all static variables your program might have.
	  When this is done the real initialisation function is
	  called. There we instantiate all objects we need, and
	  finally start the services. Each service is now running as a
	  realtime thread, using the data you provided on
	  instantiation. Be warned that when this function exits, all
	  local data is destroyed, that is why we allocate global
	  variables.
	</para>
	<note>
	  Writing kernel applications is doing it the hard way and
	  is not advised for beginners. Use RTAI/LXRT instead.
	</note>
      </sect3>    
    </sect2>
    <sect2>
      <title>The Orocos Thread System</title>
      <sect3>
	<title>Periodic Threads</title>
      <para>
	An &orocos; thread, which must execute a task periodically,
	is defined by the
	<classname>PeriodicThreadInterface</classname>. The most
	common operations are <methodname>start()</methodname>,
	<methodname>stop()</methodname> and setting the periodicity.
	What is executed is defined in the <classname>
	  RunnableInterface</classname>. It contains three methods :
	<methodname>initialize()</methodname>,
	<methodname>step()</methodname> and
	<methodname>finalize()</methodname>. You can inherit from this
	interface to implement your own functionality. In
	initialize(), you put the code that has to be executed once
	when the component is start()'ed. In step(), you put the
	instructions that must be executed periodically. In
	finalize(), you put the instructions that must be executed
	right after the last step() when the component is stop()'ed.
      </para>
      <para>
	&orocos; delivers one implementation of the
	<classname>PeriodicThreadInterface</classname> : <classname>
	  PeriodicThread</classname>, which creates a thread
	according to the operating system you are compiling for.
	However, you are encouraged <emphasis>NOT</emphasis> to use it
	! The CoreLib uses this class as a basis to provide a more
	fundamental task-based (as opposite to thread based)
	execution mechanism which allows to write applications
	more efficiently. It is provided in the corelib/task package.
      </para>
	<para>
	  Common uses are :
	  <itemizedlist>
	  <listitem>
	    <para>Running periodic control tasks.</para>
	  </listitem>
	  <listitem>
	    <para>Fetching periodic progress reports.</para>
	  </listitem>
	  <listitem>
	    <para>Running the corelib periodic tasks.</para>
	  </listitem>
	</itemizedlist>
	</para>
      </sect3>
      <sect3>
	<title>Non Periodic Threads</title>
	<para>
	  For non-periodic threads, which block or do lenghty calculations in their step() method,
	  the <classname>SingleThread</classname> class can be used.
	  The corelib/task package does not use the SingleThread.
	  Porting applications to Orocos might benifit this class
	  in a first adaptation step. It only has a start()
	  method, which will provoke one single call to step() (see
	  above). It can be re-started each time the step
	  function returns. The initialise() and finalise() functions
	  are called as above.
	</para>
	<para>
	  Common uses are :
	  <itemizedlist>
	  <listitem>
	    <para>Listening for data on a network socket.</para>
	  </listitem>
	  <listitem>
	    <para>Reading a file or files from harddisk.</para>
	  </listitem>
	  <listitem>
	    <para>Waiting for user input.</para>
	  </listitem>
	</itemizedlist>
	</para>
	<para>
	  The user of this class must be aware that he must provide himself
	  the locking primitives (like ORO_OS::Mutex) to provide thread safety.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Synchronisation Primitives</title>
      <para>
	Orocos OS only provides a few synchronisation primitives,
	mainly for guarding critical sections.
      </para>
      <sect3>
	<title>Mutexes</title>
	<para>
	  There are two kinds of Mutexes : <classname>Mutex</classname>
	  and <classname>MutexRecursive</classname>. To lock a mutex, it
	  has a method <methodname>lock()</methodname>, to unlock, the method is <methodname>unlock()</methodname> and to
	  try to lock, it is <methodname>trylock()</methodname>.
	  A lock() and trylock() on a recursive mutex from the same
	  thread will always succeed, otherwise, it blocks.
	</para>
	<para>
	  For ease of use, there is a <classname>MutexLock</classname> which
	  gets a Mutex as argument in the contstructor. As long as the
	  MutexLock object exists, the given Mutex is locked. This is
	  called a scoped lock.
	</para>
	<example>
	  <title>Locking a Mutex</title>
	  <para>The first listing shows a complete lock over a function :</para>
	  <programlisting>
  Mutex m;
  void foo() {
     int i;
     MutexLock lock(m);
     // m is locked.
     // ...
  } // when leaving foo(), m is unlocked.
	  </programlisting>
	  <para>
	    Any scope is valid, so if the critical section is smaller than
	    the size of the function, you can :
	  </para>
	  <programlisting>
  Mutex m;
  void bar() {
     int i;
     // non critical section
     {
        MutexLock lock(m);
        // m is locked.
        // critical section
     } //  m is unlocked.
     // non critical section
     //...
  }
	  </programlisting>
	</example>
      </sect3>
      <sect3>
	<title>Signals and Semaphores</title>
	<para>
	  Orocos does not provide a semaphore abstraction. The higher level
	  Event implementation in CoreLib can be used for thread safe signalling and
	  data exchange.
	</para>
      </sect3>
    </sect2>
  </sect1>
</article>
