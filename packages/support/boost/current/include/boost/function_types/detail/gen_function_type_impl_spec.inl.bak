
// (C) Copyright Tobias Schwinger
//
// Use modification and distribution are subject to the boost Software License,
// Version 1.0. (See http://www.boost.org/LICENSE_1_0.txt).

#ifndef BOOST_PP_IS_ITERATING
//------------------------------------------------------------------------------
#   include <boost/preprocessor/cat.hpp>
#   include <boost/preprocessor/arithmetic/inc.hpp>
#   include <boost/preprocessor/arithmetic/dec.hpp>
#   include <boost/preprocessor/punctuation/comma.hpp>
#   include <boost/preprocessor/facilities/identity.hpp>
#   include <boost/preprocessor/iteration/local.hpp>
#   include <boost/preprocessor/iteration/iterate.hpp>
#   include <boost/preprocessor/repetition/enum_params.hpp>
#   include <boost/preprocessor/repetition/enum_shifted_params.hpp>
#   include <boost/preprocessor/repetition/enum_trailing_params.hpp>
//------------------------------------------------------------------------------
#   define BOOST_PP_ITERATION_PARAMS_1 \
      (3,(0,BOOST_FT_MAX_ARITY,BOOST_FT_FRAGMENT(function_type_impl_spec,N_Ts)))
#   include BOOST_PP_ITERATE()
//------------------------------------------------------------------------------
#else // ndef } BOOST_PP_IS_ITERATING { def
//------------------------------------------------------------------------------
#   ifndef i // +1 == ii == N_Ts 
//------------------------------------------------------------------------------
#     define i BOOST_PP_FRAME_ITERATION(1)
#     define ii BOOST_PP_INC(i)
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
      #define k function
      #define t(x) R x (BOOST_PP_ENUM_PARAMS(i,T))
      #include BOOST_FT_FRAGMENT(function_type_impl_spec,specialization body) 
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#     if ii >= 2 // member function pointers must have at least two sub types
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#       define k member_function_pointer 
#       define t(x) R (T0::*x)(BOOST_PP_ENUM_SHIFTED_PARAMS(i,T))
#       include BOOST_FT_FRAGMENT(function_type_impl_spec,specialization body) 

#       define k const_member_function_pointer
#       define t(x) R (T0::*x)(BOOST_PP_ENUM_SHIFTED_PARAMS(i,T)) const
#       include BOOST_FT_FRAGMENT(function_type_impl_spec,specialization body)

#       define k volatile_member_function_pointer 
#       define t(x) R (T0::*x)(BOOST_PP_ENUM_SHIFTED_PARAMS(i,T)) volatile
#       include BOOST_FT_FRAGMENT(function_type_impl_spec,specialization body) 

#       define k const_volatile_member_function_pointer 
#       define t(x) R (T0::*x)(BOOST_PP_ENUM_SHIFTED_PARAMS(i,T)) const volatile
#       include BOOST_FT_FRAGMENT(function_type_impl_spec,specialization body)
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#     endif // ii >= 2
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#     undef ii
#     undef i
//------------------------------------------------------------------------------
#   else // specialization body
//------------------------------------------------------------------------------
#     define s(i) BOOST_PP_CAT(itr,BOOST_PP_IF(i,BOOST_PP_DEC(i),R))
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
template<typename S>
struct function_type_impl<k, S, ii>
{
  template<typename R BOOST_PP_ENUM_TRAILING_PARAMS(i,typename T)>
  struct synthesize
  {
    typedef t(type);
  };
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Create sub types iterators
#     define BOOST_PP_LOCAL_LIMITS (0,i)
#     define BOOST_PP_LOCAL_MACRO(j) \
  typedef typename BOOST_PP_IF(j, \
    mpl::next<s(BOOST_PP_DEC(j))>, mpl::begin<S>) :: type s(j);
#     include BOOST_PP_LOCAL_ITERATE()
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
  // Dereference sub type iterators and use with synthesize template
  typedef typename 
    synthesize

#     define BOOST_PP_LOCAL_LIMITS (0,i)
#     define BOOST_PP_LOCAL_MACRO(j)  \
  BOOST_PP_IF(j,BOOST_PP_COMMA,BOOST_PP_IDENTITY(<))() \
    typename mpl::deref< s(j) >::type
#     include BOOST_PP_LOCAL_ITERATE() 

    >::type 
  type; 
};
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#     undef t
#     undef k
#     undef s
// - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
#   endif
//------------------------------------------------------------------------------
#endif // def BOOST_PP_IS_ITERATING
