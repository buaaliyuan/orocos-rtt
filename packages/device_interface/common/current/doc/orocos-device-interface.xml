<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY rtai        "<acronym>RTAI</acronym>">
<!ENTITY rtos        "<acronym>RTOS</acronym>">
]
>

<book>
  <bookinfo>
    <title>Orocos Hardware Device Interface</title>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>

      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
      
      <author>
	<firstname>Panagiotis</firstname>
	<surname>Issaris</surname>
	<affiliation>
	  <orgname>K.U.Leuven</orgname>
	  <address><country>Belgium</country></address>
	</affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <holder>Peter Soetens, Herman Bruyninckx</holder>
    </copyright>

    <abstract>
      <para>
	This document provides a short introduction to the
	&orocos; Hardware Device Interface definitions. These
	are a collection of classes making abstraction of
	interacting with hardware components.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.1</revnumber>
	<date>18 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Initial document copied from core documentation.</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>

  <chapter>
    <title>Introduction</title>
    <sect1>
      <title>The Orocos Device Interface (<acronym>DI</acronym>)</title>
      <para>
	Designing portable software which should interact with
	hardware is very hard. Some efforts, like <ulink
	  url="http://http://stm.lbl.gov/comedi/"> Comedi</ulink>
	propose a generic interface to communicate with a certain kind
	of hardware (mainly analog/digital IO). This allows us to
	change hardware and still use the same code to communicate
	with it.  Therefore, we aim at supporting every Comedi
	supported card.  We invite you to help us writing a C++
	wrapper for this API and port comedilib (which adds more
	functionality) to the realtime kernels.
      </para>
      <para>
	We do not want to force people into using Comedi, and most of
	us have home written device drivers.  To allow total
	implementation independence, we are writing a C++ device
	interface hierarchy (a part of the Orocos Object Hierarchy)
	which just defines which functionalities a generic device
	driver should implement. It is up to the developers to wrap
	their C device driver into a class which implements this
	interface. You can find an example of this in the devices
	package.  The core only contains the interface header files.
	Other packages should always point to these interface files
	and never to the real drivers actually used.  It is up to the
	application writer to decide which driver will actually be
	used.
      </para>
      <para> <emphasis>STRUCTURE</emphasis> The FDI can be structured
	in two major parts : <emphasis>physical</emphasis> device
	interfaces and <emphasis>logical</emphasis> device interfaces.
	Physical device interfaces can be subdivided in four basic
	interfaces: Analog Input, Analog Output, Digital Input,
	Digital Output. The major difference is that analog devices
	are addressed with a channel as parameter and write a ranged
	value, while digital devices are addressed with a bit number
	as parameter and a true/false value. Logical device interfaces
	represent the entities humans like to work with: a drive, a
	sensor, an encoder, etc. They put <emphasis>semantics</emphasis> on top
of the physical interfaces they use underneath. You just want to know the
	position of a positional encoder in radians for example.
	Often, the physical layer is device dependent (and thus
	non-portable) while the logical layer is device independent.
      </para>
      <para> 
	<figure><title>Device Interface Overview</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="fdi.png" format="PNG"/>
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="fdi.eps" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </para>
      <para> <emphasis>EXAMPLE</emphasis> An example of the
	interactions between the logical and the physical layer is the
	logical encoder with its physical counting card. An encoder is
	a physical device keeping track of the position of an axis of
	a robot or machine. The programmer wishes to use the encoder
	as a sensor and just asks for the current position. Thus a
	logical encoder might choose to implement the
	<interfacename>SensorInterface</interfacename> which provides
	a <methodname>read(ReadType &amp; )</methodname> function.
	Upon construction of the logical sensor, we supply the real
	device driver as a parameter. This device driver implements
	for example <interfacename>AnalogInInterface</interfacename>
	which provides <methodname>read(ReadType &amp; data, unsigned
	  int chan)</methodname> and allows to read the position of a
	certain encoder of that particular card. Of course, we could
	also put a simulation of an encoder in place of the device
	driver for testing purposes.
      </para>
      <para>
	<figure><title>(insert example-picture here)</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="example.png" format="PNG"/>
	    </imageobject>
	    <imageobject>
	      <imagedata fileref="example.png" format="EPS"/>
	    </imageobject>
	  </mediaobject>
	</figure>
      </para>
    </sect1>
    <sect1>
      <title>Name Serving</title>
      <para>
	Name Serving is introduced in the Orocos CoreLib documentation.
      </para>
      <para>
	The FDI provides name serving on interface level. This means
	that one can ask a certain interface by which objects it is
	implemented and retrieve the desired instance. No casting
	whatsoever is needed for this operation. For now, only the
	physical device layer can be queried for entities, since
	logical device drivers are typically instantiated where
	needed, given an earlier loaded physical device driver.
      </para>
      <para>
	<xref linkend="example_name_service"/> shows how one could query the 
	<classname>AnalogOutInterface</classname>.
	  
	<example id="example_name_service"><title>Using the name service</title>
	    
	  <programlisting>
	    <![CDATA[
	    unsigned int pos;
	    new FancyCard("CardName"); // FancyCard implements AnalogOutInterface
	    AnalogOutInterface* card = AnalogOutInterface::nameserver.getObject("CardName");
	    card->read(pos, 0);    // Read some data
	    delete card;
	    ]]>
	  </programlisting>
	</example>
      </para>
    </sect1>
  </chapter>
    <chapter>
    <title>The Orocos Object Hierarchy</title>
    <para>
      It is our aim to gradually build a common class hierarchy in the
      project describing the interfaces of data structures or devices.
      This will allow our applications to share the same data format
      and thus communicate efficiently.
    </para>
  </chapter>
</book>
