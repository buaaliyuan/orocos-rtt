<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.4//EN"
"http://www.oasis-open.org/docbook/xml/4.4/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.ac.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title> Orocos Generic Hardware Control Kernel Components</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002-2006</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	Generic Hardware Access ControlKernel components.
      </para>
    </abstract>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation, with no Invariant Sections, with no
	Front-Cover Texts, and with no Back-Cover Texts. A copy of
	this license can be found at <ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>
  </articleinfo>
  <sect1>
    <title>Introduction</title>
    <para>
      This package depends on the interfaces defined in the 
      Orocos Device Interface and implementations of the
      Orocos Device Drivers package. They must be installed together
      with the Orocos Control Kernel package and the Corelib.
    </para>
  </sect1>
  <sect1 id="generic-sens-eff">
    <title>Generic Hardware Abstraction</title>
    <para>
      This section explains how hardware sensors and outputs
      are abstracted using these Components in the Control
      Kernel Framework. They allow to do a quick test of
      existing device drivers, accessing them from a 
      Control Kernel. They are not aimed to a specific
      application and the signals are propagated in
      a simulink-like (thus without much semantical
      meaning attached) way in 'channels'.
    </para>
    <sect2>
      <title>GenericSensor : Sensor Hardware Abstraction</title>
      <para>
	The Generic Sensor knows two fundamental
	types of sensors : Analog Inputs and Digital Inputs.
	Multichannel Analog and Digital input cards are defined
	in the Device Interface package, while the logical
	representation of an Analog Input and Digital Input
	are implemented in the Device Driver package.
      </para>
      <para>
	The Sensor provides methods to add Analog and
	Digital Inputs.
      </para>
      <sect3>
	<title>Creating a GenericSensor Component</title>
	<para>
	  The <classname>ORO_ControlKernel::GenericSensor</classname> is created like all
	  the other components in the control framework :
	  <programlisting>
  GenericSensor   hardw_sens(NUM_CHANS);
	  </programlisting>
	  Where NUM_CHANS is the maximal number of channels
	  this Sensor exposes (see later).
	</para>
      </sect3>
      <sect3>
	<title>Adding and Removing an Analog Input</title>
	<para>
	  An unlimited number of Analog Inputs can be added
	  to the GenericSensor :
	  <programlisting>
  int A_CHANNEL_1 = 1;
  hardw_sens.addAnalogInput("AIn_1", analog_input_card, A_CHANNEL_1 );
	  </programlisting>
	  This methods adds a DataObjectInterface&lt;double&gt; object
	  with the name "AIn_1" to the Inputs, which
	  is updated from an analog_input_card on channel A_CHANNEL_1.
	  The analog_input_card must implement the <classname>
	  ORO_DeviceInterface::AnalogInInterface</classname>.
	  If there is already an "AIn_1" DataObject, addAnalogInput
	  returns false.
	</para>
	<para>
	  The <classname>ORO_DeviceDriver::AnalogInput</classname> can also be read from an Orocos
	  Program Script or State Description :
	  <programlisting>
  var double result = GenericSensor.value("AIn_1")
  var int    raw_result = GenericSensor.rawValue("AIn_1")
	  </programlisting>
	</para>
	<para>
	  It can be removed with the following method call :
	  <programlisting>
  hardw_sens.removeAnalogInput("AIn_1");
	  </programlisting>
	  Which removes the "AIn_1" DataObject from the Inputs
	  DataObjects.
	</para>
      </sect3>
      <sect3>
	<title>Using Virtual Channels</title>
	<para>
	  Analog Outputs can be ordered in a virtual channels DataObject.
	  This allows a more generic way of accessing the DataObjects
	  in the other components. The Channel DataObject which is
	  created is of the type
	  <classname>DataObjectInterface&lt; std::vector&lt;double&gt; &gt;</classname>
	  and has the name "ChannelValues". AnalogInputs
	  can be added to a channel in this vector :
	  <programlisting>
  int A_VIRT_CHAN = 1;
  int A_CHANNEL   = 5;
  hardw_sens.addChannel(A_VIRT_CHAN, analog_input_card, A_CHANNEL );
	  </programlisting>
	  Which demonstrates that channel 5 of the <classname>ORO_DeviceInterface::AnalogInInterface</classname>
	  is inserted in position 1 of the Channel DataObject. If this
	  channel was already taken, addChannel returns false;
	</para>
	<para>
	  Removing a virtual channel is quite straightforward :
	  <programlisting>
  hardw_sens.removeChannel( A_VIRT_CHAN );
	  </programlisting>
	</para>
	<para>
	  The Process Control Components in the control_kernel_components/process_control
	  package use virtual channels for their operations.
	</para>
      </sect3>
      <sect3>
	<title>Adding Digital Inputs</title>
	<para>
	  Digital Inputs are not introduced in DataObjects, as digital
	  signal processing is done in the PLC-like Execution Engine.
	  The GenericSensor exposes the Digital Inputs to the 
	  <classname>ORO_ControlKernel::ExecutionExtension</classname> of the Control Kernel.
	</para>
	<para>
	  A <classname>ORO_DeviceDriver::DigitalInput</classname> is added as such :
	  <programlisting>
  int D_CHANNEL = 2;
  hardw_sens.addDigitalInput("DIn_1", digital_input_card, D_CHANNEL );
	  </programlisting>
	  Which is very similar to adding an Analog Input. However,
	  behind the scenes, no DataObject is created. The GenericSensor
	  exposes this Input through the methods :
	  <programlisting>
  bool result = hardw_sens.isOn("DIn_1");
	  </programlisting>
	  Or in a program or state script :
	  <programlisting>
  var bool result = GenericSensor.isOn("DIn_1")
	  </programlisting>
	</para>
      </sect3>
      <sect3>
	<title>Loading the GenericSensor</title>
	<para>As usual, the component needs to be loaded in the Control Kernel
	before it can be used :
	</para>
	<programlisting>
StandardControlKernel&lt;> myKernel;
myKernel.loadSensor( &amp;hardw_sens );	</programlisting>
	<para>
	  As long as the kernel is not running, new inputs may be added,
	  which will trigger an automatic reinitialisation of all the DataObjects,
	  such that the new inputs become visible.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>GenericEffector : Effector Hardware Abstraction</title>
      <para>
	The <classname>ORO_ControlKernel::GenericEffector</classname> is very similar to the GenericSensor, but
	analog/digital inputs are replaced by the ouputs counterparts.
	The GenericEffector reads from the Outputs DataObject.
      </para>
      <sect3>
	<title>Creating a GenericEffector</title>
	<para>
	  This is analogous to creating a GenericSensor :
	  <programlisting>
  GenericEffector hardw_eff(NUM_CHANS);
	  </programlisting>
	  Whrere NUM_CHANS is the maximum number of channels read from
	  the "ChannelValues" DataObject.
	</para>
      </sect3>
      <sect3>
	<title>Adding and Removing Analog Outputs</title>
	<para> Analogous to the GenericSensor :
	  <programlisting>
  int A_CHANNEL_1 = 1;
  hardw_eff.addAnalogOutput("AOut_1", analog_output_card, A_CHANNEL_1 );
	  </programlisting>
	  This methods <emphasis>expects</emphasis>
	  a DataObjectInterface&lt;double&gt; object
	  with the name "AOut_1" in the Outputs, so it must be
	  created by the Controller Component. The GenericEffector
	  will check the existence of this DataObject in its
	  componentStartup method (thus when it is started).
	  The analog_output_card must implement the <classname>
	  ORO_DeviceInterface::AnalogOutInterface</classname>.
	  If there is already an "AOut_1" DataObject, addAnalogOutput
	  returns false.
	</para>
	<para>
	  The <classname>ORO_DeviceDriver::AnalogOutput</classname> can also be read from an Orocos
	  Program Script or State Machine :
	  <programlisting>
  var double result = GenericEffector.value("AOut_1")
  var int    raw_result = GenericEffector.rawValue("AOut_1")
	  </programlisting>
	  Writing to DataObjects is not allowed, and can
	  only be done by the Controller Component.
	</para>
	<para>
	  It can be removed with the following method call :
	  <programlisting>
  hardw_sens.removeAnalogOutput("AOut_1");
	  </programlisting>
	  This does not remove the AOut_1 DataObject, it just
	  does no longer use it.
	</para>
      </sect3>
      <sect3>
	<title>Using Virtual Channels</title>
	<para>
	  Analog Outputs can be read from a virtual channels DataObject.
	  The GenericEffector <emphasis>expects</emphasis> a
	  <classname>DataObjectInterface&lt; std::vector&lt;double&gt; &gt;</classname>
	  DataObject in the Outputs with the name "ChannelValues".
	  Analog Outputs can be read from this vector :
	  <programlisting>
  int A_VIRT_CHAN = 1;
  int A_CHANNEL   = 5;
  hardw_eff.addChannel(A_VIRT_CHAN, analog_output_card, A_CHANNEL );
	  </programlisting>
	  Which demonstrates that channel 5 of the <classname>ORO_DeviceInterface::AnalogOutInterface</classname>
	  is set to the value of virtual channel 1.
	  If this virtual 
	  channel was already taken, addChannel returns false;
	</para>
	<para>
	  Removing a virtual channel is again quite straightforward :
	  <programlisting>
  hardw_eff.removeChannel( A_VIRT_CHAN );
	  </programlisting>
	</para>
	<para>
	  The Process Control Components in the control_kernel_components/process_control
	  package use virtual channels for their operations.
	</para>
      </sect3>
      <sect3>
	<title>Adding Digital Outputs</title>
	<para>
	  Digital Outputs are not read from DataObjects, as digital
	  signals are set in the Execution Engine.
	  The GenericEffector exposes the Digital Outputs to the 
	  Execution Extension of the Control Kernel.
	</para>
	<para>
	  A Digital Output is added as such :
	  <programlisting>
  int D_CHANNEL = 2;
  hardw_eff.addDigitalOutput("DOut_1", digital_output_card, D_CHANNEL );
	  </programlisting>
	  Which is again analogous to the GenericSensor. The GenericEffector
	  exposes this Output through the methods :
	  <programlisting>
  hardw_eff.switchOn("DOut_1");
  bool result = hardw_eff.isOn("DOut_1");
  harw_eff.switchOff("DOut_1");
	  </programlisting>
	  Or in a program or state script :
	  <programlisting>
  do GenericEffector.switchOn("DOut_1")
  var bool result = GenericEffector.isOn("DOut_1")
  do GenericEffector.switchOff("DOut_1")
	  </programlisting>
	</para>
      </sect3>
      <sect3>
	<title>Loading the GenericEffector</title>
	<para> This is analogous to the GenericSensor :
	</para>
	<programlisting>
  StandardControlKernel&lt;> myKernel;
  myKernel.loadEffector( &amp;hardw_eff );	</programlisting>
	<para>
	  As long as the kernel is not running, new outputs may be added,
	  which will trigger an automatic reinitialisation of all the DataObjects,
	  such that the new outputs become visible.
	</para>
      </sect3>
    </sect2>
  </sect1>
  <sect1>
    <title>Using the GenericEffector and GenericSensor</title>
    <para>
      The <classname>ORO_ControlKernel::GenericEffector</classname> 
      and <classname>ORO_ControlKernel::GenericSensor</classname> allow for a quick test of the
      available hardware. An example can be found in the
      <filename>kernel_samples/hardware_components</filename> directory.
      A <classname>ORO_ControlKernel::SignalGenerator</classname> or
      <classname>ORO_ControlKernel::SignalTracker</classname> with a
      <classname>ORO_ControlKernel::FeedForwardController</classname> can be used to generate
      a signal on an analog ouput, or replicate a signal on an analog input.
      These components can be found in the
      signal_processing and process_control packages.
    </para>
    <example>
      <title>Control Kernel Layout with GenericSensor and GenericEffector</title>
      <para>
	This example shows how a <emphasis>minimal</emphasis> kernel configuration can work with these
	two components :
      </para>
      <programlisting>
  #include &lt;kernel_components/PID_Controller.hpp>
  #include &lt;kernel_components/SignalGenerator.hpp>
  #include &lt;kernel_components/GenericSensor.hpp>
  #include &lt;kernel_components/GenericEffector.hpp>
  #include &lt;control_kernel/StandardControlKernel.hpp>
  #include &lt;control_kernel/KernelConfig.hpp>
  #include &lt;corelib/TaskPreemptible.hpp>

  using namespace ORO_ControlKernel;

  int ORO_main() {
    int MAX_CHANNELS = 16;
    <classname>ORO_ControlKernel::StandardControlKernel</classname>&lt;> kernel;
    <classname>ORO_ControlKernel::PID_Controller</classname> pid(MAX_CHANNELS);
    <classname>ORO_ControlKernel::SignalGenerator</classname> gen(MAX_CHANNELS);
    <classname>ORO_ControlKernel::GenericSensor</classname>   hardw_sens(MAX_CHANNELS);
    <classname>ORO_ControlKernel::GenericEffector</classname> hardw_eff(MAX_CHANNELS);

    kernel.loadController( &amp;pid );
    kernel.loadGenerator( &amp;gen );
    kernel.loadEffector( &amp;hardw_sens );
    kernel.loadSensor( &amp;hardw_eff );

    // configure inputs/outputs as in <xref linkend="generic-sens-eff"/>
    // ...

    // configure components from cpf files :
    <classname>ORO_ControlKernel::KernelConfig</classname> kconfig( &amp;kernel );
    kconfig.configure();

    <classname>ORO_CoreLib::TaskPreemptible</classname> ktask(0.01, &amp;kernel );
    ktask.start();
   
    // wait for user interruption ...
    // ( See also <classname>ORO_Execution::TaskBrowser</classname> / <classname>ORO_Execution::TaskContext</classname> ).

    ktask.stop();
    return 0;
  }
      </programlisting>
      <para>
	The figure below shows the contents of the DataObjects of the Control Kernel
	when the GenericEffector and GenericSensor are used with a SignalGenerator
	and a PIDController component and are configured as above.
	<figure>
	  <title>Control Kernel Layout with GenericSensor and GenericEffector</title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="hardware-pattern" />
	    </imageobject>
	  </mediaobject>
	</figure>
      </para>
    </example>
  </sect1>
</article>
