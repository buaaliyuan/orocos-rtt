/***************************************************************************
  tag: Peter Soetens  Thu Apr 22 20:40:59 CEST 2004  SignalGenerator.hpp 

                        SignalGenerator.hpp -  description
                           -------------------
    begin                : Thu April 22 2004
    copyright            : (C) 2004 Peter Soetens
    email                : peter.soetens@mech.kuleuven.ac.be
 
 ***************************************************************************
 *   This library is free software; you can redistribute it and/or         *
 *   modify it under the terms of the GNU Lesser General Public            *
 *   License as published by the Free Software Foundation; either          *
 *   version 2.1 of the License, or (at your option) any later version.    *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 59 Temple Place,                                    *
 *   Suite 330, Boston, MA  02111-1307  USA                                *
 *                                                                         *
 ***************************************************************************/ 
 
#ifndef ORO_SIGNALGENERATOR_HPP
#define ORO_SIGNALGENERATOR_HPP

#include <control_kernel/DataServer.hpp>
#include <control_kernel/KernelInterfaces.hpp>
#include <signal_processing/Sine.hpp>
#include <pkgconf/control_kernel.h>
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
#include "execution/TemplateDataSourceFactory.hpp"
#include "execution/TemplateCommandFactory.hpp"
#include <control_kernel/ExecutionExtension.hpp>
#endif

#include <control_kernel/BaseComponents.hpp>
#include <control_kernel/ExtensionComposition.hpp>

#ifdef ORO_PRAGMA_INTERFACE
ORO_PRAGMA_INTERFACE
#endif

namespace ORO_ControlKernel
{
    using namespace ORO_SignalProcessing;
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
    using namespace ORO_Execution;
#endif

    /**
     * The Setpoints generated by the SignalGenerator.
     */
    struct SignalSetPoint :
        public ServedTypes< std::vector<double> >
    {
        SignalSetPoint()
        {
            this->insert(std::make_pair(0, "ChannelValues") );
        }
    };

    /**
     * @brief A Generator Component for generating all kinds of signals
     * for N channels.
     *
     * It only accepts commands through its
     * methods and not through the Command DataObject.
     * For now, it also does not read the Input or Model
     * DataObject. It only writes new SignalSetPoints
     * for each channel.
     * @ingroup kcomps kcomp_generator
     */
    class SignalGenerator
        : public Generator< Expects<NoCommand>, Expects<NoInput>, Expects<NoModel>, Writes<SignalSetPoint>, 
                            MakeFacet<KernelBaseFunction
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
                                       , ExecutionExtension
#endif
                                       >::Result >
    {
        typedef Generator< Expects<NoCommand>, Expects<NoInput>, Expects<NoModel>, Writes<SignalSetPoint>, 
                           MakeFacet<KernelBaseFunction
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
                                      , ExecutionExtension
#endif
                                      >::Result > Base;
    public:
        /**
         * @brief Create a signalgenerator with a fixed number of channels.
         */
        SignalGenerator(int num_channels =  1, const std::string& name = "SignalGenerator") 
            : Base( name ),
              max_chans("Channels", "The number of channels", num_channels)
        {
            channel.resize(max_chans);
            set_point.resize(max_chans, 0.0);

        }

        virtual bool componentLoaded() 
        {
            SetPoint->dObj()->Get("ChannelValues", setp_DObj);
            setp_DObj->Set(set_point);
            return true;
        }            
                
        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void calculate() 
        {
            int i=0;
            for( chaniter it= channel.begin(); it != channel.end(); ++it, ++i)
                if (it->enable && it->gen)
                    if ( !it->freeze )
                        set_point[i]  = it->factor * it->gen->result( TimeService::Instance()->secondsSince(it->timestamp) );
                else
                    set_point[i] = 0;
        }
            
        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void push()      
        {
            setp_DObj->Set( set_point );
        }

        /**
         * @name The SignalGenerator Commands.
         * @{
         */

        /**
         * @brief Generate a sine on a channel.
         * @param chan_num The channel to set a sine.
         * @param amplitude The amplitude of the sine.
         * @param frequence The frequence of the sine in Hz.
         * @param phase The phase shift of the sine (in degrees).
         */
        bool sine( int chan_num, double frequence, double phase )
        {
            if (chan_num >= max_chans )
                return false;
            delete channel[chan_num].gen;
            channel[chan_num].gen = new Sine( 1.0, frequence, phase * 360/(2* M_PI) ); 
            return true;
        }

        /**
         * @brief Multiply the output of a channel with a special value.
         */
        bool scaleValue( int chan_num, double factor )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].factor = factor;
            return true;
        }

        /**
         * @brief Unmute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool enableChannel( int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].freezetime = 0;
            channel[chan_num].timestamp = TimeService::Instance()->getTicks();
            channel[chan_num].enable = true;
            return true;
        }

        /**
         *  @brief Mute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool disableChannel( int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].enable = false;
            return true;
        }

        bool isEnabled( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return false;
            return channel[chan_num].enable;
        }

        bool isFrozen( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return false;
            return channel[chan_num].freeze;
        }

        /**
         * @brief Freeze or pause the output of the channel.
         *
         * It will resume
         * when unfreezed. During freeze, it keeps generating its
         * last setpoint.
         */
        bool freezeChannel( int chan_num)
        {
            // we can only freeze if the channel is enabled.
            if (chan_num >= max_chans || channel[chan_num].enable==false || channel[chan_num].freeze == true)
                return false;
            channel[chan_num].freeze = true;
            channel[chan_num].freezetime = TimeService::Instance()->getTicks();
            return true;
        }

        /**
         * @brief Unfreeze the channel, it will continue to generate
         * new setpoints.
         */
        bool unfreezeChannel( int chan_num)
        {
            // we can only freeze if the channel is enabled.
            if (chan_num >= max_chans || channel[chan_num].enable==false || channel[chan_num].freeze == false)
                return false;
            // add the frozen time to the timestamp
            channel[chan_num].timestamp += TimeService::Instance()->ticksSince( channel[chan_num].freezetime );
            channel[chan_num].freeze = false;
            return true;
        }

        /**
         * @brief Return the current setpoint of a channel.
         */
        double channelValue( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return 0;
            return set_point[chan_num];
        }

        bool isValidChannel( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return false;
            return true;
        }

        /**
         * @}
         */
        virtual bool updateProperties( const PropertyBag& bag )
        {
            /*
             * <simple name="Channels" type="integer"><value>8</value</simple>
             * <sequence>
             * <struct name="Channel" type="type_less">
             *   <simple name="Channel Nr"        type="integer"> <value>0</value></simple>
             *   <simple name="Channel Generator" type="string">  <value>sine</value></simple>
             * </struct>
             * </sequence>
             */
            return true; //decomposeProperty( max_chans, bag);
        }

#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION

        DataSourceFactoryInterface* createDataSourceFactory()
        {
            TemplateDataSourceFactory< SignalGenerator >* ret =
                newDataSourceFactory( this );
            ret->add( "channelValue", 
                      data( &SignalGenerator::channelValue, "The current value "
                            "of the channel.",
                            "Channel", "The number of the channel") );
            return ret;
        }

        bool true_gen() const { return true; }

        CommandFactoryInterface* createCommandFactory()
        {
            TemplateCommandFactory< SignalGenerator >* ret =
                newCommandFactory( this );
            ret->add( "enableChannel", 
                      command( &SignalGenerator::enableChannel,
                               &SignalGenerator::true_gen,
                               "Turn on a channel.",
                               "Channel", "The channel to turn on."
                               ) );
            ret->add( "disableChannel", 
                      command( &SignalGenerator::disableChannel,
                               &SignalGenerator::true_gen,
                               "Turn off a channel.",
                               "Channel", "The channel to turn off."
                               ) );
            ret->add( "freezeChannel", 
                      command( &SignalGenerator::freezeChannel,
                               &SignalGenerator::isFrozen,
                               "Freeze a channel.",
                               "Channel", "The channel to freeze."
                               ) );
            ret->add( "resumeChannel", 
                      command( &SignalGenerator::unfreezeChannel,
                               &SignalGenerator::isFrozen,
                               "Resume a channel.",
                               "Channel", "The channel to resume, after a freeze.", true
                               ) );
            ret->add( "scaleValue", 
                      command( &SignalGenerator::scaleValue,
                               &SignalGenerator::true_gen,
                               "Scale the output of a channel.",
                               "Channel", "The channel number.",
                               "Factor", "The scale factor."
                               ) );
            ret->add( "sine", 
                      command( &SignalGenerator::sine,
                               &SignalGenerator::true_gen,
                               "Generate a sine on a channel.",
                               "Channel", "The channel number.",
                               "Frequence", "The frequency in Hz.",
                               "Phase", "The phase in degrees"
                               ) );
            return ret;
        }
#endif

    protected:
        Property<int> max_chans;

        /**
         * Holds all info about the state of a channel.
         */
        struct Channel
        {
            Channel() : factor(1.0), enable(false), gen(0) {}
            Channel(double f, bool e, SignalGeneratorInterface* g)
                : factor(f), enable(e), gen(g) {}
            double factor;
            bool enable;
            bool freeze;
            SignalGeneratorInterface* gen;
            // the time when the signal was started
            TimeService::ticks timestamp;
            // freezetime is the accumulated frozen time
            TimeService::ticks freezetime;
        };

        typedef std::vector<Channel>::iterator chaniter;
        std::vector<Channel> channel;
        std::vector<double> set_point;
        DataObjectInterface< std::vector<double> >* setp_DObj;
    };

}

#endif
