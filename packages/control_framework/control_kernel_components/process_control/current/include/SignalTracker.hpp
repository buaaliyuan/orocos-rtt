/***************************************************************************
  tag: Peter Soetens  Thu Apr 22 20:40:59 CEST 2004  SignalTracker.hpp 

                        SignalTracker.hpp -  description
                           -------------------
    begin                : Thu April 22 2004
    copyright            : (C) 2004 Peter Soetens
    email                : peter.soetens@mech.kuleuven.ac.be
 
 ***************************************************************************
 *   This library is free software; you can redistribute it and/or         *
 *   modify it under the terms of the GNU Lesser General Public            *
 *   License as published by the Free Software Foundation; either          *
 *   version 2.1 of the License, or (at your option) any later version.    *
 *                                                                         *
 *   This library is distributed in the hope that it will be useful,       *
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of        *
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU     *
 *   Lesser General Public License for more details.                       *
 *                                                                         *
 *   You should have received a copy of the GNU Lesser General Public      *
 *   License along with this library; if not, write to the Free Software   *
 *   Foundation, Inc., 59 Temple Place,                                    *
 *   Suite 330, Boston, MA  02111-1307  USA                                *
 *                                                                         *
 ***************************************************************************/ 
 
#ifndef ORO_SIGNALTRACKER_HPP
#define ORO_SIGNALTRACKER_HPP

#include <control_kernel/DataServer.hpp>
#include <control_kernel/KernelInterfaces.hpp>
#include <control_kernel/ExtensionComposition.hpp>
#include <control_kernel/BaseComponents.hpp>
#include <control_kernel/PropertyExtension.hpp>

#include <pkgconf/control_kernel.h>
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
#include "execution/TemplateDataSourceFactory.hpp"
#include "execution/TemplateCommandFactory.hpp"
#include <control_kernel/ExecutionExtension.hpp>
#endif

#pragma interface

namespace ORO_ControlKernel
{

#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
    using namespace ORO_Execution;
#endif

    /**
     * The Model expected by the SignalTracker.
     */
    struct SignalTrackerModel :
        public ServedTypes< std::vector<double> >
    {
    };

    /**
     * The Input expected by the SignalTracker.
     */
    struct SignalTrackerInput :
        public ServedTypes< std::vector<double> >
    {
    };

    /**
     * The Commands expected by the SignalTracker.
     */
    struct SignalTrackerCommand :
        public ServedTypes< std::vector<double> >
    {
    };


    /**
     * The Setpoints generated by the SignalTracker.
     */
    struct SignalTrackerSetPoint :
        public ServedTypes< std::vector<double> >
    {
        SignalTrackerSetPoint()
        {
            this->insert(std::make_pair(0, "ChannelValues") );
        }
    };

    /**
     * @brief A Generator for tracking any input signal
     * for N channels.
     *
     * It only accepts data through its
     * data object ports. It copies a channel value from
     * Command, Model or Input DataObject to the a SetPoint
     * DataObject channel. WARNING if you try to track from different
     * DataObjects, the last one will always be used for all channels !
     *
     * The current implementation can only track one dataobject
     * at a time (so all tracked channels come from one dataobject). 
     * Interested parties can extend this implementation with
     * multi-dataobject tracking.
     * @ingroup kcomps kcomp_generator
     */
    class SignalTracker
        : public Generator< Expects<SignalTrackerInput>,
                            Expects<SignalTrackerModel>,
                            Expects<SignalTrackerCommand>,
                            Writes<SignalTrackerSetPoint>,
                            MakeFacet<KernelBaseFunction
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
                                       , ExecutionExtension
#endif
                                       >::Result >
    {
        typedef Generator< Expects<SignalTrackerInput>,
                           Expects<SignalTrackerModel>,
                           Expects<SignalTrackerCommand>,
                           Writes<SignalTrackerSetPoint>,
                           MakeFacet< KernelBaseFunction
#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION
                                      , ExecutionExtension
#endif
                                      >::Result > Base;
    public:
        /**
         * Constructor.
         */
        SignalTracker(int num_channels =  1, const std::string& name = "SignalTracker") 
            : Base( name ),
              max_chans("Channels", "The number of channels", num_channels)
        {
            channel.resize(max_chans);
            set_point.resize(max_chans);
        }

        virtual bool componentStartup()
        {
            if ( ! SetPoint->dObj()->Get("ChannelValues", setp_DObj) || int(setp_DObj->Get().size()) != max_chans )
                return false;

            return true;
        }            

        virtual void pull()
        {
            // read the tracking channels
            // we only read one DO, which might be conceived as a bug by some parties.
            if ( track_DObj )
                track_DObj->Get( track_point );
        }

        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void calculate() 
        {
            if ( track_DObj )
                {
                    for( chaniter it= channel.begin(); it != channel.end(); ++it)
                        if (it->enable)
                            set_point[ it->sink_chan ] = it->factor * track_point[ it->source_chan ];
                        else
                            set_point[ it->sink_chan ] = 0;
                }
        }
            
        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void push()      
        {
            setp_DObj->Set( set_point );
        }

        /**
         * @name The SignalTracker Commands.
         * @{
         */
        bool trackCommand( int sp_chan, int com_chan )
        {
            return track( Command->dObj(), "ChannelValues", sp_chan, com_chan );
        }

        bool trackInput( int sp_chan, int inp_chan)
        {
            return track( Input->dObj(), "ChannelValues", sp_chan, inp_chan );
        }

        bool trackModel( int sp_chan, int mod_chan)
        {
            return track( Model->dObj(), "ChannelValues", sp_chan, mod_chan );
        }

        bool isTracking(const std::string& do_name ) const
        {
            return track_DObj != 0;
        }

        /**
         * Multiply the output of a channel with a special value.
         */
        bool scaleValue( int chan_num, double factor )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].factor = factor;
            return true;
        }

        /**
         * Unmute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool enableChannel( int chan_num )
        {
            if (chan_num >= max_chans || channel[chan_num].tracker == 0)
                return false;
            channel[chan_num].enable = true;
            return true;
        }

        /**
         * Mute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool disableChannel( int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].enable = false;
            return true;
        }

        bool isEnabled( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return false;
            return channel[chan_num].enable;
        }

        /**
         * Return the current setpoint of a channel.
         */
        double channelValue( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return 0;
            return set_point[chan_num];
        }

        bool isValidChannel( int chan_num ) const
        {
            if (chan_num >= max_chans )
                return false;
            return true;
        }
        /**
         * @}
         */
        virtual bool updateProperties( const PropertyBag& bag )
        {
            /*
             * <simple name="Channels" type="integer"><value>8</value</simple>
             * <sequence>
             * <struct name="Channel" type="type_less">
             *   <simple name="Channel Nr"        type="integer"> <value>0</value></simple>
             *   <simple name="Channel Generator" type="string">  <value>sine</value></simple>
             * </struct>
             * </sequence>
             */
            //return decomposeProperty( max_chans, bag);
            return true;
        }

#ifdef OROPKG_CONTROL_KERNEL_EXTENSIONS_EXECUTION

        DataSourceFactoryInterface* createDataSourceFactory()
        {
            TemplateDataSourceFactory< SignalTracker >* ret =
                newDataSourceFactory( this );
            ret->add( "channelValue", 
                      data( &SignalTracker::channelValue, "The current value "
                            "of the channel.",
                            "Channel", "The number of the channel") );
            return ret;
        }

        bool true_gen( ) const { return true; }

        CommandFactoryInterface* createCommandFactory()
        {
            TemplateCommandFactory< SignalTracker >* ret =
                newCommandFactory( this );
            ret->add( "enableChannel", 
                      command( &SignalTracker::enableChannel,
                               &SignalTracker::true_gen,
                               "Turn on a channel.",
                               "Channel", "The channel to turn on."
                               ) );
            ret->add( "disableChannel", 
                      command( &SignalTracker::disableChannel,
                               &SignalTracker::true_gen,
                               "Turn off a channel.",
                               "Channel", "The channel to turn off."
                               ) );
            ret->add( "scaleValue", 
                      command( &SignalTracker::scaleValue,
                               &SignalTracker::true_gen,
                               "Scale the output of a channel.",
                               "Channel", "The channel number.",
                               "Factor", "The scale factor."
                               ) );
            ret->add( "trackInput", 
                      command( &SignalTracker::trackInput,
                               &SignalTracker::true_gen,
                               "Track an Input channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Input Channel", "The Input channel number"
                               ) );
            ret->add( "trackModel", 
                      command( &SignalTracker::trackModel,
                               &SignalTracker::true_gen,
                               "Track an Model channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Model Channel", "The Model channel number"
                               ) );
            ret->add( "trackCommand", 
                      command( &SignalTracker::trackCommand,
                               &SignalTracker::true_gen,
                               "Track an Command channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Command Channel", "The Command channel number"
                               ) );
            return ret;
        }
#endif

    protected:

        template < class DOS >
        bool track( DOS* dObj, const std::string& do_name, int sp_chan, int track_chan )
        {
            if ( !isValidChannel(sp_chan) || !isValidChannel(track_chan) || dObj == 0)
                return false;

            if (!dObj->has(do_name, std::vector<double>() ) )
                {
                    track_DObj = 0;
                    return false;
                }
            else
                {
                    channel[sp_chan].source_chan = track_chan;
                    channel[sp_chan].sink_chan   = sp_chan;
                    dObj->Get(do_name, track_DObj);
                    channel[sp_chan].tracker     = track_DObj;
                    return true;
                }
        } 

        Property<int> max_chans;

        /**
         * Holds all info about the state of a channel.
         */
        struct Channel
        {
            Channel() : factor(1.0), enable(false), tracker(0) {}
            Channel(double f, bool e)
                : factor(f), enable(e) {}
            double factor;
            bool enable;
            int source_chan;
            int sink_chan;
            DataObjectInterface< std::vector<double> >* tracker;
        };

        typedef std::vector<Channel>::iterator chaniter;
        std::vector<Channel> channel;
        std::vector<double> set_point;
        std::vector<double> track_point;
        DataObjectInterface< std::vector<double> >* setp_DObj;
        DataObjectInterface< std::vector<double> >* track_DObj;
    };

}

#endif
