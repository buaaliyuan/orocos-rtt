module Orocos
{
  exception LoadException
  {
    string what;
  };

  exception ParseException
  {
    string what;
  };

  interface KernelInterface
  {
    typedef sequence<string> NameList;

    // try to shutdown the server.
    // return true if accepted.
    boolean requestShutdown();

    NameList getProgramNames();

    // state machines
    NameList getStateMachineNames();

    // The filename is not needed, but it will be used to construct
    // error messages.  This function will throw a
    // file_parse_exception ( defined in
    // <execution/parse_exception.hpp> ) if parsing fails, or a
    // statemachine_load_exception ( defined in ExecutionExtension.hpp
    // ) if loading fails.
    void loadStateMachines( in string code, in string filename ) raises (LoadException, ParseException);
    boolean unloadStateMachine( in string name ) raises (LoadException);

    void loadPrograms( in string code, in string filename ) raises (LoadException);
    boolean unloadProgram( in string name ) raises (LoadException);

    // One line of log info
    string getLogLine();
    // One line of report info
    //string getReportLine();

    string getProgramText(in string name );
    string getStateText(in string name );
    string getProgramStatus(in string name );
    long getProgramLine(in string name );
    string getStateStatus(in string name );
    long getStateLine(in string name );
    string getState(in string name );

    // return the list of names of all controller components
    NameList getControllers();
    // return the list of names of all generator components
    NameList getGenerators();
    // return the list of names of all effector components
    NameList getEffectors();
    // return the list of names of all estimator components
    NameList getEstimators();
    // return the list of names of all sensor components
    NameList getSensors();
    // return the list of names of all support components
    NameList getSupports();

    // return the list of names of those components that have
    // registered either a DataSourceFactory or a CommandFactory.
    NameList getComponents();

    // return the list of commands of the given component.  Can return
    // an empty list.
    NameList getCommands( in string comp );

    // return the list of datasources of the given component.  Can
    // return an empty list.
    NameList getData( in string comp );

    // return the list of methods of the given component.  Can
    // return an empty list.
    NameList getMethods( in string comp );

    // This function parses the command or method in the given string, and
    // starts executing it.  The returned long is a unique id for
    // the executing command on success. 
    // Return -1 if it was a method, which has been invoked successfully
    // Return 0 if it was an illegal command
    // Return + if it is a successful command, which is now queued.
    long startExecutingCommand( in string code ) raises (LoadException);

    // is the command with identifier commandid ( as returned by
    // startExecutingCommand ) finished executing ?  Note that you
    // still need to call abandonCommand if the command is finished.
    boolean isCommandFinished( in long commandid );

    // stop waiting for the execution of the command with the given id
    // ( as returned by startExecutingCommand ) to complete.
    void abandonCommand( in long commandid );
  };
};
