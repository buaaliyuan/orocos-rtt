<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY control  "ControlKernel">
]
>

<book>
  <bookinfo>
    <title> The Orocos Control Kernel Manual </title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>

      <author>
        <honorific>Dr. ir</honorific>
        <firstname>Herman</firstname>
        <surname>Bruyninckx</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>

      <author>
        <firstname>Panagiotis</firstname>
        <surname>Issaris</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002</year>
      <holder>Peter.Soetens@mech.kuleuven.ac.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.ac.be</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	Control Kernel Framework.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>22 Aug 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.02</revnumber>
	<date>19 Sep 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial interface description</revremark>
      </revision>
      <revision>
	<revnumber>0.9</revnumber>
	<date>13 Nov 2002</date>
	<authorinitials>ps</authorinitials>
	<revremark>Updated for release</revremark>
      </revision>
      <revision>
	<revnumber>0.11</revnumber>
	<date>28 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Updated to reflect new control kernel
	  infrastructure</revremark>
      </revision>
      <revision>
	<revnumber>0.12</revnumber>
	<date>11 Dec 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark> Added NamesControlKernel docs</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation, with no Invariant Sections, with no
	Front-Cover Texts, and with no Back-Cover Texts. A copy of
	this license can be found at <ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </bookinfo>


  
  <chapter>
    <title>Introduction</title>
    <para>
      This chapter explains installation, and gives an overview of the
      features and interface of the &orocos; &control; module.
    </para>

    <sect1>
      <title>Installation</title>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
    </sect1>
    <sect1><title>Prerequisites</title>
      <tip>
	<para>	
	  We highly advise you to read first the Orocos CoreLib documentation before going on.
	  It explains Events, Tasks versus Threads, NameServing and many other basic
	  functionalities used in Orocos.
	</para>      
      </tip>
      <tip>
	<para>
	  This document only covers some generic use cases. If you want detailed
	  information about a class or function, read the Doxygen generated reference
	  of this package. You will find a lot of complementary
	  information in there not presented here.
	</para>
      </tip>
    </sect1>
  </chapter>
  <chapter>
    <title>Philosophy</title>
    <para>
      Making a complex realtime system 'work' is not easy without (and
      even with) well chosen guidelines which must tell the designer
      how a certain problem is best solved. Some guidlines specific
      for Control Kernel development and use are shortly described in
      this chapter.
    </para>
    <sect1>
      <title>Separating Control Flow, Data Flow and Configuration
	Flow</title>
      <para>
	When two components need to communicate, the kind of
	communication channel is dependent of the data being
	communicated. In the &orocos; framework, three distinctive
	communication flows can be recognized. All three have
	different timing constraints, different kinds of data and of
	course, different purposes. The following section explains
	these three types.
      </para>
      <sect2>
	<title>Configuration Flow</title>
	<para>
	  The first type is normally also firstly encountered when a
	  program is run. All present components, or objects in
	  general, need to be configured to suit the targetted
	  application. Configuration information can be hard coded
	  into the program, read from an XML file or given by the user
	  through a Graphical User Interface. Configuration involves a
	  mostly slow, non deterministic flow into the system. Most
	  engineers familiar with control know this and make sure that
	  all configuration flow has stopped once the control loop is
	  running. The &orocos; framework will, where possible,
	  prevent further configuration once a system is running. It
	  must be stopped, reconfigured and restarted if the user
	  whiches to reconfigure the running system. This is not
	  always acceptable (some systems can not be stopped right
	  away). The Control Flow solves this for such cases.
	</para>
	<para>The Control Kernel uses XML files for most of its
	  configuration flow.</para>
      </sect2>
      <sect2>
	<title>Data Flow</title>
	<para>
	  When a Control Kernel is constructed, it has as its main
	  purpose to gather sensor readings, do some mathematical
	  operations on that data and send the results back to the
	  effectors of the system. This cycle is done many times a
	  second and causes a changing flow of data through the
	  system. The components in the control kernel are responsible
	  for sustaining this flow : they convert one kind of data
	  into another kind. In any feedback system, data goes through
	  a set of stages before it leaves the system again. Each such
	  stage gives an intermediate meaning to the data being there.
	  The &orocos; Control Kernel identifies 5 different states
	  the data flow goes through. It is first raw Input from
	  Sensors. The Input is used to build a Model. The application
	  has data which represents a desired system state and is
	  called Command. These three can be combined to produce
	  intermediate SetPoints, which, compared with the current
	  Model and Inputs are leading to an Output which is sent to
	  the Effectors. This flow of data is unidirectional and
	  allows an efficient software implementation.
	</para>
	<para>
	  The Control Kernel uses DataObjects to store the
	  intermediate Data Flow. Special values of Data inside
	  DataObjects might trigger a state change in one of the
	  components reading them. However, triggering specific
	  actions inside a component should happen through the Control
	  Flow, and not the Data Flow. 
	</para>
      </sect2>
      <sect2>
	<title>Control Flow</title>
	<para>
	  The last kind of flow is also sometimes refered to as
	  'Command Flow'. Because of the unlucky choosen name for the
	  Command Data Object, Control Flow is a better name to
	  distinguish from this total opposite mechanism. Control Flow
	  is actually hardly a Flow. It consists of discontinuous
	  operations on the Control Kernel while it is running. These
	  operations are guaranteed to not interrupt the control
	  kernel and thus merely switch a flag or reset a parameter in
	  the running system. The Control Flow is the manifestation of
	  the users application running. Not only does the user whish
	  to control a continous system, many side actions must be
	  taken to accomplish a success. Examples are opening a
	  gripper, turning on a spindle or a coolant, instructing the
	  machine to home etc. It is obvious that such commands do not
	  belong in the Data Flow ( no matter the Command Data Object
	  might suggest).
	</para>
	<para>
	  A beginning application might give the first commands in the
	  main program function and then direct control to the user. A
	  Program Execution mechanism has been developped to parse
	  user text programs and execute the given commands in a
	  running Control Kernel. This is described in great detail in
	  the Program Execution Package of Orocos.
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Which Control Kernels and How Many ?</title>
      <sect2>
	<title>A first overview</title>
	<para>
	  A user might wonder how much Control kernels his application
	  might need. One way to see the answer is looking at the
	  following list of answers :
	  <itemizedlist>
	    <listitem>
	      <para>Do I need to control different system states at different frequencies ?
		Meaning, do i need for example, to control velocities at a different
		frequency than positions ?</para>
	    </listitem>
	    <listitem>
	      <para> Do I need to control different systems ? Meaning, do I need to control
		isolated parts, for example, 3 independent axes or an additional table.</para>
	    </listitem>
	    <listitem>
	      <para>Do I need to switch between the controlled states in a running system ? 
		Meaning, do I need
		to maintain a low level control while I switch a higher level control
		mode ?</para>
	    </listitem>
	  </itemizedlist> As you could have guessed, any yes answer on
	  the above items indicates that an additional control kernel
	  is needed.
	</para>
	<para>
	  Control Kernels can run in parallell or serial (e.g.
	  cascaded). Parallell kernels do not know of each other or
	  are consistently commanded from a higher level. When two or
	  more kernels are cascaded, The output of the higher level
	  control kernel is a command for the lower level kernel.
	  Proper locking must be provided by the control kernel when
	  both are running at different priorities. 
	</para>
      </sect2>
      <sect2>
	<title>Cascading Control Kernels</title>
	<para>
	  In most systems two or more kernels, running at different
	  frequencies and priorities, must be connected together. For
	  efficiency reasons, a cascaded higher level control kernel
	  will read the DataObjects of the low level control kernel to
	  acquire Model or Input data. It is also possible that the
	  kernels all access a common Sensor Component which provides
	  proper locking. Both are possible and have pros and cons in
	  different applications. The disadvantage of locking within
	  the common component is the lost time determinism when the
	  low priority thread gets the lock first. Another
	  disadvantage is that each common component must provide its
	  own locking mechanism. When data sharing is done through
	  DataObjects, any kind of data can be guarded against
	  concurrent access without the components knowing. This is
	  sometimes refered to as the 'monitor software pattern'.
	</para>
	<para>
	  It is the kernel's decision which kind of DataObjects are
	  used to contain the Data. A control kernel used for
	  cascading must thus make sure that the DataObject contains
	  the right locking primitives to guard data consistency. The
	  available DataObjects are discussed in the next Chapter. An
	  application builder must thus choose the control kernel
	  containing DataObjects which meet his requirements.
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter><title>The (Default) Control Kernel</title>
    <sect1>
      <title>Purpose</title>
      <para>
	Anyone wanting to write his own software (feedback) controller
	will need a control kernel to do the work. In this kernel,
	five basic responsabilities are identified and placed under
	the responsability of a Component. The responsabilities are :
	gathering sensor data (Sensor Component), estimating a model
	(Estimator Component), generating setpoints (Generator
	Component), taking a control action (Controller Component) and
	sending the outputs to the hardware (Effector Component).
	Depending on the application, other components implementations
	will be used, together with other types of data being
	exchanged. The Default Control control kernel is providing the
	infrastructure, but does not do any calculations or accesses
	no external resources. It provides infrastructure for loading
	components, exchanging data between components and defines
	what functionality the components can use (more on this later
	in the Extensions chapter).
      </para>
    </sect1>
    <sect1>
      <title>Theoretic background</title>
      <para>
	The implementation of the Control Kernel is based on the
	software pattern for control. A paper is to be published,
	which gives a high level explanation of its purpose. This
	paper is available on the &orocos; website.
      </para>
      <para>
	<ulink
	  url="http://www.orocos.org/documents/motconframe.pdf">See
	  the Control Kernel paper.</ulink>
      </para>
    </sect1>
    <sect1>
      <title>Basic Control Kernel Interfaces ( Control Kernel,
	DataObjects, Components )</title>
      <para>
	When you start thinking about a control application, you
	mostly have a control scheme at hand. This scheme identifies
	data flows from data sources (sensors) over algoriths to data
	sinks (effectors). In any application the following data must
	be passed around : Input data from sensors, Command data from
	a higher level producer, Model data representing the current
	system state, SetPoint data denoting the desired system state,
	Output data to send to the system's effectors. Identifying
	what is exactly in these five data types is the first step for
	creating a control kernel. In Orocos, these five types must be
	given as a template parameter to the DefaultControlKernel. The
	most simple invocation is when only a double is passed on
	(think one axis control):
      </para>
      <programlisting>
	#include &lt;control_kernel/DefaultControlKernel.hpp&gt;
	typedef DefaultControlKernel &lt;double, double, double, double, double&gt; My1DKernel;
      </programlisting>
      <para>
	What is shown above is defining the type My1DKernel as being a
	DefaultControlKernel where only a double is exchanged between
	each component. The meaning of the template parameters is like
	this :
      </para>
      <programlisting>
	DefaultControlKernel &lt;InputType, ModelType, CommandType, SetPointType, OutputType&gt;;
      </programlisting>
      <para>
	Which you can remember by the acronym IMCSO ;-). If that
	doesn't work, looking at the data flow (cfr the
	uni-directional graph) might help to find the correct order.
	But do not worry, you only need to do this once for your
	application. Next you can create an instance of your new
	control kernel :
      </para>
      <programlisting>
	My1DKernel first_kernel;
      </programlisting>
      <para>
	What happened is that you created a control kernel with five
	DataObjects for each DataType (being all doubles) and 5
	default components which do just nothing. Other kernels may
	define other DataObjects and/or other default components. It
	is the programmers task to replace the default components with
	'functional' components, actually doing something with the
	data. Each component can be loaded and unloaded with the
	respective method calls on the kernel.
      </para>
      <para> When one defines a control kernel one must first define
	its DataObjects. Once the control kernel type is determined (
	in the typedef ) , the DataObjects type can no longer be
	changed. This means that if you want to change the type of
	data exchanged by two components, you need to change the
	control kernel definition. This is not a big drawback for
	control applications since the data flow is in most
	applications invariant.
      </para>
    </sect1>
    <sect1>
      <title>DataObjects</title>
      <para>
	Data must be guarded against concurrent (multi-threaded)
	access, or it may be needed to fetch the data from a server or
	to instruct the data-producer to provide a new sample. All
	these actions are the responsibility of the DataObjects. They
	shield or extend data access as the control kernel requires.
	For example, a control kernel based on CORBA components will
	need DataObjects which understand CORBA, a control kernel
	running in a single thread will need no mutual exclusion at
	all and thus can use an efficient, non-locking, DataObject.
	The data guarded by the DataObjects can be any valid C++ type,
	so mostly people use classes or structs (instead of double).
	The default constructor of the data is called when the
	DataObject is constructed.
      </para>
      <para>
	A DataObject is always accessed in a generic way with
	<methodname>Get()</methodname> and
	<methodname>Set()</methodname> methods. Here is an example of
	creating and using a DataObject.
	<example>
	  <title>Accessing a DataObject</title>
	  <programlisting>
	    DataObject&lt;double&gt; my_DO; // A DataObject may also contain a class 
	    my_Do.Set( 3.14 ); 
	    double contents;
	    my_Do.Get( contents );   // contents == 3.14 contents  =
	    my_Do.Get(); // equivalent
	  </programlisting>
	</example> When in a component, the DataObject must be
	accessed through a Port of the component. This will be
	explained in the Components section.
      </para>
      <sect2>
	<title>DataObjectInterface</title>
	<para>This Interface describes the Get() and Set() methods
	  each DataObject must have. Set() and Get() copy all contents
	  of the DataObject.
	</para>
      </sect2>
      <sect2>
	<title>DataObject</title>
	<para>This is the most simple DataObject implementation. The
	  Get() and Set() methods directly map onto the contents and
	  can always be inlined by the compiler. It offers no thread
	  safety, but maximum efficiency for copying data.
	</para>
      </sect2>
      <sect2>
	<title>DataObjectLocked</title>
	<para>This is a thread safe DataObject which Set() and Get()
	  methods are guarded by a single mutex. The second thread
	  accessing this object will always block, which is not always
	  wanted in a realtime system.
	</para>
      </sect2>
      <sect2>
	<title>DataObjectPrioritySet</title>
	<para>This is a more complex DataObject which gives always
	  priority to the thread calling Set(), which will never
	  block. The thread accessing Get() will block if the Set()
	  thread is accessing the contents.It is mainly used for
	  sharing data between two kernels, running at different
	  priorities.</para>
	<note>
	  <para>This DataObject will only work if the Set() thread has
	    the highest priority. When the inverse is true, data
	    corruption will occur. It is obvious that this DataObject
	    can only be used if both threads have static priorities
	    (which is the case for all threads in the Orocos
	    framework)</para>
	</note>
      </sect2>
      <sect2>
	<title>DataObjectPriorityGet</title>
	<para>The inverse of DataObjectPrioritySet. The thread
	  accessing Get() will never block.</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Components</title>
      <sect2>
	<title>Defining your own Component</title>
	<para>As mentioned before, the DefaultControlKernel will have
	  made DefaultComponents which do nothing. The control kernel
	  is equiped with loadController(), unloadGenerator(),..
	  methods which allow a clean insertion of a new component and
	  which guarantee a clean removal of the old component.
	  Defining a Component of your own goes like this :
	</para>
	<screen>
	  #include &lt;control_kernel/DefaultControlKernel.hpp&gt;


	  template &lt; class _DefaultGenerator &gt; 
	  class MyGenerator 
	      : public _DefaultGenerator 
	  { 
	      void pull() 
	      { 
	          // ... 
	      } 
	      void calculate()
	      { 
	          // ... 
	      } 
	      void push() 
	      { 
	          // ... 
	      } 
	  };
	</screen>
	<para>What you see is that the class MyGenerator has one
	  template argument, _DefaultGenerator, which must be supplied
	  on object creation and this template argument is a base
	  class of MyGenerator. This might look a bit strange to
	  people not familiar with templates, but the aim of this
	  construct is to allow the changing of the base class of a
	  Component, without having to adjust the code each time. As
	  you can guess, the _DefaultGenerator type is supplied by the
	  kernel. You can access it like this :</para>
	<screen>
	  My1DKernel::DefaultGenerator</screen>
	<para>These types exist for all components. Of course, the
	  type is useless in that form, it must be supplied to your
	  own written component : </para>
	<screen>
	  MyGenerator&lt; My1DKernel::DefaultGenerator &gt;  my_gen;
	</screen>
	<para>The above line has created an instance of MyGenerator
	  called my_gen and which now has the DefaultGenerator as base
	  class. Since MyGenerator is a subclass of DefaultGenerator,
	  it can be used with the setGenerator() method call of the
	  DefaultControlKernel. The next line could then be :</para>
	<screen>
	  first_kernel.loadGenerator( &amp;my_gen );
	</screen>
	<para>which would cause my_gen to be loaded into the kernel.
	  To actually use this generator instead of the current one,
	  it must be selected :</para>
	<screen>
	  first_kernel.selectGenerator( &amp;my_gen );
	</screen>
	<para> Only one component per type can be selected and only a
	  previously loaded component can be selected. This is because
	  all loaded components are configured just before the control
	  kernel is running. Any component not loaded at that time
	  will not be configured by that control kernel and is thus
	  not usable when the control kernel is running. The above
	  methods are available for all components of the
	  kernel.</para>
      </sect2>
      <sect2>
	<title>Components and Name-Serving</title>
	<para>Each component can be given a name upon construction.
	  The name of a component is stored in a nameserver for each
	  kind of control kernel and for each kind of component. Each
	  type of control kernel thus causes nameservers to be created
	  for each of its component types, this allows a good
	  separation of name clashing. If a component with the same
	  name is created for the same type, only the first one will
	  show up in the nameserver. Nameserving is described in more
	  detail in the CoreLib documentation.
	</para>
	<para>
	  There are some methods that allow easy working with named
	  components. Going further with the MyKernel1D example :
	</para>
	<programlisting>
	  // One way to retrieve a previously created generator.
	  My1DKernel::DefaultGenerator* g = MyKernel1D::DefaultGenerator::nameserver.getObject("GeneratorName"); 
	  
	  // loading a previously created generator
	  first_kernel.loadGenerator( "GeneratorName" ); // and select it too. 
	  
	  if ( first_kernel.isLoadedGenerator( "GeneratorName") ) 
	       first_kernel.selectGenerator( "GeneratorName") );
	</programlisting>
      </sect2>
      <sect2>
	<title>Inserting Functionality and Algorithms</title> 
	<para>As seen in the previous section, each component you
	  write should have at least a pull(), calculate(), push()
	  method for data processing. The pull() method will Get() the
	  data objects and copy its contents to local variables, the
	  calculate() method will perform some algorithmic
	  functionality on the data and the push() method must Set()
	  the results in the next DataObject. This division is done to
	  isolate communication in different methods so that a more
	  intelligent interaction between control kernel and component
	  is possible. For example, a certain control kernel
	  implementation could only call the pull() method if new data
	  is effectively available, but always calls the
	  calculate/push() method. A practical example of this is the
	  Interpolator residing in a Generator component.</para>
	<para>A DataObject can be accessed from within the component
	  as such :</para>
	<programlisting><![CDATA[
	  // ... 
	  _DefaultGenerator::InputType localCopy;
	  _DefaultGenerator::SetPointType localResult; 
	  // ... 
	  void pull() 
	  { 
	        localCopy = _DefaultGenerator::Inputs::dObj()->Get(); 
	  } 
	  
	  void calculate()
	  { 
	        // ... calculate the setpoint 
	  } 

	  void push() 
	  {
	       _DefaultGenerator::SetPoints::dObj()->Set( localResult ); 
	  }]]>
	</programlisting>
	<para>
	  What the above means is that the DefaultGenerator has Ports
	  and one DataObject associated with each port. In the above
	  example, the Inputs and SetPoints Ports were accessed and
	  the <methodname>dObj()</methodname> call gives you a pointer
	  back to the DataObject of that Port. Next you can perform
	  the usual Set and Get operations as described in the
	  DataObject section.
	</para>
	<para>
	  The DefaultGenerator also contains the type information of
	  the data of each DataObject. InputType is the type of data
	  of the Inputs Port and SetPointType is the Type of the
	  SetPointsPort. equal names are provided for the other Ports.
	</para>
	<note>
	  <para>
	    Looking at the Software Pattern for Control, one can see
	    that not each Component has access to all DataObjects.
	    Thus, the Generator Component has no access to the Outputs
	    Port or OutputType. Trying to access these will lead to a
	    compile error. Each Component has its own set of Ports
	    which is fixed.
	  </para>
	</note>
	<sect3>
	  <title>Good Use Rules for DataObjects</title>
	  <para>
	    These methods are used for the Data-Flow of the kernel.
	    You copy data from one component to the other, purely for
	    doing calculations, not doing configurations. If you want
	    to configure/modify a component, you must add a method
	    call to it, which does the action. An example is a method
	    to turn off the D action of a PID Controller Component.
	    The wrong way to do this is to insert a 'bool' member in
	    the SetPointType to indicate if the D action should be
	    enabled. The correct way is to provide a method. If it
	    must be switched off dynamically, an Event can be created
	    which is fired by the component (Generator, Estimator or
	    even an external object) which demands that the D action
	    must be stopped.  The Controller can locate this Event and
	    register the disable/enable-method as a handler. How this
	    is practically done is described later.
	  </para>
	  <para>
	    Fortunately, a Template file is provided from which you
	    can copy/paste to start writing your own components. This
	    file is called <filename>ComponentTemplates.hpp</filename>
	    and is provided with this package. You will see that for
	    each component different DataObjects can be accessed and
	    different types will be defined to facilitate that access.
	  </para>
	</sect3>
      </sect2>
      <sect2>
	<title>Standard Control Kernel Events and Hooks</title>
	<para>
	  A component might be interested in the fact if it is
	  inserted in a control kernel and if this control kernel is
	  running or not. A control kernel might possibly do an init-
	  run of the components so that the member variables can be
	  initialised correctly, with sensor readings for example. All
	  these actions are quite standard for every component and
	  kernel. For each such action, an Event is created by the
	  control kernel which will be fired by the control kernel
	  when it occurs. When the action must be executed in a
	  defined order, a hook ( this is a virtual function in a
	  component ) will be provided instead. This is because Events
	  do not allow ordered notification.
	</para>
	<para>
	  To summarize, each control kernel has some Events to which
	  each component can subscribe. As an alternative, some Events
	  have a method counterpart which can be overriden. This
	  method is guaranteed to be called when the Event occurs
	  (together with all the registered handlers).
	</para>
	<para>Each DefaultComponent (and thus each component you will
	  insert into the kernel) is a subclass of the
	  <classname>ComponentBaseInterface</classname>, which is
	  defined in the file
	  <filename>KernelInterfaces.hpp</filename>. This interface
	  allows each component to locate the control kernel in which
	  it is loaded by the kernel() method returns a pointer to the
	  <classname>KernelBaseFunction</classname>, which is the base
	  class of each kernel. The
	  <classname>ComponentBaseInterface</classname> defines the
	  methods you can override, the
	  <classname>KernelBaseFunction</classname> interface allows
	  you to access the Standard Control Kernel Events. We refer
	  to the Doxygen API documentation for the full documentation
	  of these interfaces. The Events document explains how Events
	  work and how a handler can be added.
	</para>
	<para>
	      The following hooks are available for each Component to
	  fill in :
	      <table>
	    <title>ComponentBaseInterface Hooks</title>
	    <tgroup cols="2">
	      <tbody>
		<row>
		      <!-- one of (entrytbl entry) -->
		  <entry>virtual void componentLoaded() {}</entry>
		  <entry>Called when the component is loaded into the
		    kernel.</entry>
		</row>
		<row>
		      <!-- one of (entrytbl entry) -->
		  <entry>virtual void componentUnloaded() {}</entry>
		  <entry>Called when the component is unloaded from
		    the kernel.</entry>
		</row>
		<row>
		      <!-- one of (entrytbl entry) -->
		  <entry>virtual void componentStartUp() {}</entry>
		  <entry>
		    Called when the control kernel is started and all
		    components are initialised. The component must
		    write meaningful information to its data objects
		    and is guaranteed to find meaningfull information
		    in its readable data objects.
		  </entry>
		</row>
		<row>
		      <!-- one of (entrytbl entry) -->
		  <entry>virtual void componentShutdown() {}</entry>
		  <entry>
		    Called when the control kernel is stopped and all
		    components should return to a safe off-state.
		  </entry>
		</row>
	      </tbody>
	    </tgroup>
		<!-- one of (graphic mediaobject tgroup) -->
	      </table>
	</para>
	<para>The following image explains the life cycle of a typical
	  component. 
	  <figure><title>Component Life Cycle</title>
	    <mediaobject>
	      <imageobject role="html">
		<imagedata fileref="component_life_cycle.png" format="PNG"/>
	      </imageobject>
	      <imageobject role="fo">
		<imagedata fileref="component_life_cycle.eps" format="EPS"/>
	      </imageobject>
	    </mediaobject>
	  </figure>
	      The state the component is in is entirely dependent on the control kernel state.
	      How control kernel methods change a components state is shown below.
	      <figure><title>Control Kernel - Component Interaction</title>
		<mediaobject>
		  <imageobject role="html">
		    <imagedata fileref="kernel_component_interaction.png" format="PNG"/>
		  </imageobject>
		  <imageobject role="fo">
		    <imagedata fileref="kernel_component_interaction.eps" format="EPS"/>
		  </imageobject>
		</mediaobject>
	      </figure>
	</para>
      </sect2>
    </sect1>
  </chapter>
  <chapter>
    <title>Multiple DataObjects per Port : NameServed
      DataObjects</title>
    <para>It is possible to access more than one DataObject of different
      types through a Read or Write Port.</para>
    <sect1>
      <title>Introduction</title>
      <para>
	As the previous chapter explained, there are some problems
	with de DefaultControlKernel with respect to its DataObjects. 
	The disadvantages are listed again :
	<itemizedlist>
	  <listitem>
	    <para>Only one entity (component) can write to a default
	  DataObject, or data can be overwritten by others.</para></listitem>
	  <listitem>
	    <para>There is no safe encapsulation within a DataObject,
	  it must always be accessed as a whole.</para></listitem>
	  <listitem>
	    <para>It is not flexible since the listitems of the
	  DataObject are referenced directly by the variable name,
	  instead of some abstraction means.</para></listitem>
	</itemizedlist>
	The advantages of the DefaultControlKernel are :
	<itemizedlist>
	  <listitem>
	    <para>It is easy to use and understand.</para></listitem>
	  <listitem>
	    <para>It has almost zero overhead for small kernels.</para></listitem>
	</itemizedlist>
      </para>
      <para> The NamesControlKernel aims to solve the disadvantages
	by introducing nameserving on DataObject member level and
	tries to keep the advantages of the former too. 
      </para>
      <para>
	The NamesControlKernel allows the user to compose
	their DataObjects out of different types. Each type,
	being it int, Frame, vector,... can have several instances
	with each their own name in the DataObject. In addition,
	the user can choose to still use the not-nameserved (unserved)
	type as in the DefaultControlKernel. But that is optional.
      </para>
      <para>The overhead is only little. The lookup (resolving)
	of the names can happen at startuptime, and from then on,
	the resolved DataObject can be used. To avoid name clashes,
	the server only looks in the scope of the current kernel.
	This means a component can not automatically access DataObjects
	from another kernel.
      </para>
    </sect1>
    <sect1>
      <title>Constructing a Nameserved DataType</title>
      <para>
	In the previous chapters, DataTypes were constructed with
	placing all data to be exchanged in a class. This has
	changed now. An example explains best :
      </para>
      <example>
	  <title>A Nameserved DataType</title>
	  <para>
	    Imaging that you want to specify what is in
	    the model of your kernel :
	  </para>
	  <programlisting> <![CDATA[
	    struct MyNamesModel 
	         : public ServedTypes<Frame, double>, public UnServedType<>
	    {
	         MyModel()
	         {
                      this->insert( make_pair(0, "EndPosition"));
                      this->insert( make_pair(0, "OldPosition"));
                      this->insert( make_pair(1, "Temperature"));
	         }
	    };
	    ]]>
	  </programlisting>
	</example>
      <para> 
	In the ServedTypes list, you can specify zero up to
	ten different types which you want to nameserve. Each type
	may only occur once in that list. The empty list (you don't
	want to nameserve any type is denoted by ServedTypes&lt;&gt;.
	You can only have one UnServedType, which is empty in the
	example. This is the DataObject you get when you call the
	old Get() method like in the DefaultControlKernel.
      </para>
      <para>
	The next important part is the constructor. The user must use
	the insert function to insert a pair of (number, string) for
	each object he wants to be created. The number denotes the
	nth type listed in ServedTypes&lt;...&gt;, starting from zero.
	In the example, two Frames are created, with each their own
	name and one double, which holds the temperature. The number
	of objects created with insert() is not restrained. The
	number of ServedTypes is.
      </para>
      <para> 
	You must do this for all five datatypes of the NamesControlKernel,
	just like you did with the DefaultControlKernel. Once the five
	classes are defined, one can define the kernel :
      </para>
      <programlisting>
	#include &lt;control_kernel/NamesControlKernel.hpp&gt;
	typedef NamesControlKernel &lt;MyNamesInput, MyNamesModel, MyNamesCommand, MyNamesSetPoint, MyNamesOutput&gt; MyNamesKernel;
      </programlisting>
      <para>
	This kernel can be used in exactly the same way
	as the DefaultControlKernel. It has the same functions
	and behaves in exactly the same way. The only difference is
	that the Components and external classes can query DataObjects
	by name.
      </para>
    </sect1>
    <sect1>
      <title>Accessing a Nameserved DataType Directly</title>
      <para>
	Going further with the earlier examples, Assume that we 
	want to access the Nameserved Model from within the Generator.
	The example below shows what code you need to add to this
	component to be able to use it in the NamesControlKernel.
      </para>
      <warning>
	<para>
	  Once a component uses the functions of a nameserver,
	  it can no longer be used in the DefaultControlKernel.
	  The NamesControlKernel can accept all DefaultControlKernel
	  components but not vice versa.
	</para>
      </warning>
	<programlisting><![CDATA[
	  // ... 
	  _DefaultGenerator::InputType localCopy;
	  _DefaultGenerator::SetPointType localResult; 
	  
	  // New Code :
	  Frame delta_position;
	  double tool_temp;

	  // ... 
	  void pull() 
	  { 
	        localCopy = _DefaultGenerator::Inputs::dObj()->Get(); 
	        
                // New Code :
	        Frame end_f, old_f;
	        if ( !_DefaultGenerator::Model::dObj()->Get("EndPosition", end_f) ||
	             !_DefaultGenerator::Model::dObj()->Get("OldPosition", old_f) )
	             { // Error, "EndPosition" or "OldPosition" not found ! }

	        delta_position = end_f - old_f;

	        if ( !_DefaultGenerator::Model::dObj()->Get("Temperature", tool_temp) )
	             { // Error, "Temperature" not found ! }
	  } 
	  
	  void calculate()
	  { 
	        // ... calculate the setpoint
	  } 

	  void push() 
	  {
	       _DefaultGenerator::SetPoints::dObj()->Set( localResult ); 
	  }]]>
	</programlisting>
      <para>
	As you can see in the example, the component declares itself
	which type it needs from the Model and with which name. If
        it could not be found, Get() returns false.
      </para>
    </sect1>
    <sect1>
      <title>Indirect Nameserved DataType Access</title>
      <para>
	The vigilant user will have noticed that each time pull() is
	called, the string is resolved to a DataType. This can become
	very costly in demanding applications. This can be solved by
	resolving the DataObject which holds the DataType instead of the 
	DataType directly.  This method is called indirect access, since a
	step in between must be done to get the data.
      </para>
      <para>
	We adapt the above example again to demonstrate
	how the dataobject of the temperature can be resolved first.
      </para>
      <example>
	<title>Early resolving of the DataObject (Indirect)</title>
	<para>
	  This example demonstrates that the component can
	  get a pointer to the DataObject instead, which then in turn
	  must be accessed like a normal DataObject to Get() or Set()
	  the Data.
	</para>
	<programlisting>
	  <![CDATA[
	  
	  // ... 
	  _DefaultGenerator::InputType localCopy;
	  _DefaultGenerator::SetPointType localResult; 
	  
	  Frame delta_position;
	  double tool_temp;

	  // New Code :
	  Inputs::DataObject<double>::type* tool_temp_dobj;
	  
	  void ComponentLoaded()
	  {
	      // called when the component is loaded into the kernel.
	      if ( !_DefaultGenerator::Model::dObj()->Get("Temperature", tool_temp_dobj ) )
	             { // Error, "Temperature" not found ! }
	  }

	  // ... 
	  void pull() 
	  { 
	        localCopy = _DefaultGenerator::Inputs::dObj()->Get(); 
	        
	        Frame end_f, old_f;
	        if ( !_DefaultGenerator::Model::dObj()->Get("EndPosition", end_f) ||
	             !_DefaultGenerator::Model::dObj()->Get("OldPosition", old_f) )
	             { // Error, "EndPosition" or "OldPosition" not found ! }

	        delta_position = end_f - old_f;

	        // New Code:
	        tool_temp = tool_temp_dobj->Get();
	  } 
	  ]]>
	</programlisting>
      </example>
      <para>
	This method requires a bit more typing work but is also 
	safer because the component can issue a failure
	at load time instead of at runtime ( in pull() ). Hence, this method
	is always advised within a component. DataObjects (like the Command)
	can also be accessed from the outside, thus both methods remain
	available to allow the shorter, more transparant way.
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>Extending the Default Control Kernel</title>
    <sect1>
      <title>Control Kernel Extensions</title>
      <para>
	Extending the Default Control Kernel, composing extensions
      </para>
      <para>
	The DefaultControlKernel has only little features. It can be
	used to write a closed control cycle, but it offers no
	facilities to report data, configure it at run time etc. To
	add extra functionality to the Control Kernel, an Opt-In
	mechanism must be designed which the components can use, if
	desired. Each extra functionality is called an Extension. It
	is possible (and legal) that a component may have the
	functions present for using an extension, but that it is
	inserted in a control kernel which does not provide it. The
	opposite can be true too. The control kernel provides an
	extension that the component not wishes to use.
      </para>
      <para>
	A control kernel can have as many extensions as possible, but
	each extension can only be added once. There are currently two
	extensions provided : the Property extension and the Reporting
	extension, which are both described below. Each control kernel
	has also a <classname>KernelBaseFunction</classname>, which
	defines the basic features each control kernel has. The most
	important one is calling the update() methods of the
	components and changing the components state when the control
	kernel is started or stopped.
      </para>
      <para>
	Each extension will execute a small part of functionality in
	each periodic step of the Control Kernel. When multiple
	extensions are used, they are called one after the other in
	the order specified by the user. In most applications, the
	<classname>KernelBaseFunction</classname> will be executed as
	first, then the other extensions will be called.
      </para>
      <para>
	Each extension is accompanied by a piece of code, which is
	inserted in all components of the kernel. This allows the
	component to communicate information to the extension and
	back. This piece of code is called a Component Aspect. As the
	previous section explained, the
	<classname>KernelBaseFunction</classname> is coupled with the
	<classname>ComponentBaseInterface</classname> Aspect. What the
	Aspect does is providing extra method calls (hooks) to each
	component, which are related to a particular extension. The
	extension on the otherhand can access the component through
	the Aspect interface.
      </para>
      <para>
	How does one add an extension to the Default Control Kernel ?
	It happens by adding an extra template parameter on creation.
	To revisit the My1DKernel example :
      </para>
      <screen>
	// equivalent typedef as before : 
	typedef DefaultControlKernel&lt;double, double, double, double, double,	KernelBaseFunction&gt; My1DKernel; 

	// adding a new extension to the KernelBaseFunction : 
	typedef CompositeExtension&lt;KernelBaseFunction, PropertyExtension&gt; MyExtension; 
	typedef DefaultControlKernel &lt;double, double, double, double, double, MyExtension&gt; My1DPropertyKernel;
      </screen>
      <para>
	As can be seen, Extensions are composed using the
	<classname>CompositeExtension</classname> class, specifying
	the &lt; First, Second &gt; extension, where First and Second
	are allowed to be Composite Extensions themselves. The order
	First, Second determines which Extension is executed before
	the other. In the example above, the
	<classname>KernelBaseFunction</classname> is executed by the
	control kernel before the
	<classname>PropertyExtension</classname>, as it should be.
	Adding the reporting extension is then analogouos :
      </para>
      <screen>
	// ... // A control kernel with two additional Extensions :
	typedef CompositeExtension&lt; MyFirstExtension,
	ReportingExtension&gt; MySecondExtension; typedef
	DefaultControlKernel &lt;double, double, double, double,
	double, MySecondExtension&gt; My1DPropRepKernel;
      </screen>
      <para>
	The order in which the extensions are composed is important.
	If one extension fails on startup, the other will not be
	initialised and the starting of the control kernel will fail (
	return false ). Logically, you can read from left to right :
	If the first works, check then if the second works, then the
	third etc. The ordering is thus a recursive depth first. A
	whole dependency tree is built in that way, but each extension
	can occur only once. 
      </para>
      <figure><title>Ordering Extensions</title>
	<mediaobject>
	  <imageobject role="html">
	    <imagedata fileref="ExtensionTimeLine.png" format="PNG"/>
	  </imageobject>
	  <imageobject role="fo">
	    <imagedata fileref="ExtensionTimeLine.eps" format="EPS"/>
	  </imageobject>
	</mediaobject>
      </figure>
    </sect1>
    <sect1>
      <title>Component Aspects</title>
      <para>
	Extensions add Aspects to Components.
      </para>
      <para>
	Adding an Extension to the control kernel does not (visibly)
	change the existing components. So a component does not need
	to anticipate any possible extension (nor does the Control
	Kernel). The Aspect, which is added to the Component does
	however add a hook, into which the Component can place code
	which will be executed when the Extension accesses the
	Component. If a component wants to export some data when the
	control kernel supports reporting, it will put some code into
	the <methodname>exportReports()</methodname> hook. If the
	reporting extension is not present in the kernel, the
	<methodname>exportReports()</methodname> method will never be
	called. The Extension can know if a component has put code
	into the hook by providing a default implementation which gets
	called if the component does not want to use it. Each Aspect
	is defined as such that the Component has a passive role,
	meaning that the hook is always called by the Extension, and
	the component does not need to call the Extension (which would
	lead to locking the component into an Extension).
      </para>
      <sect2>
	<title>Extension Method Hooks</title>
	<para>
	  Almost every Extension will provide a hook method that each
	  component can override ( re-implement ) to make use of the
	  functionality. One hook might be used by different
	  Extensions, as long as the semantical meaning remains the
	  same for both Extensions. The following hooks are defined
	  until now :
	  <table>
	    <title>Extension Method Hooks</title>
	    <tgroup cols="2">
	      <thead>
		<row>
		  <entry>Method</entry>
		  <entry>Used For</entry>
		  <entry>Used By Extension</entry>
		</row>
	      </thead>
	      <tbody>
		<row>
		  <entry>
		    void exportReports( PropertyBag&amp; bag )
		  </entry>
		  <entry>The component needs to fill the bag with its
		    own Properties which will be read after each
		    control kernel cycle. This is how the Extension
		    knows what the Component wants to report.
		  </entry>
		  <entry>ReportingExtension, CORBAExtension</entry>
		</row>
		<row>
		  <entry>bool updateProperties( const PropertyBag&amp; bag )</entry>
		  <entry>The component can use the Properties found in the bag to
		    update its own properties. The Extension got the Properties from
		    a CPF file.</entry>
		  <entry>PropertyExtension</entry>
		</row>
	      </tbody>
	    </tgroup>
	  </table>
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Configuring a Control Kernel.</title>
      <para>This section explains how a Control Kernel can be
	configured in your program.</para>
      <sect2>
	<title>The KernelConfigurator</title>
	<para>Control kernels ( and components )  can be configured at
	  runtime with an XML file in the CPF (Component Property
	  File <citation>CCM</citation> ) format, 
	  defined by the OMG group. This group defines
	  the standards to be used within CORBA, but they are usable
	  outside CORBA too. The KernelConfigurator is a class which
	  can read a given xml file and configure a control kernel
	  with that information. The KernelConfigurator parses the
	  file and passes the result to the
	  <methodname>updateKernelProperties()</methodname> method of
	  the DefaultControlKernel. If you want to add your own
	  configuration options to a DefaultControlKernel subclass,
	  you can override this method, with your own which parses the
	  extra properties and then call the method of the base class
	  with the rest of the bag.
	</para>
	<para>A control kernel configuration file might look like this
	  :</para>
	<programlisting>
	  &lt;?xml version="1.0" encoding="UTF-8"?&gt;
	  &lt;properties&gt;
	  &lt;struct name="KernelProperties" type="type_less"&gt;
	  &lt;description&gt;The Basic characteristics of this kernel.&lt;/description&gt;
	  &lt;simple name="name"      type="string"&gt;&lt;description&gt;The Name of this kernel&lt;/description&gt;&lt;value&gt;Default&lt;/value&gt;&lt;/simple&gt;
	  &lt;simple name="frequency" type="double"&gt;&lt;description&gt;The periodic execution frequency in Hz&lt;/description&gt;&lt;value&gt;1000&lt;/value&gt;&lt;/simple&gt;
	  &lt;simple name="priority"  type="string"&gt;&lt;description&gt;The priority of the kernel.&lt;/description&gt;&lt;value&gt;NonPreemptible&lt;/value&gt;&lt;/simple&gt;
	&lt;/struct&gt;

	  &lt;struct name="Extensions" type="type_less"&gt;
	  &lt;simple name="Interpreter" type="string"&gt;
	  &lt;description&gt;The property file of the interpreter&lt;/description&gt;
	  &lt;value&gt;interpreter.cpf&lt;/value&gt;&lt;/simple&gt;

	  &lt;simple name="Reporter" type="string"&gt;
	  &lt;description&gt;The property file of the reporter&lt;/description&gt;
	  &lt;value&gt;reporter.cpf&lt;/value&gt;&lt;/simple&gt;

	  &lt;simple name="Sequencer" type="string"&gt;
	  &lt;description&gt;The property file of the sequencer&lt;/description&gt;
	  &lt;value&gt;sequencer.cpf&lt;/value&gt;&lt;/simple&gt;

	  &lt;simple name="Property" type="string"&gt;
	  &lt;description&gt;The property file of the property manager&lt;/description&gt;
	  &lt;value&gt;property.cpf&lt;/value&gt;&lt;/simple&gt;
	&lt;/struct&gt;
	&lt;/properties&gt;
	</programlisting>
	<para>
	  It has two major parts : KernelProperties and Extensions.
	  The first contains general options which apply to any
	  kernel. The second specifies the property file for each
	  (possible) extension. If the file is not found, an error is
	  raised by the KernelConfigurator. The XML format is further
	  explained in the Property Extension section. It is allowed
	  to define your own properties in this file and update them
	  in your own <methodname>updateKernelProperties</methodname>
	  method. 
	</para>
      </sect2>
      <sect2>
	<title>Configuring the Control Kernel with XML files</title>
	<para>
	  Runtime configuration of the control kernel and its
	  Components can happen with XML files, so that you don't have
	  to recompile your program each time you want to change an
	  option. The CPF format is defined in the
	  <filename>cpf.dtd</filename> file and is equal to the CORBA
	  3 standard's property file format. The DefaultControlKernel and
	  each extension have an own CPF file, which defines the
	  values some (or all) properties should take. There may be
	  more properties than listed in the CPF file and vice versa.
	  The parser will do its best effort to configure each
	  component with the given data. 
	</para>
	<tip>
	  <para> Example CPF files can often be found in the doc directory of the packages.</para>
	</tip>
      </sect2>
      <sect2>
	<title>Properties</title>
	<para>
	  Properties are a way to represent configuration options in
	  an abstract way. The property contains data (has a value),
	  which is of one certain, immutable, type. Any type can be
	  encapsulated by a Property. A Property of a double is
	  written as : 
	  <screen>
	    Property&lt;double&gt; d_prop;</screen>
	  A Property of an arbitrary type A is
	  equally written as 
	  <screen>
	    Property&lt; A &gt; a_prop;
	  </screen> 
	  This however does not enable the
	  marshallers or demarshallers to know how to convert a
	  property to a text file and vice versa. For each unknown
	  type, the user has to write a composeProperty and
	  decomposeProperty method. How this must happen can be read
	  in the <filename>corelib/properties/base
	    PropertyComposition.hpp</filename> and
	  <filename>corelib/properties/base
	    PropertyDecomposition.hpp</filename> files.
	</para>
	<example>
	  <title>Property Composition and Decomposition</title>
	  <para> The Geometry primitives have also such custom functions
	  which can be found in the file <filename>geometry
	    MotionProperties.hpp</filename> file.</para>
	</example>      
      </sect2>
    </sect1>
  </chapter>
  <chapter>
    <title>Extensions</title>
    <sect1>
      <title>The Property Extension</title>
      <para>
        Extending your components with properties.
      </para>
      <para>
	By default, only the control kernel has a limited set of
	properties, Components have none. The PropertyExtension adds
	properties also to the components. The
	<filename>properties.cpf</filename> file lists the CPF file
	for each component type. The components present in the control
	kernel will get the properties updated on starting the control
	kernel. An option can be enabled to configure all components,
	even those not loaded in the control kernel.
      </para>
      <sect2>
	<title>Configuring the Property Extension</title>
	<para>
	  The PropertyExtension can be configured through the CPF
	  file given in the control kernel configuration file. Not all configuration options
	  are yet implemented and the layout may change in future releases.
	  An example looks like this :
	</para>
	<example>
	  <title>Example properties.cpf file</title>
	  <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE properties SYSTEM "cpf.dtd"&gt;
&lt;properties&gt;
    &lt;!--Possible future syntax : --&gt;
    &lt;struct name="Generator" type="ComponentEntry"&gt;
        &lt;simple name="Type"&gt;&lt;value&gt;Generator&lt;/value&gt;&lt;/simple&gt;
        &lt;simple name="Filename"&gt;&lt;value&gt;MotionGenerator.cpf&lt;/value&gt;&lt;/simple&gt;
    &lt;/struct&gt;

    &lt;!--Current syntax : --&gt;
    &lt;simple name="Generator"  type="string"&gt;&lt;description&gt;The Generator Component Property File.&lt;/description&gt;&lt;value&gt;generator.cpf&lt;/value&gt;&lt;/simple&gt;
    &lt;simple name="Estimator"  type="string"&gt;&lt;description&gt;The Estimator Component Property File.&lt;/description&gt;&lt;value&gt;estimator.cpf&lt;/value&gt;&lt;/simple&gt;
    &lt;simple name="Controller" type="string"&gt;&lt;description&gt;The Controller Component Property File.&lt;/description&gt;&lt;value&gt;controller.cpf&lt;/value&gt;&lt;/simple&gt;
    &lt;simple name="Sensor"     type="string"&gt;&lt;description&gt;The Sensor Component Property File.&lt;/description&gt;&lt;value&gt;sensor.cpf&lt;/value&gt;&lt;/simple&gt;
    &lt;simple name="Effector"   type="string"&gt;&lt;description&gt;The Effector Component Property File.&lt;/description&gt;&lt;value&gt;effector.cpf&lt;/value&gt;&lt;/simple&gt;

    &lt;simple name="SaveProperties" type="boolean"&gt;
        &lt;description&gt; True if properties of components need to be saved when stopping the kernel.&lt;/description&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="SaveFilePrefix"   type="string"&gt;
        &lt;description&gt;The suffix of the filename to store the components state into&lt;/description&gt;&lt;value&gt;saved_&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="SaveFileExtension"   type="string"&gt;
        &lt;description&gt;The extension of the filename to store the components state into&lt;/description&gt;&lt;value&gt;cpf&lt;/value&gt;
    &lt;/simple&gt;

&lt;/properties&gt;
	  </programlisting>
	</example>
      </sect2>
      <sect2>
	<title>Hooks</title>
	<para>The Property Extension has one hook : the
	  <methodname>updateProperties( const PropertyBag&amp; bag
	    )</methodname> method. The user must extract properties
	  from the bag and assign his own proper property with the
	  value found. A helper function can be written to facilitate
	  this for any type.
	</para>
	<example>
	  <title>The PropertyExtension used in
	    CartesianComponents.hpp</title>
	  <para>
	    A simple component with only one property. If
	    composeProperty can not find the gain property back, it
	    will return false, and the control kernel will not start.
	  </para>
	  <programlisting>
	    // In constructor, gain defaults to zero :
	       , gain("Gain","The gain of the controller",0)

	    // Hook In Controller Component :
	    virtual bool updateProperties( const PropertyBag&amp; bag)
            {
	        return composeProperty(bag, gain ); // returns true if successful.
            }

	    // ... The gain of the Controller ...
	    Property&lt;double&gt; gain;

	    // ...
	  </programlisting>
	  <para>The CPF file looks like this :</para>
	  <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE properties SYSTEM "cpf.dtd"&gt;
&lt;properties&gt;
    &lt;simple name="Name" type="string"&gt;&lt;description&gt;The unique name of this component&lt;/description&gt;&lt;value&gt;CartesianController&lt;/value&gt;&lt;/simple&gt;
    &lt;simple name="Gain"    type="double"&gt;&lt;description&gt;The gain of the controller &lt;/description&gt;&lt;value&gt;2&lt;/value&gt;&lt;/simple&gt;
&lt;/properties&gt;
	  </programlisting>
	</example>
      </sect2>
    </sect1>
    <sect1>
      <title>The Reporting Extension</title>
      <para>
        Reporting components and dataobjects values.
      </para>
      <para>
	A second functional Extension is the Reporting Extension. It
	enables components to report the status of internal variables
	to the screen or to a file, independent of the kernel's
	execution period. It can be used for synchronous reporting of
	data (every sample), but the design favours determinism of
	execution time over determinism of data acquisition. This
	means that it is possible that a data sample is lost, but
	never possible that the control kernel stalls because of the
	reporting activity. Each extension must at least guarantee
	that it does not block within its execution.
      </para>
      <para>
	What happens is that after each control kernel step, the
	Extension tries to make a backup of the components data. If by
	accident the data is accessed by the report writing task, the
	copy operation is cancelled. A better buffering mechanism
	(swinging buffers) might solve this in a better way.
      </para>
      <sect2>
	<title>Configuring the Reporting Extension</title>
	<para>
	  The ReportingExtension can be configured through the CPF
	  file given in the control kernel configuration file. Not all
	  configuration options are yet implemented and the layout may
	  change in future releases. An example looks like this :
	</para>
	<example>
	  <title>Example reporting.cpf file</title>
	  <programlisting>
&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;!DOCTYPE properties SYSTEM "cpf.dtd"&gt;
&lt;!-- Properties of the ReportingExtension --&gt;
&lt;properties&gt;

    &lt;simple name="ReportPeriod" type="double"&gt;
            &lt;description&gt;The period, in seconds, for making reports.&lt;/description&gt;
            &lt;value&gt;0.1&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="ReportFile" type="string"&gt;
        &lt;description&gt;The file to write the reports to.&lt;/description&gt;
        &lt;value&gt;reports.txt&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="ReportServer" type="string"&gt;
        &lt;description&gt;The name of the report server to use.&lt;/description&gt;
        &lt;value&gt;MyReporter&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="WriteToStdOut" type="boolean"&gt;
        &lt;description&gt;True if the report needs to be written to standard output.&lt;/description&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/simple&gt;
    &lt;simple name="WriteToFile" type="boolean"&gt;
        &lt;description&gt;True if the report needs to be written to a file.&lt;/description&gt;
        &lt;value&gt;1&lt;/value&gt;
    &lt;/simple&gt;
    &lt;struct name="Exporters" type="type_less"&gt;
        &lt;simple name="Component" type="string"&gt;&lt;value&gt;Sensor&lt;/value&gt;&lt;/simple&gt;
        &lt;simple name="Component" type="string"&gt;&lt;value&gt;Effector&lt;/value&gt;&lt;/simple&gt;
        &lt;simple name="Component" type="string"&gt;&lt;value&gt;Controller&lt;/value&gt;&lt;/simple&gt;
        &lt;simple name="Component" type="string"&gt;&lt;value&gt;Estimator&lt;/value&gt;&lt;/simple&gt;
        &lt;simple name="Component" type="string"&gt;&lt;value&gt;Generator&lt;/value&gt;&lt;/simple&gt;
    &lt;/struct&gt;
&lt;/properties&gt;
	  </programlisting>
	</example>
      </sect2>
      <sect2>
	<title>Hooks</title>
	<para>The ReportingExtension has one hook : the
	  <methodname>void exportReports( PropertyBag&amp; bag)
	  </methodname> method. The user must put every value he
	  wishes to report in a Property of the according type. For
	  example to report a 6D position, one would create a Property
	  <screen>Property&lt; Double6D &gt; q6;</screen> in the
	  component class. The exportReports method will then insert
	  this property into the given bag. Of course, a component
	  does not need to report all its properties, depending on the
	  configuration, other types might be reported. 
	</para>
	<para>
	  The Decomposition constraint of the PropertyExtension also
	  applies here.
	</para>
	<example>
	  <title>Reporting in CartesianComponents.hpp</title>
	  <para>
	    A simple component with only one value to report.
	  </para>
	  <programlisting>
	    // In constructor :
	       :end_pos("End Position","One of many variables which can be reported.")

	    // Hook in Generator Component:
                 virtual void exportReports(PropertyBag&amp; bag)
                 {
                     bag.add(&amp;end_pos);
                 }

	    // The property itself
	    Property&lt; ORO_Geometry::Frame &gt; end_pos;

	    // ...
	  </programlisting>
	</example>
      </sect2>
    </sect1>
  </chapter>
<bibliography><title>Bibliography</title>
  <biblioentry xreflabel="corba3">
    <abbrev>CCM</abbrev>
    <title>CORBA Components</title>
    <pubdate>2002</pubdate>
    <publisher><publishername>Object Management Group</publishername></publisher>
    <pagenums>277-282</pagenums>
  </biblioentry>
</bibliography>

</book>
