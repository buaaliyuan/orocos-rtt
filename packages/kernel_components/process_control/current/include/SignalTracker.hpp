#ifndef ORO_SIGNALTRACKER_HPP
#define ORO_SIGNALTRACKER_HPP

#include <control_kernel/DataServer.hpp>
#include <control_kernel/KernelInterfaces.hpp>

#include <pkgconf/system.h>
#ifdef OROPKG_EXECUTION_PROGRAM_PARSER
#include "execution/TemplateDataSourceFactory.hpp"
#include "execution/TemplateCommandFactory.hpp"
#endif


namespace ORO_ControlKernel
{
    using namespace ORO_SignalProcessing;

    /**
     * The Setpoints generated by the SignalTracker.
     */
    struct SignalTrackerSetPoint :
        public ServedTypes< vector<double> >
    {
        SignalTrackerSetPoint()
        {
            this->insert(make_pair(0, "ChannelValues") );
        }
    };

    /**
     * The Commands accepted the SignalTracker.
     */
    struct SignalTrackerCommand :
        public ServedTypes< vector<double> >
    {
        SignalTrackerCommand()
        {
            this->insert(make_pair(0, "ChannelValues"));
        }
    };

    /**
     * A Generator for tracking any input signal
     * for N channels. It only accepts data through its
     * data object ports. It copies a channel value from
     * Command, Model or Input DataObject to the a SetPoint
     * DataObject channel. WARNING if you try to track from different
     * DataObjects, the last one will always be used for all channels !
     *
     * The current implementation can only track one dataobject
     * at a time (so all tracked channels come from one dataobject). 
     * Interested parties can extend this implementation with
     * multi-dataobject tracking.
     */
    template< class Base >
    class SignalTracker
        : public Base
    {
    public:
        /**
         * Constructor.
         */
        SignalTracker(int num_channels =  1) 
            : Base("SignalTracker"),
              max_chans("Channels", "The number of channels", num_channels)
        {
            channel.resize(max_chans);
            set_point.resize(max_chans);
        }

        virtual bool componentStartup()
        {
            if ( ! Base::SetPoint::dObj()->Get("ChannelValues", setp_DObj) || setp_DObj->Get().size() != max_chans )
                return false;

            return true;
        }            

        virtual void pull()
        {
            // read the tracking channels
            // we only read one DO, which might be conceived as a bug by some parties.
            if ( track_DObj )
                track_DObj->Get( track_point );
        }

        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void calculate() 
        {
            if ( track_DObj )
                {
                    for( chaniter it= channel.begin(); it != channel.end(); ++it)
                        if (it->enable)
                            set_point[ it->sink_chan ] = it->factor * track_point[ it->source_chan ];
                        else
                            set_point[i] = 0;
                }
        }
            
        /**
         * @see KernelInterfaces.hpp class ModuleControlInterface
         */
        virtual void push()      
        {
            setp_DObj->Set( set_point );
        }

        bool trackCommand( int sp_chan, int com_chan )
        {
            return track( Base::Command::dObj(), "ChannelCommand", sp_chan, com_chan );
        }

        bool trackInput( int sp_chan, int inp_chan)
        {
            return track( Base::Input::dObj(), "ChannelInput", sp_chan, inp_chan );
        }

        bool trackModel( int sp_chan, int mod_chan)
        {
            return track( Base::Model::dObj(), "ChannelModel", sp_chan, mod_chan );
        }

        template < class DOS >
        bool track( DOS* dObj, const std::string& do_name, int sp_chan, int track_chan )
        {
            if ( !isValidChannel(sp_chan) || !isValidChannel(track_chan) )
                return false;

            if (!dObj->has(do_name, vector<double>() ) )
                {
                    track_DObj = 0;
                    return false;
                }
            else
                {
                    channel[sp_chan].source_chan = track_chan;
                    channel[sp_chan].sink_chan   = sp_chan;
                    dObj->Get(do_name, track_DObj);
                    channel[sp_chan].tracker     = track_DObj;
                    return true;
                }
        } 

        bool isTracking(const std::string& do_name ) const
        {
            return track_DObj != 0;
        }

        /**
         * Multiply the output of a channel with a special value.
         */
        bool scaleValue( unsigned int chan_num, double factor )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].factor = factor;
            return true;
        }

        /**
         * Unmute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool enableChannel( unsigned int chan_num )
        {
            if (chan_num >= max_chans || channel[chan_num].tracker == 0)
                return false;
            channel[chan_num].enable = true;
            return true;
        }

        /**
         * Mute a channel.
         *
         * @return true if chan_num was valid.
         */
        bool disableChannel( unsigned int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            channel[chan_num].enable = false;
            return true;
        }

        bool isEnabled( unsigned int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            return channel[chan_num].enable;
        }

        /**
         * Return the current setpoint of a channel.
         */
        double channelValue( unsigned int chan_num )
        {
            if (chan_num >= max_chans )
                return 0;
            return set_point[chan_num];
        }

        bool isValidChannel( unsigned int chan_num )
        {
            if (chan_num >= max_chans )
                return false;
            return true;
        }

        virtual bool updateProperties( const PropertyBag& bag )
        {
            /*
             * <simple name="Channels" type="integer"><value>8</value</simple>
             * <sequence>
             * <struct name="Channel" type="type_less">
             *   <simple name="Channel Nr"        type="integer"> <value>0</value></simple>
             *   <simple name="Channel Generator" type="string">  <value>sine</value></simple>
             * </struct>
             * </sequence>
             */
            return decomposeProperty( max_chans, bag);
        }

#ifdef OROPKG_EXECUTION_PROGRAM_PARSER

        DataSourceFactory* createDataSourceFactory()
        {
            TemplateDataSourceFactory< SignalTracker<Base> >* ret =
                newDataSourceFactory( this );
            ret->add( "channelValue", 
                      data( &SignalTracker<Base>::channelValue, "The current value "
                            "of the channel.",
                            "Channel", "The number of the channel") );
            return ret;
        }

        template< class T >
        bool true_gen( T t ) const { return true; }

        CommandFactoryInterface* createCommandFactory()
        {
            TemplateCommandFactory< SignalTracker<Base> >* ret =
                newCommandFactory( this );
            ret->add( "enableChannel", 
                      command( &SignalTracker<Base>::enableChannel,
                               &SignalTracker<Base>::isValidChannel,
                               "Turn on a channel.",
                               "Channel", "The channel to turn on."
                               ) );
            ret->add( "disableChannel", 
                      command( &SignalTracker<Base>::disableChannel,
                               &SignalTracker<Base>::isValidChannel,
                               "Turn off a channel.",
                               "Channel", "The channel to turn off."
                               ) );
            ret->add( "scaleValue", 
                      command( &SignalTracker<Base>::scaleValue,
                               &SignalTracker<Base>::isValidChannel,
                               "Scale the output of a channel.",
                               "Channel", "The channel number.",
                               "Factor", "The scale factor."
                               ) );
            ret->add( "trackInput", 
                      command( &SignalTracker<Base>::trackInput,
                               &SignalTracker<Base>::isValidChannel,
                               "Track an Input channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Input Channel", "The Input channel number"
                               ) );
            ret->add( "trackModel", 
                      command( &SignalTracker<Base>::trackModel,
                               &SignalTracker<Base>::isValidChannel,
                               "Track an Model channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Model Channel", "The Model channel number"
                               ) );
            ret->add( "trackCommand", 
                      command( &SignalTracker<Base>::trackCommand,
                               &SignalTracker<Base>::isValidChannel,
                               "Track an Command channel.",
                               "SetPoint Channel", "The SetPoint channel number.",
                               "Command Channel", "The Command channel number"
                               ) );
            return ret;
        }
#endif

    protected:
        Property<int> max_chans;

        /**
         * Holds all info about the state of a channel.
         */
        struct Channel
        {
            Channel() : factor(1.0), enable(false), tracker(0) {}
            Channel(double f, bool e)
                : factor(f), enable(e) {}
            double factor;
            bool enable;
            int source_chan;
            int sink_chan;
            DataObjectInterface< std::vector<double> >* tracker;
        };

        typedef typename std::vector<Channel>::iterator chaniter;
        std::vector<Channel> channel;
        std::vector<double> set_point;
        std::vector<double> track_point;
        DataObjectInterface< std::vector<double> >* setp_DObj;
        DataObjectInterface< std::vector<double> >* track_DObj;
    };

}

#endif
