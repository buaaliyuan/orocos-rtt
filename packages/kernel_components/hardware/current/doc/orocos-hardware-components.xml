<?xml version='1.0'?>

<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd"
[
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY hardwcomp   "<acronym>Generic Hardware Components</acronym>">
<!ENTITY hardw       "<acronym>Generic Hardware</acronym>">
]
>

<book>
  <bookinfo>
    <title> Orocos Generic Hardware Control Kernel Components</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>          <address><country>Belgium</country></address>
        </affiliation>
      </author>
    </authorgroup>
    <copyright>
      <year>2002-2004</year>
      <holder><email>Peter.Soetens@mech.kuleuven.ac.be</email></holder>
      <holder><email>Herman.Bruyninckx@mech.kuleuven.ac.be</email></holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	Generic Hardware Access ControlKernel components.
      </para>
    </abstract>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation, with no Invariant Sections, with no
	Front-Cover Texts, and with no Back-Cover Texts. A copy of
	this license can be found at <ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>
  </bookinfo>
  <chapter>
    <title>Introduction</title>
    <para>
      This chapter explains installation, and gives an overview of the
      features and interface of the &orocos; &hardwcomp;.
    </para>
    <sect1>
      <title>Installation</title>
      <para>
	This package depends on the interfaces defined in the 
	Orocos Device Interface package and implementations of the
	Orocos Device Drivers package. They must be installed together
	with the Orocos Control Kernel package and the Corelib.
      </para>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
    </sect1>
  </chapter>
  <chapter>
    <title>Generic Hardware Abstraction</title>
    <para>
      This chapter explains how hardware sensors and outputs
      are abstracted using these Components in the Control
      Kernel Framework. They allow to do a quick test of
      existing device drivers, accessing them from a 
      Control Kernel. They are not aimed to a specific
      application and the signals are propagated in
      a simulink-like (thus without much semantical
      meaning attached) way in 'channels'.
    </para>
    <sect1>
      <title>GenericSensor : Sensor Hardware Abstraction</title>
      <para>
	The Generic Sensor knows two fundamental
	types of sensors : Analog Inputs and Digital Inputs.
	Multichannel Analog and Digital input cards are defined
	in the Device Interface package, while the logical
	representation of an Analog Input and Digital Input
	are implemented in the Device Driver package.
      </para>
      <para>
	The Sensor provides methods to add Analog and
	Digital Inputs.
      </para>
      <sect2>
	<title>Creating a GenericSensor Component</title>
	<para>
	  The GenericSensor is created like all
	  the other components in the control framework :
	  <programlisting>
  GenericSensor   hardw_sens(NUM_CHANS);
	  </programlisting>
	  Where NUM_CHANS is the maximal number of channels
	  this Sensor exposes (see later).
	</para>
      </sect2>
      <sect2>
	<title>Adding and Removing an Analog Input</title>
	<para>
	  An unlimited number of Analog Inputs can be added
	  to the GenericSensor :
	  <programlisting>
  int A_CHANNEL_1 = 1;
  hardw_sens.addAnalogInput("AIn_1", analog_input_card, A_CHANNEL_1 );
	  </programlisting>
	  This methods adds a DataObjectInterface&lt;double&gt; object
	  with the name "AIn_1" to the Inputs, which
	  is updated from an analog_input_card on channel A_CHANNEL_1.
	  The analog_input_card must implement the <classname>
	  AnalogInInterface</classname>.
	  If there is already an "AIn_1" DataObject, addAnalogInput
	  returns false.
	</para>
	<para>
	  The Analog Input can also be read from an Orocos
	  Program Script or State Description :
	  <programlisting>
  var double result = GenericSensor.value("AIn_1")
  var int    raw_result = GenericSensor.rawValue("AIn_1")
	  </programlisting>
	</para>
	<para>
	  It can be removed with the following method call :
	  <programlisting>
  hardw_sens.removeAnalogInput("AIn_1");
	  </programlisting>
	  Which removes the "AIn_1" DataObject from the Inputs
	  DataObjects.
	</para>
      </sect2>
      <sect2>
	<title>Using Virtual Channels</title>
	<para>
	  Analog Outputs can be ordered in a virtual channels DataObject.
	  This allows a more generic way of accessing the DataObjects
	  in the other components. The Channel DataObject which is
	  created is of the type
	  <classname>DataObjectInterface&lt; std::vector&lt;double&gt; &gt;</classname>
	  and has the name "ChannelValues". AnalogInputs
	  can be added to a channel in this vector :
	  <programlisting>
  int A_VIRT_CHAN = 1;
  int A_CHANNEL   = 5;
  hardw_sens.addChannel(A_VIRT_CHAN, analog_input_card, A_CHANNEL );
	  </programlisting>
	  Which demonstrates that channel 5 of the AnalogInInterface
	  is inserted in position 1 of the Channel DataObject. If this
	  channel was already taken, addChannel returns false;
	</para>
	<para>
	  Removing a virtual channel is quite straightforward :
	  <programlisting>
  hardw_sens.removeChannel( A_VIRT_CHAN );
	  </programlisting>
	</para>
	<para>
	  The Process Control Components in the kernel_components/process_control
	  package use virtual channels for their operations.
	</para>
      </sect2>
      <sect2>
	<title>Adding Digital Inputs</title>
	<para>
	  Digital Inputs are not introduced in DataObjects, as digital
	  signal processing is done in the PLC-like Execution Engine.
	  The GenericSensor exposes the Digital Inputs to the 
	  Execution Extension of the Control Kernel.
	</para>
	<para>
	  A Digital Input is added as such :
	  <programlisting>
  int D_CHANNEL = 2;
  hardw_sens.addDigitalInput("DIn_1", digital_input_card, D_CHANNEL );
	  </programlisting>
	  Which is very similar to adding an Analog Input. However,
	  behind the scenes, no DataObject is created. The GenericSensor
	  exposes this Input through the methods :
	  <programlisting>
  bool result = hardw_sens.isOn("DIn_1");
	  </programlisting>
	  Or in a program or state script :
	  <programlisting>
  var bool result = GenericSensor.isOn("DIn_1")
	  </programlisting>
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>GenericEffector : Effector Hardware Abstraction</title>
      <para>
	The GenericEffector is very similar to the GenericSensor, but
	analog/digital inputs are replaced by the ouputs counterparts.
	The GenericEffector reads from the Outputs DataObject.
      </para>
      <sect2>
	<title>Creating a GenericEffector</title>
	<para>
	  This is analogous to creating a GenericSensor :
	  <programlisting>
  GenericEffector hardw_eff(NUM_CHANS);
	  </programlisting>
	  Whrere NUM_CHANS is the maximum number of channels read from
	  the "ChannelValues" DataObject.
	</para>
      </sect2>
      <sect2>
	<title>Adding and Removing Analog Outputs</title>
	<para> Analogous to the GenericSensor :
	  <programlisting>
  int A_CHANNEL_1 = 1;
  hardw_eff.addAnalogOutput("AOut_1", analog_output_card, A_CHANNEL_1 );
	  </programlisting>
	  This methods <emphasis>expects</emphasis>
	  a DataObjectInterface&lt;double&gt; object
	  with the name "AOut_1" in the Outputs, so it must be
	  created by the Controller Component. The GenericEffector
	  will check the existence of this DataObject in its
	  componentStartup method (thus when it is selected).
	  The analog_output_card must implement the <classname>
	  AnalogOutInterface</classname>.
	  If there is already an "AOut_1" DataObject, addAnalogOutput
	  returns false.
	</para>
	<para>
	  The Analog Output can also be read from an Orocos
	  Program Script or State Description :
	  <programlisting>
  var double result = GenericEffector.value("AOut_1")
  var int    raw_result = GenericEffector.rawValue("AOut_1")
	  </programlisting>
	  Writing to DataObjects is not allowed, and can
	  only be done by the Controller Component.
	</para>
	<para>
	  It can be removed with the following method call :
	  <programlisting>
  hardw_sens.removeAnalogOutput("AOut_1");
	  </programlisting>
	  This does not remove the AOut_1 DataObject, it just
	  does no longer use it.
	</para>
      </sect2>
      <sect2>
	<title>Using Virtual Channels</title>
	<para>
	  Analog Outputs can be read from a virtual channels DataObject.
	  The GenericEffector <emphasis>expects</emphasis> a
	  <classname>DataObjectInterface&lt; std::vector&lt;double&gt; &gt;</classname>
	  DataObject in the Outputs with the name "ChannelValues".
	  Analog Outputs can be read from this vector :
	  <programlisting>
  int A_VIRT_CHAN = 1;
  int A_CHANNEL   = 5;
  hardw_eff.addChannel(A_VIRT_CHAN, analog_output_card, A_CHANNEL );
	  </programlisting>
	  Which demonstrates that channel 5 of the AnalogOutInterface
	  is set to the value of virtual channel 1.
	  If this virtual 
	  channel was already taken, addChannel returns false;
	</para>
	<para>
	  Removing a virtual channel is again quite straightforward :
	  <programlisting>
  hardw_eff.removeChannel( A_VIRT_CHAN );
	  </programlisting>
	</para>
	<para>
	  The Process Control Components in the kernel_components/process_control
	  package use virtual channels for their operations.
	</para>
      </sect2>
      <sect2>
	<title>Adding Digital Outputs</title>
	<para>
	  Digital Outputs are not read from DataObjects, as digital
	  signals are set in the Execution Engine.
	  The GenericEffector exposes the Digital Outputs to the 
	  Execution Extension of the Control Kernel.
	</para>
	<para>
	  A Digital Output is added as such :
	  <programlisting>
  int D_CHANNEL = 2;
  hardw_eff.addDigitalOutput("DOut_1", digital_output_card, D_CHANNEL );
	  </programlisting>
	  Which is again analogous to the GenericSensor. The GenericEffector
	  exposes this Output through the methods :
	  <programlisting>
  hardw_eff.switchOn("DOut_1");
  bool result = hardw_eff.isOn("DOut_1");
  harw_eff.switchOff("DOut_1");
	  </programlisting>
	  Or in a program or state script :
	  <programlisting>
  do GenericEffector.switchOn("DOut_1")
  var bool result = GenericEffector.isOn("DOut_1")
  do GenericEffector.switchOff("DOut_1")
	  </programlisting>
	</para>
      </sect2>
    </sect1>
    <sect1>
      <title>Using Components with the GenericEffector and GenericSensor</title>
      <para>
	The GenericEffector and GenericSensor allow for a quick test of the
	available hardware. An example can be found in the
	<filename>kernel_samples/hardware_components</filename> directory.
	A <classname>SignalGenerator</classname> or
	<classname>SignalTracker</classname> with a
	<classname>FeedForwardController</classname> can be used to generate
	a signal on an analog ouput, or replicate a signal on an analog input.
	These components can be found in the
	signal_processing and process_control packages.
      </para>
    </sect1>
  </chapter>
</book>
