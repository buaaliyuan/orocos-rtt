// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:910

#include "corba/ExecutionEngineI.h"
#include "ExecutionEngine.hpp"
#include "ProgramLoader.hpp"
#include "parse_exception.hpp"
#include <sstream>

using namespace std;


// Implementation skeleton constructor
Orocos_ExecutionEngine_i::Orocos_ExecutionEngine_i (ExecutionEngine& ee)
    :mee(ee), sproc( ee.getTaskContext() )
{
}

// Implementation skeleton destructor
Orocos_ExecutionEngine_i::~Orocos_ExecutionEngine_i (void)
{
}

void Orocos_ExecutionEngine_i::loadPrograms (
    const char * code,
    const char * filename
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ::RTT::Corba::ExecutionEngine::LoadException
  ))
{
    ProgramLoader loader(true);
    stringstream input( code );
    try {
        loader.loadProgram( input, mee.getTaskContext(), filename );
    }
    catch (program_load_exception &ple) {
        throw Corba::ExecutionEngine::LoadException( ple.what() );
    } catch(file_parse_exception &fpe) {
        throw Corba::ExecutionEngine::LoadException( fpe.what().c_str() );
    }
}

void Orocos_ExecutionEngine_i::unloadProgram (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ::RTT::Corba::ExecutionEngine::LoadException
  ))
{
    ProgramLoader loader(true);
    try {
        loader.unloadProgram( name, mee.getTaskContext() );
    }
    catch (program_unload_exception &ple) {
        throw Corba::ExecutionEngine::LoadException( ple.what() );
    }
}

::RTT::Corba::ExecutionEngine::ProgramNames * Orocos_ExecutionEngine_i::getPrograms (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    std::vector<std::string> vlist = mee.programs()->getProgramList();
    ::RTT::Corba::ExecutionEngine::ProgramNames_var result = new ::RTT::Corba::ExecutionEngine::ProgramNames( vlist.size() );
    for (unsigned int i=0; i != vlist.size(); ++i )
        result[i] = CORBA::string_dup( vlist[i].c_str() );
    return result._retn();
}

CORBA::Long Orocos_ExecutionEngine_i::getProgramLine (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    ProgramInterfacePtr p = mee.programs()->getProgram( name );
    if ( p )
        return p->getLineNumber();
    return -1;
}

char * Orocos_ExecutionEngine_i::getProgramText (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    ProgramInterfacePtr p = mee.programs()->getProgram( name );
    if ( p )
        return CORBA::string_dup( p->getText().c_str() );
    return "";
}

char * Orocos_ExecutionEngine_i::getProgramStatus (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    return CORBA::string_dup( mee.programs()->getProgramStatusStr(name).c_str() );
}

void Orocos_ExecutionEngine_i::loadStateMachines (
    const char * code,
    const char * filename
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ::RTT::Corba::ExecutionEngine::LoadException
  ))
{
    ProgramLoader loader(true);
    stringstream input( code );
    try {
        loader.loadStateMachine( input, mee.getTaskContext(), filename );
    }
    catch (program_load_exception &ple) {
        throw Corba::ExecutionEngine::LoadException( ple.what() );
    } catch(file_parse_exception &fpe) {
        throw Corba::ExecutionEngine::LoadException( fpe.what().c_str() );
    }
}

void Orocos_ExecutionEngine_i::unloadStateMachine (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException,
    ::RTT::Corba::ExecutionEngine::LoadException
  ))
{
    ProgramLoader loader(true);
    try {
        loader.unloadStateMachine( name, mee.getTaskContext() );
    }
    catch (program_unload_exception &ple) {
        throw Corba::ExecutionEngine::LoadException( ple.what() );
    }
}

::RTT::Corba::ExecutionEngine::StateMachineNames * Orocos_ExecutionEngine_i::getStateMachines (
    
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
  // Add your implementation here
    std::vector<std::string> vlist = mee.states()->getStateMachineList();
    ::RTT::Corba::ExecutionEngine::StateMachineNames_var result = new ::RTT::Corba::ExecutionEngine::StateMachineNames( vlist.size() );
    for (unsigned int i=0; i != vlist.size(); ++i )
        result[i] = CORBA::string_dup( vlist[i].c_str() );
    return result._retn();
}

char * Orocos_ExecutionEngine_i::getStateMachineText (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    StateMachinePtr p = mee.states()->getStateMachine( name );
    if ( p )
        return CORBA::string_dup( p->getText().c_str() );
    return "";
}

char * Orocos_ExecutionEngine_i::getStateMachineStatus (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    return CORBA::string_dup( mee.states()->getStateMachineStatusStr(name).c_str() );
}

CORBA::Long Orocos_ExecutionEngine_i::getStateMachineLine (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    StateMachinePtr p = mee.states()->getStateMachine( name );
    if ( p )
        return p->getLineNumber();
    return -1;
}

char * Orocos_ExecutionEngine_i::getCurrentState (
    const char * name
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
     const StateMachinePtr ps = mee.states()->getStateMachine(name);
     if (ps && ps->isActive() )
         return CORBA::string_dup( ps->currentState()->getName().c_str() );
     return CORBA::string_dup("na");
}

CORBA::Boolean Orocos_ExecutionEngine_i::execute (
    const char * code
  )
  ACE_THROW_SPEC ((
    CORBA::SystemException
  ))
{
    return sproc.execute( code );
}
