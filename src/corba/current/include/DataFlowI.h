// -*- C++ -*-
//
// $Id$

// ****  Code generated by the The ACE ORB (TAO) IDL Compiler ****
// TAO and the TAO IDL Compiler have been developed by:
//       Center for Distributed Object Computing
//       Washington University
//       St. Louis, MO
//       USA
//       http://www.cs.wustl.edu/~schmidt/doc-center.html
// and
//       Distributed Object Computing Laboratory
//       University of California at Irvine
//       Irvine, CA
//       USA
//       http://doc.ece.uci.edu/
// and
//       Institute for Software Integrated Systems
//       Vanderbilt University
//       Nashville, TN
//       USA
//       http://www.isis.vanderbilt.edu/
//
// Information about TAO is available at:
//     http://www.cs.wustl.edu/~schmidt/TAO.html

// TAO_IDL - Generated from 
// be/be_codegen.cpp:844

#ifndef DATAFLOWI_H_
#define DATAFLOWI_H_

#include "DataFlowS.h"
#include "../DataFlowInterface.hpp"
#include "../BufferInterface.hpp"

#if !defined (ACE_LACKS_PRAGMA_ONCE)
#pragma once
#endif /* ACE_LACKS_PRAGMA_ONCE */

/*
 * This class is unused. See CorbaBuffer
 */
template< class T>
class  RTT_Corba_BufferChannel_i : public virtual POA_RTT::Corba::BufferChannel, public virtual PortableServer::RefCountServantBase
{
    typename RTT::BufferInterface<T>::shared_ptr mbuf;
public:
  //Constructor 
  RTT_Corba_BufferChannel_i (typename RTT::BufferInterface<T>::shared_ptr buf)
      : mbuf(buf)
    {}
        
  
  //Destructor 
    virtual ~RTT_Corba_BufferChannel_i (void) {}
  
  virtual
  ::CosEventChannelAdmin::EventChannel_ptr getChannel (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) { 
        RTT::Logger::In in("CorbaBufferChannelI::getChannel");
        RTT::log(RTT::Error) << "Not yet implemented."<<RTT::endlog();
        return 0;
#if 0
        // Although this theoretically works, there is currently no real benefit in supporting this.
        RTT::log(RTT::Info) << "Connecting Orocos Buffer to Corba Event Channel."<<RTT::endlog();
        CosEventChannelAdmin::EventChannel_var ec = Services::createChannel();

        RTT::Corba::CorbaBuffer<T>* buf = new RTT::Corba::CorbaBuffer<T>( mbuf, ec.in() )

        return buf->_this();
#endif
  }

    virtual CORBA::Boolean push (const ::CORBA::Any & data)
        ACE_THROW_SPEC ((
                         CORBA::SystemException
                         ))
    {
        using namespace RTT;
        Logger::In in("CorbaBufferChannelI::push");
        log(Debug) << "Receiving buffer value."<<endlog();

        T value;
        if ( AnyConversion<T>::update( data, value ) == false ) {
            Logger::log() <<Logger::Error << "Could not accept remote value: wrong data type."<<Logger::endl;
            return false;
        }

        return mbuf->Push( value );
    }

    virtual CORBA::Boolean pull ( ::CORBA::Any_out data)
        ACE_THROW_SPEC ((
                         CORBA::SystemException
                         ))
    {
        using namespace RTT;
        Logger::In in("CorbaBufferChannelI::pull");
        log(Debug) << "Returning buffer value."<<endlog();
        T result;
        if ( mbuf->Pop( result ) == false )
            return false;
        CORBA::Any_var toset = AnyConversion<T>::createAny( result );
        data = toset._retn();
        return true;
    }
  
  virtual
  ::CORBA::Any_ptr front(
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) {
      return RTT::AnyConversion<T>::createAny( mbuf->front() );
  }
  
  virtual
  CORBA::Boolean full (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) {
      return mbuf->full();
  }
  
  virtual
  CORBA::Boolean empty (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) {
      return mbuf->full();
  }
  
  virtual
  CORBA::Long capacity (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )){
      return mbuf->capacity();
  }
  
  virtual
  CORBA::Long size (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) {
      return mbuf->size();
  }
  
  virtual
  void clear (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
      )) {
      mbuf->clear();
  }
};

class  RTT_Corba_DataFlowInterface_i : public virtual POA_RTT::Corba::DataFlowInterface, public virtual PortableServer::RefCountServantBase
{
    RTT::DataFlowInterface* mdf;
public:
  //Constructor 
  RTT_Corba_DataFlowInterface_i (RTT::DataFlowInterface* dfi);
  
  //Destructor 
  virtual ~RTT_Corba_DataFlowInterface_i (void);
  
  virtual
  ::RTT::Corba::DataFlowInterface::PortNames * getPorts (
      
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
  
  virtual
  ::RTT::Corba::AssignableExpression_ptr createDataChannel (
      const char * port_name
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
  
  virtual
  ::RTT::Corba::BufferChannel_ptr createBufferChannel (
      const char * port_name
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
  
  virtual
  ::RTT::Corba::DataFlowInterface::PortType getPortType (
      const char * port_name
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
  
  virtual
  CORBA::Boolean isConnected (
      const char * port_name
    )
    ACE_THROW_SPEC ((
      CORBA::SystemException
    ));
};


#endif /* DATAFLOWI_H_  */

