<?xml version='1.0'?>
<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.3//EN"
"http://www.oasis-open.org/docbook/xml/4.3/docbookx.dtd"
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>

<article>
  <articleinfo>
    <title> Orocos Kinematics Package</title>
    <authorgroup>
      <author>
        <firstname>Peter</firstname>
        <surname>Soetens</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>

      <author>
        <firstname>Herman</firstname>
        <surname>Bruyninckx</surname>
        <affiliation>
          <orgname>K.U.Leuven</orgname>
          <address><country>Belgium</country></address>
        </affiliation>
      </author>

    </authorgroup>
    <copyright>
      <year>2002,2006</year>
      <holder>Peter.Soetens@mech.kuleuven.be</holder>
      <holder>Herman.Bruyninckx@mech.kuleuven.be</holder>
    </copyright>

    <abstract>
      <para>
	This document explains the design and implementation of the
	Kinematics package.
      </para>
    </abstract>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this
	document under the terms of the GNU Free Documentation
	License, Version 1.1 or any later version published by the
	Free Software Foundation, with no Invariant Sections, with no
	Front-Cover Texts, and with no Back-Cover Texts. A copy of
	this license can be found at <ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>
  </articleinfo>
  <section>
    <title>Introduction</title>
    <para>
      This section explains installation, and gives an overview of the
      features and interface of the &orocos; &kindynpkg;.
    </para>
    <section>
      <title>Installation</title>
      <para>
        Install the Orocos Geometry package first, it contains
	definitions of frames, twists etc.
	A package is provided on the Orocos web page.
      </para>
      <para>
	&orocos; uses the eCos tools for configuration and building.
	Therefore the configuration and building process is pretty
	well standardised. We refer to the Orocos Base installation
	instructions for the advised configuration and installation
	procedure. 
      </para>
    </section>
    <section><title>Prerequisites</title>
      <tip>
	<para>	We highly advise you to read first the Orocos CoreLib and Geometry
	documentation before going on.
	</para>
      </tip>
      <tip>
	<para>This document only covers some generic use cases. If you want detailed
	information about a class or function, read the Doxygen generated reference
	of this package. You will find a lot of complementary
	information in there not presented here.</para>
      </tip>
    </section>
  </section>
  <section>
    <title>Kinematics</title>
    <section>
      <title>Introduction</title>
      <para>
	Kinematics are used for converting postions, velocities,...
	expressed in one (orthogonal) frame, to another frame or
	another space. The two major spaces in Robotics are Cartesian
	space and Joint space. Cartesian space uses 3D coordinates for
	position and a kind of convention for orientation ( the
	homogeneous transformation matrix, Euler angles,...), while
	joint space is just the radial position of each joint, thus
	for a 6 degrees of freedom robot, this is a vector with 6
	values, denoting the six joint positions.
      </para>
      <para>
	Forward kinematics is used to calculate from a given set of
	joint positions the end effector position of the robot in a
	kind of reference frame. Inverse kinematics is used to
	calculate from a given end effector position, expressed in a
	certain frame, the joint positions which lead to this
	position. The solutions of the inverse kinematics can not
	always be found because : The position might be impossible to
	reach by the robot, or, the position might be reachable in
	many ways by the robot (called different configurations), or,
	the joint positions can not be calculated because the end
	effectors position is singular, which means that it can be
	reached in an infinite amount of ways by the joints.
      </para>
      <para>
	Our kinematics algorithms keep track of all the above and much
	more. This can clearly be seen from the used interfaces too.
      </para>
      <section>
	<title>Kinematics Value Types</title>
	<para>
	  The types used to convert to and from in the kinematic
	  algorithms are defined in the
	  <filename>KinematicsTypes.hpp</filename> file in the
	  <classname>ORO_KinDyn</classname> namespace. For example,
	  joint positions, values,... are represented by the classes
	  <classname>JointPositions</classname>,
	  <classname>JointVelocities</classname>,
	  <classname>JointAccelerations</classname>,...  which have
	  the same interface as a
	  <classname>std::vector&lt;double&gt;</classname>.  Jacobians
	  are represented by the <classname>Jacobian</classname> class
	  which has the same interface as a Boost::uBlas Matrix, see
	  <ulink url="http://www.boost.org/libs/numeric/ublas/doc/">
	  Boost::uBlas Library</ulink>. The frames, vectors,
	  twists,...  are used from the
	  <classname>ORO_Geometry</classname> classes
	  <classname>ORO_Geometry::Frame</classname>, <classname>ORO_Geometry::Vector</classname>,
	  <classname>ORO_Geometry::Twist</classname>,...
	</para>
      </section>
      <section>
	<title>The KinematicsInterface</title>
	<para>
	  The <classname>ORO_KinDyn::KinematicsInterface</classname>
	  describes the library side of the kinematics
	  algorithms. The interface allows you to calculate all
	  forward and inverse jacobians, positions and velocities. A
	  desired <classname>ORO_KinDyn::Configuration</classname> and a
	  <classname>ORO_KinDyn::Singularity</classname> class instance must be
	  provide where approriate. How the kinematics are calculated
	  depends on the actual implementation. We provide the
	  Featherstone algorithms for many kinds of robots. Only the
	  ZXXDWH and ZYYDWH robots are converted to the
	  KinematicsInterface. You can take a look at how we converted
	  them to fit into the framework if you have a different kind
	  of robot.
	</para>
	<para>
	  The KinematicsInterface is completely stateless and returns
	  theoretical values, thus does not take into account any
	  geometry constraints or winding of joints (angles larger
	  than 360 degrees). All state information is kept in the
	  <classname>ORO_KinDyn::KinematicsComponent</classname>.
	</para>
      </section>
      <section>
	<title>The KinematicsFactory</title>
	<para>
	  The <classname>ORO_KinDyn::KinematicsFactory</classname> class can be
	  used to add or create <classname>ORO_KinDyn::KinematicsInterface</classname>
	  objects. Currently, only the Kuka 160 and Kuka 361 robots
	  can be created, but it is designed as such that it can be
	  extended by users for other robot types. It can save kinematic
	  device configurations to XML files and read them again later.
	</para>
	<para>
	  To create an object, use:
	  <programlisting>  #include &lt;kindyn/KinematicsFactory.hpp>
  //...
  <classname>ORO_KinDyn::KinematicsInterface</classname>* kine = <classname>ORO_KinDyn::KinematicsFactory</classname>::Create("Kuka160");
  
  // or save to file:
  KinematicsFactory::SaveDevice("Kuka160", "kuka160.xml");
  // load it again with possibly updated values:
  KinematicsFactory::LoadDevice("kuka160.xml");
  // each newly created KinematicsInterface object 
  // gets the new configuration.</programlisting>
	</para>
      </section>
      <section>
	<title>The KinematicsComponent</title>
	<para>
	  As each robot only needs one instance of the
	  <interfacename>KinematicsInterface</interfacename>, for
	  doing the calculations, many are needed to keep track of the
	  current path and configuration of the robot in different
	  places of your program. The
	  <classname>ORO_KinDyn::KinematicsComponent</classname> makes
	  sure that between two consecutive calls, the robot stays in
	  the same configuration and the joints follow a continuous
	  path.  It will return in error when an impossible jump is
	  detected.  It provides methods for setting or extracting the
	  desired robot configuration. For example, your trajectory
	  generator and the actual robot might be using a different
	  KinematicsComponent to keep track of the state of the
	  calculations.
	</para>
	<para>
	  See the <classname>ORO_KinDyn::KinematicProcess</classname> for use
	  of kinematics in the Control Kernel.
	</para>
      </section>
    </section>
  </section>
<!--
  <section id="chap-interface">
    <title>Interfaces</title>
    <para>
      This section describes the <emphasis>interfaces</emphasis> of
      the different components in the motion control part of &orocos;.
    </para>

    <section id="interface-motivation">
      <title>Motivation</title>
      <para>
A complex and feature-rich application such as motion control can be
	given various different interfaces. This Section explains and
	motivates the guidelines we follow in the &orocos; project to
	define interfaces:
<itemizedlist>

	  <listitem>
	    <para>
	      <emphasis>Loose coupling.</emphasis> Every object that
	      implements an interface must implement the whole
	      interface. This means that interfaces are kept as small
	      a possible, and that every object usually implements
	      several interfaces. The reasons for this choice are: (i)
	      it avoids the need to return &ldquo;method not
	      implemented&rdquo; error messages and the corresponding
	      error recovery; and (ii) it forces the developers to
	      classify functionality into parts with the least
	      possible amount of interdependencies.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>Application independence.</emphasis> The words
	      &ldquo;robot&rdquo; or &ldquo;machine tool&rdquo; are
	      avoided whenever possible, because most of the
	      functionalities are much more general than just for
	      robots or machine tools.
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>Shallow inheritance hierarchies.</emphasis> We
	      avoid inheritance hierarchies of more than two levels
	      deep, because deep hierarchies lead to ambiguous
	      inheritance structure. For example, one could suggest to
	      have a hierarchy such as &ldquo;robot&rdquo; &map;
	      &ldquo;6DOF robot&rdquo; &map; &ldquo;6DOF
	      velocity-controlled robot&rdquo; &map; &ldquo;6DOF
	      hybrid velocity/force-controlled robot&rdquo; &map;
	      &hellip; But the latter interface could originate
	      equally well from another hierarchy, such as
	      &ldquo;control law&rdquo; &map; &ldquo;velocity
	      control&rdquo; &map; &ldquo;hybrid force/velocity
	      control&rdquo; &map; &ldquo;6DOF hybrid force/velocity
	      control.&rdquo;
	    </para>
	  </listitem>

	  <listitem>
	    <para>
	      <emphasis>Inheritance versus aggregation and
		composition.</emphasis> A particular interface can be
	      a <emphasis>specialisation</emphasis> of an already
	      existing interface, for which inheritance is an
	      appropriate formalism. But an interface can also the
	      <emphasis>composition</emphasis> or
	      <emphasis>aggregation</emphasis> of other interfaces,
	      i.e., the interface contains other interfaces, and
	      possibly puts extra constraints on how to use the
	      individual interfaces. The difference between
	      aggregation and composition is that, in the latter case,
	      the object that implements the composed interface cannot
	      exist if one of its sub-interfaces is taken out.
	    </para>
	  </listitem>

</itemizedlist>
      </para>

    </section>


    <section id="interface-cart-motion">
      <title>Cartesian motion</title>
      <para>
	moveTo (Cartesian position); move (Cartesian velocity);
      </para>

    </section>

    <section id="interface-axis-motion">
      <title>Axis</title>
      <para>
	readId(); setId();
      </para>
      <para>
	moveTo (joint position set); move (joint velocity set);
      </para>
      <para>
	readPos (joint position set); readVel (joint position set);
      </para>
      <para>
	applyForce (joint velocity set); readForce (joint velocity
	set); 
      </para>
      <para>
	home ();
      </para>

    </section>

    <section id="interface-device">
      <title>Device</title>
      <para>
	readId(); setId();
      </para>
      <para>
	Activate(), deactivate().
      </para>

    </section>

    <section id="interface-robot">
      <title>Robot</title>
      <para>
	readId(); setId();
      </para>
      <para>
	composite of Axis objects;
      </para>

    </section>

    <section id="interface-servo">
      <title>Servo</title>
      <para>
      </para>

    </section>

    <section id="interface-trajectory">
      <title>Trajectory</title>
      <para>
      </para>

    </section>

    <section id="interface-interpolation">
      <title>Interpolation</title>
      <para>
      </para>

    </section>

  </section>
-->
</article>
