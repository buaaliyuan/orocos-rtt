<?xml version='1.0'?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd" 
[
<!ENTITY cvs         "<acronym>CVS</acronym>">
<!ENTITY orocos      "<acronym>Orocos</acronym>">
<!ENTITY rtai        "<acronym>RTAI</acronym>">
<!ENTITY rtos        "<acronym>RTOS</acronym>">
]
>

<article>
 <articleinfo>
    <title>
      The OROCOS Project 
    </title>
    <subtitle><emphasis>Open RObot COntrol Software</emphasis>
    </subtitle>
    <authorgroup>
      <author>
	<firstname>Herman</firstname>
	<surname>Bruyninckx</surname>
      </author>
      
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
      </author>

    </authorgroup>
    <copyright>
      <year>2002,2003,2004,2005,2006</year>
      <holder>Herman Bruyninckx, Peter Soetens</holder>
    </copyright>

    <abstract>
      <para>
	This document gives an application oriented overview of
	<ulink url="http://www.orocos.org">&orocos;</ulink>,
	the <emphasis>Open RObot COntrol Software</emphasis> project. 
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>05 Dec 2002</date>
	<authorinitials>hb</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.19.2</revnumber>
	<date>11 March 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added Application Stack figure, removed confusing
	  objects and components section, adapted vision :-)</revremark>
      </revision>
      <revision>
	<revnumber>0.22.0</revnumber>
	<date>7 March 2006</date>
	<authorinitials>ps</authorinitials>
	<revremark>Added section 'Building Orocos Applications"</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <section id="whatis">
    <title>What is Orocos?</title>
    <para>
      &ldquo;&orocos;&rdquo; is the acronym of the
      <emphasis><ulink url="http://www.orocos.org">Open Robot Control
	  Software</ulink></emphasis> project. The project's aim is to develop
      a general-purpose, free software, and modular <emphasis>framework</emphasis>
      for <emphasis>robot</emphasis>and <emphasis>machine control</emphasis>.
    </para>
    <para>
      A framework is a set of source code from which applications in a
      particular domain can be made <citation>Johnson97</citation>). So, the
      framework is not an application
      in itself, but it provides the infrastructure and the functionalities to
      build applications in C++.  Usually, application builders must fill
      in some &ldquo;hot spots&rdquo; that are specific to their
      application, and hence, which cannot be provided by the framework.
    </para>
    <para>
      &orocos; works in a &ldquo;bottom-up&rdquo; fashion, so current
      activities are currently more focused on developing 
      <emphasis>basic infrastructure</emphasis> than on implementing
      advanced control, planning or sensor processing algorithms.
    </para>
    <para>
      &orocos; is a free software project, hence its code and documentation
      are released under Free Software licenses.
    </para>
    <para>
      Your feedback and suggestions are greatly appreciated. Please, use the
      project's 
      <ulink
	url="http://lists.mech.kuleuven.be/mailman/listinfo/orocos">mailinglist</ulink> for this purpose.
    </para>
  </section>
  <section id="audience">
    <title>Target audience</title>
    <para>
      Robotics or machine control in general is a very broad field,
      and many roboticists are pursuing quite different goals, dealing
      with different levels of complexity, real-time control
      constraints, application areas, user interaction, etc.  So,
      because the robotics community is not homogeneous, &orocos;
      targets four different categories of &ldquo;Users&rdquo; (or, in
      the first place, &ldquo;Developers&rdquo;):
      <orderedlist>
	<listitem>
	  <para>
	    <emphasis>Framework Builders.</emphasis>
	  </para>
	  <para>
	    These developers do not work on any specific application, but
	    they provide the infrastructure code to support applications. This
	    level of supporting code is most often neglected in robot software
	    projects, because in the (rather limited) scope of each individual 
	    project, putting a lot of effort in a generic support platform is
	    often considered to be &ldquo;overkill&rdquo;, or even not taken into
	    consideration at all. However, because of the large scope of the
	    &orocos; project, the supporting code (the &ldquo;Framework&rdquo;)
	    gets a lot of attention. The hope is, of course, that this work will
	    pay of by facilitating the developments for the other
	    &ldquo;Builders&rdquo;.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Component Builders.</emphasis>
	  </para>
	  <para>
	    Components provide a &ldquo;service&rdquo; within an
	    application.  Using the infrastructure of the framework, a
	    Component Builder describes the interface of a service and
	    provides one or more implementations. For example a 
	    Kinematics Component may be designed as such that it can
	    &ldquo;serve&rdquo; different kinematic architectures.
	    Other examples are Components to hardware devices, Components
	    for diagnostics, safety or simulation.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>Application Builders.</emphasis>
	  </para>
	  <para>
	    These developers use the &orocos;' Framework and Components, and
	    integrate them into one particular application. That means that they
	    add a specific, application-dependent
	    <emphasis>architecture</emphasis> on top
	    of the functionalities offered by the Framework and the Components.
	    An example Orocos application is the Orocos Control Kernel, which
	    provides an application framework for (motion) control, with a set
	    of components which implement control or planning algorithms.
	  </para>
	</listitem>
	<listitem>
	  <para>
	    <emphasis>End Users.</emphasis>
	  </para>
	  <para>
	    These people use the products of the Application Builders to program
	    and run their particular tasks.
	  </para>
	</listitem>
      </orderedlist>
      The focus in the &orocos; project lies primarily with the Framework
      Builders and the Component Builders. But, since all contributors
      are motivated by their own particular applications, the needs of
      the Application Builders are also taken into account, albeit
      indirectly. 
    </para>
    <para>
      End Users do not directly belong to the target audience of
      the &orocos; project, because &orocos; concentrates on the common
      <emphasis>framework</emphasis>, independent of any application
      architecture. Serving the needs of the End Users is left to
      (commercial and non-commercial) Application Builders.
    </para>
  </section>
  <section>
    <title>Building Orocos Applications</title>
    <para>
      Orocos applications are composed of software components, which form
      an application specific network. When using Orocos, you can choose
      to use predefined components, contributed by the community, or
      build your own component, using the Orocos Real-Time Toolkit. 
      This section introduces both ways of building applications.
    </para>
      <figure id="fig-orocos-toolkit">
	<title>
	  Orocos Real-Time Toolkit
	</title>
	<mediaobject>
	  <imageobject>
	    <imagedata fileref="svg/RealTimeToolkit" />
	  </imageobject>
	</mediaobject>
      </figure>
      <section>
	<title>Application Templates</title>
	<para>
	  The layer above the Control Components is formed by the
	  The "Application Templates" are the kick-start 'Component
	  tapers' which do nothing more than selecting and connecting
	  a few components which work well together in order to
	  realise a running application. An application template
	  should be so simple that any Orocos user can pick one and
	  modify it, hence it is the first thing a new user will
	  encounter. An application template should be explainable on
	  one page with one figure explaining the architecture.
	</para>
	<note>
	  <para>We are currently reworking the template infrastructure
	  to match this description.  The current "Control Kernel"
	  application template does not fit that description very well
	  and will disappear as such [v1.0]. Also, an application
	  template will have no longer any relation to 'C++'
	  templates.
	  </para>
	</note>
      </section>
      <section>
	<title>Control Components</title>
	<para>
	  Applications are constructed using the Orocos
	  "Control Component". A distributable entity which has a
	  control oriented interface.  
	</para>
	<figure id="fig-orocos-component-interface">
	  <title>
	    Orocos Control Component Interface
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="svg/ComponentInterface" />
	  </imageobject>
	  </mediaobject>
	</figure>
	<para>
	  A single component may be well capable of controlling a
	  whole machine, or is just a 'small' part in a whole network
	  of components, for example an interpolator or kinematic
	  component. The components are built with the "Real-Time
	  Toolkit" and optionally make use of any other library (like
	  a vision or kinematics toolkit). Most users will interface components
	  through their (XML) properties or command/method interface
	  in order to configure their applications.
	</para>
	<note><para>
	  The current Orocos 'Control
	  Kernel' components need to be converted in order to fit in
	  this description and are to be split off in separate
	  packages [v1.0].
	</para></note>
	<para>
	  The Component interface is defined by the
	  'TaskContext' class as released in version 0.22.0 and
	  described in the "Component Builders Guide".
	</para>
	<para>
	  There are five distinct ways in which an Orocos
	  component can be interfaced: through its properties,
	  events, methods, commands and data flow ports
	  (<xref linkend="fig-orocos-component-interface" />).
	  These are all optional interfaces. The purpose and
	  use of these interface 'types' is documented in the
	  Orocos Component Builder's Manual. Each component
	  documents its interface as well. To get a grip
	  on what these interfaces mean, here are some
	  fictuous component interfaces for a 'Robot' Component:
	<itemizedlist>
	  <listitem>
	    <para><emphasis>Properties:</emphasis>
	    Are run-time modifyable parameters, stored
	    in XML files. For example:
	    "Kinematic Algorithm", "Control Parameters", 
	    "Homing Position", "ToolType",...</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>Events:</emphasis> 
	    Provide a 'callback' mechanism to 'publish'
	    a change to 'subscribers'. For example:
	    "Position Reached", "Emergency Stop", 
	    "Object Grasped",...</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>Methods:</emphasis> Are callable by other
	    components to 'calculate' a result immediately, just like
	    a 'C' function. For example: "getTrackingError()",
	    "openGripper()", "writeData("filename")", "isMoving()",
	    ...</para>
	  </listitem>
	  <listitem>
	    <para><emphasis>Commands:</emphasis> Are 'sent' by other
	    components to instruct the receiver to 'reach a goal' For
	    example: "moveTo(pos, velocity)", "home()",... A command
	    cannot, in general, be completely executed
	    instantaneously, so the caller should not block and wait
	    for its completion. But the Command object offers all
	    functionalities to let the caller know about the progress
	    in the execution of the command.
	    </para>
	  </listitem>
	  <listitem>
	    <para><emphasis>Data-Flow Ports:</emphasis> Are a 'raw'
	    data transport mechanism to communicate buffered or
	    un-buffered data between components.  For example:
	    "JointSetpoints", "EndEffectorFrame",
	    "FeedForward",...</para>
	  </listitem>
	</itemizedlist>
	</para>
	<para>
	  Besides defining the above component communication
	  mechanisms, Orocos allows the Component or Application
	  Builder to write hierarchical state machines which use these
	  primitives. This is the Orocos way of defining your
	  application specific logic. State machines can be (un-)loaded
	  at runtime in any component.
	<figure id="fig-orocos-component-implementation">
	  <title>
	    Orocos Control Component State Machines.
	  </title>
	  <mediaobject>
	    <imageobject>
	      <imagedata fileref="svg/ComponentImplementation" />
	  </imageobject>
	  </mediaobject>
	</figure>
	</para>
      </section>
      <section><title>Orocos Toolkits</title>
      <para>
	The lowest level of Orocos will exist out of 3 independent libraries:
	The "Real-Time Toolkit", the "Bayesian Filtering Library" and the "Kinematics 
	and Dynamics Library". The project is currently refactoring some parts 
	in preparation of the 1.0 release. These changes are marked with 
	a version number such as [v1.0].
      </para>
      <section>
	<title>Real-Time Toolkit (RTT)</title>
	<para>
	  This is a set of C++ classes which allows a developer to
	  build Orocos components. It provides the OS
	  abstraction, low-level device drivers and device interfaces,
	  and the 'task infrastructure' to build components.  It also
	  encapsulates any distribution (using CORBA [v0.24.0]) specific code required
	  to distribute components. This is what we are now calling
	  the 'Real-Time Control Services' on our website. The 
	  <emphasis>real-time</emphasis> stands for time determinism and
	  thread-safety but does not automatically require a real-time
	  Operating System to be useful. The aim is that beginning
	  Orocos users will not be working immediately with this
	  toolkit, but use the ready made components instead.
	</para>
      </section>
      <section>
	<title>Bayesian Filtering Library (BFL)</title>
	<para>
	  This C++ library can be used independently of Orocos today but will get a more 
	  prominent place on the Orocos webpage. It will be used by Orocos Components
	  which (actively) do intelligent sensor processing [v1.0]. Current BFL users will 
	  still be able to use this library as before.
	</para>
      </section>
      <section>
	<title>Kinematics and Dynamics Library (KDL)</title>
	<para>
	  This C++ library is today integrated within Orocos as the 'geometry' and 
	  'kindyn' packages. It will be split off [v1.0] as an independent library for 
	  kinematics usable by developers who do not wish to use the Real-Time Toolkit. 
	  Credits go to Erwin Aertbelien who developed a major part of this library, 
	  and new candidates are ready to take over the job.
	</para>
      </section>
    </section>
  </section>
  <section>
    <title>Related 'Orocos' Projects</title>
    <para>
      The Orocos project spawned a couple of largely independent
      software projects. The documentation you are reading is about
      the Real-Time Control Software located on the Orocos.org webpage.
      The other <emphasis>not real-time</emphasis> projects are :
      <itemizedlist>
	<listitem>
	  <para>At KTH Stockholm, several releases have been made for
	    component-based robotic systems, and the project has been
	    renamed to <ulink
	      url="http://orca-robotics.sourceforge.net/">Orca</ulink>.</para>
	</listitem>
	<listitem>
	  <para>
	    Although not a project funded partner, the FH Ulm
	    maintains Free CORBA communication patterns for modular
	    robotics : <ulink
	      url="http://www.rz.fh-ulm.de/~cschlege/orocos/">Orocos::SmartSoft</ulink>.
	  </para>
	</listitem>
      </itemizedlist>
      This documentation is targetted at industrial robotics and real-time control.
    </para>
  </section>
</article>
