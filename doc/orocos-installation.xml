<?xml version='1.0'?>

<!DOCTYPE article PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
"/usr/share/sgml/docbook/dtd/xml/4.1.2/docbookx.dtd" 
[
<!ENTITY % oro_ents SYSTEM "http://people.mech.kuleuven.ac.be/~psoetens/orocos/doc/orocos.ent" >
%oro_ents;
]
>


<article>
  <articleinfo>
    <title>
      The OROCOS Installation Guide 
    </title>
    <subtitle><emphasis>Open Robot Control Software Version &oversion;</emphasis></subtitle>
    <authorgroup>
      <author>
	<firstname>Peter</firstname>
	<surname>Soetens</surname>
      </author>
    </authorgroup>
    <copyright>
      <year>2002,2003,2004,2005</year>
      <holder>Peter Soetens</holder>
    </copyright>

    <abstract>
      <para>
	This document explains how the
	packages of <ulink url="http://www.orocos.org">&orocos;</ulink>,
	the <emphasis>Open RObot COntrol Software</emphasis> project
	must be installed and configured.
      </para>
    </abstract>

    <revhistory>
      <revision>
	<revnumber>0.01</revnumber>
	<date>28 Oct 2003</date>
	<authorinitials>ps</authorinitials>
	<revremark>Initial version</revremark>
      </revision>
      <revision>
	<revnumber>0.02</revnumber>
	<date>21 Jan 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>ecostools updates</revremark>
      </revision>
      <revision>
	<revnumber>0.18.0</revnumber>
	<date>1 Dec 2004</date>
	<authorinitials>ps</authorinitials>
	<revremark>easier make system documented, reordered the sections</revremark>
      </revision>
      <revision>
	<revnumber>0.20.0</revnumber>
	<date>28 Feb 2005</date>
	<authorinitials>ps</authorinitials>
	<revremark>added upgrade section</revremark>
      </revision>
    </revhistory>

    <legalnotice>
      <para>
	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1 or
	any later version published by the Free Software Foundation, with no
	Invariant Sections, with no Front-Cover Texts, and with no Back-Cover
	Texts. A copy of this license can be found at
	<ulink
	  url="http://www.fsf.org/copyleft/fdl.html">http://www.fsf.org/copyleft/fdl.html</ulink>.
      </para>
    </legalnotice>

  </articleinfo>

  <sect1>
    <title> Setting up your first &orocos; source tree </title>
    <sect2 id="setup_intro">
      <title>Introduction</title>
      <para>
	This sections explains the supported Orocos targets
	and the Orocos versioning scheme.
      </para>
      <sect3>
	<title>Supported platforms (targets)</title>
	<para>
	  &orocos; was designed with portability in mind. Currently, we support RTAI and (NEW)LXRT
	  (<ulink url="http://www.rtai.org">http://www.rtai.org</ulink>), GNU/Linux
	  userspace, and very limited RTLinux (<ulink
	    url="http://www.fsmlabs.com">http://www.fsmlabs.com</ulink> and
	  <ulink url="http://www.rtlinux-gpl.org/"></ulink>). So,
	  you can first write your software as a normal program, using the framework
	  for testing and debugging purposes in plain userspace Linux and recompile
	  later to another target.
	</para>
	<para>
	  RTAI with LXRT is the best supported realtime platform at this moment. RTLinux can
	  only partially use all &orocos; features, because it lacks a decent
	  kernel space memory manager. Furthermore, since no Orocos user is using the 
	  FSMLabs RTLinux port, it is no longer updated.
	</para>
      </sect3>
      <sect3>
	<title>The versioning scheme</title>
	<para>
	  &orocos; uses the well-known even/stable uneven/unstable
	  version numbering scheme, just as the Linux kernel and many
	  other projects. A particular version is represented by three
	  numbers separated by dots. An <emphasis>even</emphasis>
	  middle number indicates a <emphasis>stable</emphasis>
	  version. For example :
	  <itemizedlist>
	    <listitem><para>0.1.4 : Release 0, unstable (1), revision
		4.</para></listitem>
	    <listitem><para>1.2.1 : Release 1, stable   (2), revision
		1.</para></listitem>
	  </itemizedlist> This numbering allows to develop and release
	  two kinds of versions, where the unstable version is mainly
	  for testing new features and designs and the stable version
	  is for people wanting to run a reliable system.
	</para>
      </sect3>
      <sect3>
	<title>Dependencies on other Libraries</title>
	<para>Before you install Orocos, verify that you have the
	following software installed on your platform : </para>
	<table frame="all">
	  <title>Build Products Locations</title>
	  <tgroup cols="3">
	    <thead>
	      <row>
		<entry>Program / Library</entry>
		<entry><strong>Minimum</strong> Version</entry>
		<entry>Description</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry>Python</entry>
		<entry>2.2</entry>
		<entry><ulink url="http://www.python.org">Python.org</ulink></entry>
	      </row>
	      <row>
		<entry>TCL</entry>
		<entry>8.0</entry>
		<entry><ulink url="http://www.tcl.tk">tcl.tk</ulink></entry>
	      </row>
	      <row>
		<entry>wxGTK</entry>
		<entry>2.4.1</entry>
		<entry><ulink url="http://www.wxwindows.org/">wxwindows.org</ulink></entry>
	      </row>
	      <row>
		<entry>Boost C++ Libraries</entry>
		<entry>0.32.0 (0.33.0 Recommended!)</entry>
		<entry><ulink url="http://www.boost.org">Boost.org</ulink></entry>
	      </row>
	      <row>
		<entry>GNU gcc / g++ Compilers</entry>
		<entry>3.3.0</entry>
		<entry><ulink url="http://gcc.gnu.org">gcc.gnu.org</ulink></entry>
	      </row>
	      <row>
		<entry>Xerces C++ Parser</entry>
		<entry>2.1</entry>
		<entry><ulink url="http://xml.apache.org/xerces-c/">Xerces website</ulink></entry>
	      </row>
	      <row>
		<entry>GNU Readline Library</entry>
		<entry>4.0</entry>
		<entry><ulink url="http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html">Readline website</ulink></entry>
	      </row>
	      <row>
		<entry>CppUnit Library</entry>
		<entry>1.9.6</entry>
		<entry><ulink url="http://cppunit.sourceforge.net/cgi-bin/moin.cgi">CppUnit website.</ulink>
		  Only needed if you want to run the Orocos tests.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>
	<para>
	  All these packages are provided by most Linux distributions.
	  Take also a look on the Orocos.org download page for
	  the latest information. 
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Basic Orocos Installation</title>
      <para>
	Orocos has switched to a less common system for distribution
	and configuration. It is taken from the eCos operating system,
	but, apart from the name, has nothing to do with it when used
	with &orocos;. </para>

      <sect3>
	<title>Orocos Build and Configuration Tools </title>
	<para>
	  The tools you will need are <command>ecosconfig</command>
	  and <command>configtool</command>. In Debian, you can use
	  the official Debian version using
	  <screen>  apt-get install ecosconfig</screen>
	  If this does not work for you, you can
	  try the ready-to-use tools in Orocos' tools/bin
	  subdirectory. The build system will try to locate the tools
	  in that directory and use them if present.
	</para>
	<para>
	  If the build tools cause problems, consult the <ulink
	    url="http://www.ecoscentric.com/devzone/configtool.shtml"> eCos
	    Configuration Tool Version 2</ulink> webpage for source
	  and binary downloads or consult the <ulink url="http://www.orocos.org/download.php#ecostools">
	    Orocos download page</ulink>.
	</para>
	<note>
	  <para>
	    <command>configtool</command> is a GUI in which users can configure
	    their packages. It uses the libwxgtk2.4 library.
	    <command>ecosconfig</command> is a commandline program, used by
	    the make system.
	  </para>
	</note>
	<para>
	  These tools both serve the same purpose : to control package
	  configuration and installation. Ecosconfig is command-line
	  based, configtool is a graphical tool. The eCos folks wrote
	  an (eCos-oriented) manual which explains them in great
	  detail in <ulink url=
	    "http://sources.redhat.com/ecos/docs-latest/user-guide/ecos-user-guide.html"> 
	    the user guide</ulink> and how packages work internally is
	  written in the <ulink
	    url="http://sources.redhat.com/ecos/docs-latest/cdl-guide/cdl-guide.html"> 
	    eCos Component Writer Guide</ulink>.
	    <note>
	      <para>
		In the eCos Operating System, a target is a
		hardware platform, in Orocos, a target is RTAI, GNU/Linux,
		LXRT and so on, so you can skip all hardware specific
		sections in the eCos manuals.
	      </para>
	    </note>
	</para>
      </sect3>
      <sect3>
	<title>Quick Installation Instructions</title>
	<para>
	  It is possible to download Orocos with the <ulink url="http://www.orocos.org/releases/orocos-install.tcl">
	    orocos-install.tcl</ulink> script, <emphasis>this is recommended</emphasis>.
	</para>
	<para>Save the script to your local drive and then do :</para>
	<screen><command>  $ tclsh orocos-install.tcl</command></screen>
	<para>
	  and follow the instructions. Watch for errors or warnings carefully !
	</para>
	<para>
	  After the script finishes, make sure you followed the closing instructions to source
	  the <command>orocosenv.sh</command> script :
	  <screen><command>  source orocosenv.sh
  mkdir orocos-&oversion;/build 
  cd orocos-&oversion;/build
  ../configure --with-&lt;target&gt;
  make new_packages 
  make configure_packages
  make all</command> </screen>
	  Where &lt;target&gt; is one of listed in <command>../configure --help</command>.
	  ( currently 'gnulinux' or 'lxrt' )
	  <command>make configure_packages</command>
	  will pop up a graphical configuration
	  tool which allows you to add or remove packages from your configuration.
	  Before a package can be added to a configuration,
	  the package must be present in the packages repository.
	</para>
	<note>
	  <para>
	    The <command>../configure</command> script must be rerun after
	    you installed missing libraries (like Boost, Xerces,...).
	  </para>
	</note>
	<para>
	  For convenience, Orocos can also be used as a regular configure/make 
	  system. It is thus allowed to :
	  <screen> <command>  mkdir orocos-&oversion;/build 
  cd orocos-&oversion;/build
  ../configure --with-&lt;target&gt;
  make all
  make check
  make install</command> </screen>
	  but this will use the default Orocos configuration. If you want to
	  add/remove packages and configure options, you need to run
	  <command>make configure_packages</command> and
	  <command>make</command> again.
	</para>
	<warning>
	  <para>
	    <command>make new_packages</command> will overwrite any
	    existing configuration !
	  </para>
	</warning>
	<para>
	  Each package will have been installed in a
	  <filename>packages/package-name/version/</filename> directory,
	  allowing multiple versions to be installed next to each other.
	  The repository version is always called 'current', and
	  considered as the most recent version. If you downloaded the
	  epk files, you will find a version number in place.
	</para>
      </sect3>
      <sect3>
	<title>Configuration</title>
	<para>
	  Orocos is configured in a two-stage system. First the configure scripts
	  detect available libraries and take some command-line options to point
	  it in the right direction. Also, it takes the Operating System you want
	  to configure for as an argument ( <parameter>--with-lxrt</parameter>,
	  <parameter>--with-gnulinux</parameter>). 
	</para>
	<para>
	  The second stage is when you issue a <command>make configure_packages</command>,
	  which will show a GUI where you can further tweak build flags and package
	  specific options.
	  This is also the stage where you can add/remove packages for compilation.
	</para>
	  <informalfigure>
	    <mediaobject>
	      <imageobject role="html">
		<imagedata fileref="ConfigTool" />
	      </imageobject>
	      <imageobject role="fo">
		<imagedata format="JPG" fileref="ConfigTool.jpg" />
	      </imageobject>
	    </mediaobject>
	  </informalfigure>
	<para>
	  When you completed these two stages, you can now <command>make</command>.
	  For more details, consult <xref linkend="install-configure"/>.
	</para>
      </sect3>
      <sect3>
	<title>Building RealTime Control Services or Robot Control Software</title>
	<para>
	  Building all of Orocos takes a long time. We provided two build targets
	  which allow you to specify what to build. <screen><command> make control_services </command></screen>
	  builds the Core Library, the Program Parsing and Execution Infrastructure
	  and the OS and Device Interfaces. These are the most important 'core'
	  parts or Orocos, and are sufficient for the 'taskintro' application and
	  contains everything described in the 'RealTime Control Services' Manual.
	</para>
	<para>
	   <screen><command> make robot_control </command></screen> builds the 
	   same packages as control_services, but adds kinematics, the control framework
	   and the control kernel components  and
	   contains everything described in the 'Robot Control Software' Manual.
	</para>
	<para>
	  Even then, not all packages are build. Type  <screen><command> make configure_packages </command></screen>
	  to add or remove specific packages to suit your needs.
	</para>
      </sect3>
      <sect3>
	<title>Manual Download Instructions</title>
	<para> If you choose to download the tools and packages manually, proceed as follows :
	</para>
	<orderedlist>
	  <listitem><para>Download orocos-&oversion;.i386linux package from the Orocos webpage</para></listitem>
	  <listitem><para>Extract it using :
	      <screen><command>  tar -xvzf orocos-&oversion;.i386linux.tar.bz2	</command></screen>
	    </para></listitem>
	  <listitem><para>Setup the base environment : 
	      <screen><command>  cd orocos-&oversion;
  EXPORT PATH=$PATH:$(pwd)/tools/bin
  mkdir build
  cd build
  ../configure	</command> </screen>
	    </para></listitem>
	</orderedlist>
	<para>
	  Now you can proceed with the Quick Installation Instructions from the
	  previous section.
	</para>
      </sect3>
      <sect3>
	<title>Building</title>
	<para>
	  The <command>make all</command> command will have made a directory
	  <filename>packages</filename> where the
	  building takes place. The results of the build are in the
	  <filename>packages/install</filename>
	  directory. You will find the header files and a library called
	  <filename>libtarget.a</filename> (literally) and
	  <filename>liborocos-&lt;target>.a</filename>. These files
	  allow you to build applications with &orocos;.
	</para>
	<para>
	  The <command>make configure_packages</command> will pop up a graphical frontend
	  to configuration. When you save and exit, a file
	  <filename>packages/orocos.ecc</filename> will
	  be generated which contains all your custom options.
	  <tip>
	    <para>Make a copy of the orocos.ecc file so that you always have
	      a backup when it gets accidentally overwritten.</para>
	  </tip>
	</para>
      </sect3>
      <sect3>
	<title>Using &orocos; concurrently for multiple targets</title>
	<para>
	  When you want to build for another target,
	  create a new build-&lt;target&gt; directory and simply re-invoke ../configure --with-&lt;target&gt;
	  from that build directory.
	</para>
	<para>
	  If this step fails, it means that you have not everyting installed
	  which is needed for a basic &orocos; build. Most users don't have the
	  Boost library (<filename>libboost-dev</filename> or
	  <filename>libboost-devel</filename>) installed.  Please install this
	  package from the binary or source package repository of your Linux
	  distribution, or download and install it from the <ulink
	    url="http://www.boost.org">Boost project.</ulink> As soon as the
	  configure step succeeds, all the rest will succeed too. Please use the
	  mailinglist at <email>orocos-dev@lists.mech.kuleuven.be</email> for
	  support questions.
	</para>
	<para>
	  The <command>make docs</command> and
	  <command>make doxy-dist</command> (both in 'build') commands build 
	  manuals and API documentation.
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Installing an Orocos Build</title>
      <para>
	Orocos can optionally ( <emphasis> but recommended</emphasis> ) be installed on your system with <screen>
  make install</screen>
	The
	default directory is <filename>/usr/local/orocos</filename>, but 
	can be changed with the <option>--with-prefix</option> option :
	<screen>  ../configure --with-prefix=/opt/other/</screen></para>
      <para>
	If you choose not to install Orocos, you can find the build's result
	in the <filename>build/packages/install/[lib/include]</filename> directory.
	The ecostools allow to define a
	separate build directory, but this is documented in the
	eCos manuals. Kernel modules can be found in the install/modules
	directory and might need manual installation.
      </para>
      <para>You can find the resulting build products on the following places:</para>
      <table frame="all">
	<title>Build Products Locations</title>
	<tgroup cols="2">
	  <thead>
	    <row>
	      <entry>What</entry>
	      <entry>Where</entry>
	    </row>
	  </thead>
	  <tbody>
<!-- 	    <row> -->
<!-- 	      <entry>Executable programs</entry> -->
<!-- 	      <entry>install/bin or /usr/local/orocos/bin</entry> -->
<!-- 	    </row> -->
	    <row>
	      <entry>
		<para>
		  Orocos library. Depending on the target :
		  liborocos-&lt;target>.a and libtarget.a
		</para>
	      </entry>
	      <entry>install/lib or /usr/local/orocos/lib</entry>
	    </row>
	    <row>
	      <!-- one of (entrytbl entry) -->
	      <entry><para>Orocos header files. Inside the package subdirectories.</para></entry>
	      <entry>install/include or /usr/local/orocos/include</entry>
	    </row>
	    <row>
	      <!-- one of (entrytbl entry) -->
	      <entry>Orocos kernel modules</entry>
	      <entry>install/modules</entry>
	    </row>
	  </tbody>
	</tgroup>
      </table>
    </sect2>
  </sect1>
  <sect1 id="install-configure">
    <title>Configuration</title>
    <sect2>
      <title>Configuring an Orocos Package</title>
      <para>
	By default, the &orocos; library will be built  in
	<filename class="directory">packages/install</filename>
	and installed in <filename>/usr/local/orocos</filename>.
      </para>
      <para>
	You can modify the former by passing a <option>--prefix=</option> option to ecosconfig or
	change it in the GUI and modify the latter by passing the <option>--prefix=</option>
	to <command>configure</command>.
      </para>
	<note>
	  <para>
	    ecosconfig and configtool both use a different namingscheme
	    for build directories. configtool uses the
	    &lt;config_name&gt;-build, &lt;config_name&gt;-mlt, &lt;config_name&gt;-mlt
	    subdirectories while ecosconfig uses the current dir to build and
	    the 'install' directory for installation. 
	  </para>
	</note>
	<note>
	<para>
	  It is advised to only
	  use the <command>configtool</command> GUI for generating the orocos.ecc file and
	  using <command>make</command> for creating a build tree.
	  </para>
	</note>
	<note>
	  <para>
	    If you invoke the eCos tools manually (without the make command)
	    you need to type the following command :
	    <command>export ECOS_REPOSITORY=/path/to/orocos-trunk/packages</command>
	    You can then run <command>ecosconfig help</command> or
	    <command>configtool</command>.
	  </para>	
	</note>
      <para>
	Just running <command>../configure</command> or <command>../configure
	  --with-gnulinux</command> selects the os/gnulinux target.
      </para>

<!-- 	<para> -->
<!-- 	  When running <command>../configure - -with-rtlinux</command> the configure -->
<!-- 	  script will select the os/rtlinux target. -->
<!-- 	</para> -->

<!-- 	<para> -->
<!-- 	  When running <command>../configure - -with-rtai</command>, the -->
<!-- configure script will select the os/rtai target -->
<!-- 	  <tip> -->
<!-- 	    <para> -->
<!-- 	      Read <xref linkend="general_setup_rtai"/> about possible patches you -->
<!-- 	      should apply to RTAI before a run will compile. -->
<!-- 	    </para> -->
<!-- 	  </tip> -->
<!-- 	</para> -->
      <para>
	When running
	<command>../configure --with-lxrt=/usr/local/realtime --with-linux=/usr/src/linux</command>
	(the path is optional) the configure
	script will try to find your RTAI installation in <filename>/usr/local/realtime</filename>
	and select the os/lxrt target. You need to specify the path to your <emphasis>RTAI patched</emphasis>
	Linux Kernel in case Orocos needs it to build properly.
	The default path where LXRT is being looked for is
	<filename>/usr/realtime</filename>, while the default Linux path is
	<filename>/usr/src/linux</filename>. To use the LibC Kernel headers in
	<filename>/usr/include/linux</filename>, specify
	<option>--with-linux=/usr</option>.
	Watch carefully the output to find any errors.
      </para>
      <para>
	When the target is selected with configure, you can run
	<command>make configure_packages</command> to pop up the GUI configtool.
	Some things to do  are :
      </para>
      <itemizedlist>
	<listitem>
	  <para>
	    Add/Remove a Package to/from your configuration : click on <menuchoice>
	      <guimenu>Build->Packages</guimenu></menuchoice>. Only
	    packages in the repository can be added or removed. <emphasis>This operation does not
	    remove a package from the repository.</emphasis>
	  </para>
	  <informalfigure>
	    <mediaobject>
	      <imageobject role="html">
		<imagedata fileref="ConfigToolPackages" />
	      </imageobject>
	      <imageobject role="fo">
		<imagedata format="JPG" fileref="ConfigToolPackages.jpg" />
	      </imageobject>
	    </mediaobject>
	  </informalfigure>
	</listitem>
	<listitem>
	  <para>
	    Install a new Package in the repository : click on <menuchoice>
	      <guimenu>Tools->Administration</guimenu></menuchoice>, this allows you to select an
	    <filename>.epk</filename> file from your harddisk, which will be
	    added to your packages repository.
	  </para>
	  <informalfigure>
	    <mediaobject>
	      <imageobject role="html">
		<imagedata fileref="ConfigToolAdmin" />
	      </imageobject>
	      <imageobject role="fo">
		<imagedata format="JPG" fileref="ConfigToolAdmin.jpg" />
	      </imageobject>
	    </mediaobject>
	  </informalfigure>
	</listitem>
      </itemizedlist>
    </sect2>
    <sect2 id="install-flags">
      <title>Orocos Build Compiler Flags</title>
      <para>
	You must set the compiler flags in the configtool GUI, in
	<menuchoice>
	  <guilabel>Global Build Options</guilabel>
	</menuchoice>
      </para>
      <informalfigure>
	<mediaobject>
	  <imageobject role="html">
	    <imagedata fileref="ConfigToolFlags" />
	  </imageobject>
	  <imageobject role="fo">
	    <imagedata format="JPG" fileref="ConfigToolFlags.jpg" />
	  </imageobject>
	</mediaobject>
      </informalfigure>
      <para>
	Furthermore, you <emphasis>MUST SET</emphasis> the Linux directory
	path in the configtool if you want to compile <emphasis>Linux Kernel Modules</emphasis>.
	Otherwise the build will fail.
      </para>
    </sect2>
    <sect2 id="install-config-devs">
      <title>Configuring Device Drivers</title>
      <para>
	Orocos provides device drivers for the Philips SJA1000
	CAN Controller, APCI1710 Encoder card, APCI2200 Digital
	IO card and Comedi Devices. These are not compiled 
	with the default installation. In the graphical
	configtool you can add device drivers with the menu
	"Build->Packages". They will be grouped in the
	device_drivers parent package.
      </para>
      <sect3>
	<title>Comedi and ComediLib</title>
	<para>
	  Orocos has a ported small part of the ComediLib
	  interface in its C++ device interface. To use these
	  classes, the Orocos configure script must first
	  detect a valid installation. This can be done
	  by providing this option to configure :
	  <screen>  ../configure --with-comedi=/path/to/comedi/include </screen>
	  If found, the Comedi support package will
	  be generated, and you will be able to add the
	  Orocos Comedi Device Driver to your configuration.
	</para>
	<important>
	  <para>
	    Orocos can use ComediLib from the GNU/Linux target
	    (non realtime interface), in which case you must
	    point configure to the 'comedilib' path (for example <filename>/usr/src/comedilib/include</filename>)
	    and the LXRT target ( realtime interface ), in which
	    case you must configure to the 'comedi' path (for example <filename>/usr/src/comedi/include</filename>).
	  </para>
	</important>
      </sect3>
      <sect3>
	<title>Philips SJA1000 CAN Controller</title>
	<para>
	  Orocos has a preliminary CAN Controller implementation
	  using the CANPie interface. To use it, the <filename>CANPie</filename>
	  and <filename>CANOpen</filename> packages must be 
	  added to your configuration. The device driver
	  works with RTAI/LXRT.
	</para>
      </sect3>
    </sect2>
    <sect2 id="install-config-corba">
      <title>Configuring for CORBA</title>
      <para>
	Orocos is slowly gaining support for CORBA. Orocos
	is recommended to be used with 'The Ace Orb' or 
	<emphasis>TAO</emphasis> version prepared by 
	OCI (Object Computing Inc.). You can find the 
	latest TAO version on 
	<ulink url="http://www.theaceorb.com">OCI's TAO
	website</ulink>. Orocos was tested with OCI's TAO 1.3 and 1.4.
	The OCI version is far more stable than the versions
	provided by the DOC group on the <ulink url="http://www.cs.wustl.edu/~schmidt/TAO.html">
	Real-time CORBA with TAO (The ACE ORB) website</ulink>.
      </para>
      <sect3>
	<title>Finding the TAO installation</title>
	<para>
	  Orocos looks for TAO in your standard include
	  paths, in case your distribution packages TAO.
	  However, if you prefer to use the OCI version,
	  you need to add a configure flag to tell Orocos
	  where to find the <filename>ACE_wrappers</filename> directory:
	  <screen>../configure --with-tao=/path/to/ACE_wrappers</screen>
	  Orocos assumes that the ACE headers are then found in
	  <filename>/path/to/ACE_wrappers/ace</filename>, the
	  TAO headers are found in <filename>/path/to/ACE_wrappers/TAO/tao</filename>,
	  the libraries are found in <filename>/path/to/ACE_wrappers/lib</filename>
	  and the IDL compiler in <filename>/path/to/ACE_wrappers/bin</filename>.
	  These are all the correct values when using the downloaded
	  packages.
	</para>
      </sect3>
      <sect3>
	<title>IDL File Compilation</title>
	<para>
	  When Orocos detects the presence of TAO, it immediately
	  generates the client and server files for all the Orocos IDL
	  files during the configure step. Thus in order to
	  re-generate these files, the configure script needs to be
	  called again. When you do not make use of Orocos' Corba
	  functionality, these files are not compiled nor used in any
	  way by the Orocos build.
	</para>
      </sect3>
      <sect3>
	<title>Application Development with TAO</title>
	<para>
	  Once you compile and link your application with Orocos and with the
	  Corba functionality enabled, you must provide the correct include
	  and link flags in your own Makefile. More specifically, you must
	  add:
	  <itemizedlist>
	    <listitem>
	      <para>
		Compiling : <option>-I/path/to/ACE_wrappers</option>
	      </para>
	      <para>
		This is the ACE build directory in case you use OCI's
		TAO packages. This option is not needed if you used
		your distribution's TAO installation, in that case,
		TAO is in the standard include path.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Linking : <option>-L/path/to/ACE_wrappers/lib -lTAO -lACE -lTAO_IDL_BE -lTAO_PortableServer -lTAO_CosNaming</option>
	      </para>
	      <para>
		This is again the ACE build directory in case you use OCI's
		TAO packages. The <emphasis>first</emphasis> option is not needed if you used
		your distribution's TAO installation, in that case,
		TAO is in the standard library path.
	      </para>
	      <important>
		<para>
		  You must also need to add
		  <filename>/path/to/ACE_wrappers</filename> to the
		  <filename>/etc/ld.so.conf</filename> file and rerun
		  <command>ldconfig</command>, such that these libraries
		  can be found.  Or you can before you start your application
		  type <screen>export LD_LIBRARY_PATH=/path/to/ACE_wrappers/lib</screen>.
		</para>
	      </important>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>
    </sect2>
    <sect2 id="general_setup_rtai">
      <title >Configuring RTAI</title>
      <para>
	Read first the 'Getting Started' section from <ulink
	  url="http://people.mech.kuleuven.ac.be/~psoetens/portingtolxrt.html">this 
	  page</ulink> if you are not familiar with RTAI installation
      </para>
      <para>
	RTAI 3.1 with Linux 2.6 and later versions are the most stable combination in our experience, 
	however you can also use RTAI 3.0 for less resource consuming applications.
	You can obtain it from 
	<ulink url="http://www.aero.polimi.it/projects/rtai/">
	  the RTAI home page</ulink>.
	Read The README.* files in the
	<filename class="directory">rtai</filename> directory for detailed
	instructions.  First, you need to patch your Linux kernel with the RTAI patch. A patch per
	kernel version can be found in the <filename>rtai-core/arch/i386/patches</filename> directory. You should
	apply
	the <filename>hal12-X.Y.Z.patch</filename> (or later) for RTAI  to a clean
	<filename>Linux-X.Y.Z</filename> kernel.  We refer to the RTAI installation instructions for more
	details.
      </para>
      <para>
	Next do <command>make menuconfig; make dep; make;</command>
      </para>
      <sect3>
	<title> RTAI settings </title>
	<para>
	  RTAI comes with documentation for configuration and
	  installation.  In the configuration process, make sure that
	  you enable the following options (<emphasis>in addition to
	  options you feel you need for your application</emphasis>) :
	  <itemizedlist>
	    <listitem>
	      <para>General -&gt; 'Enable extended configuration mode'</para>
	    </listitem>
	    <listitem>
	      <para>Core System -&gt; Native RTAI schedulers &gt;
	      Scheduler options -&gt; 'Number of LXRT slots' ('500') </para>
	    </listitem>
	    <listitem>
	      <para>Machine -&gt; 'Enable FPU support'</para>
	    </listitem>
	    <listitem>
	      <para>Core System -&gt; Native RTAI schedulers &gt;
	      IPC support -&gt; Semaphores, Fifos, Bits (or Events) and Mailboxes</para>
	    </listitem>
	    <listitem>
	      <para>Add-ons -&gt; 'Comedi Support over LXRT' (if you intend to use the
	      Orocos Comedi Drivers)</para>
	    </listitem>
	    <listitem>
	      <para>Core System -&gt; Native RTAI schedulers &gt;
	      'LXRT scheduler (kernel and user-space tasks)'</para>
	    </listitem>
	  </itemizedlist>
	  After configuring you can run 'make' and 'make install' in your RTAI directory
	</para>
	<para>
	  After installation, RTAI can be found in <filename>/usr/realtime</filename>. You'll have to 
	  specify during the Orocos configure step the alternative if you chose so.
	</para>
      </sect3>
<!--       <sect3> -->
<!-- 	<title> Loading RTAI without LXRT (not recommended)</title> -->
<!-- 	<para> -->
<!-- 	  To enable RTAI without LXRT run in your rtai directory one of the programs -->
<!-- 	  <screen> -->
<!-- ./setsched up    # for uniprocessor systems OR -->
<!-- ./setsched smp   # for smp systems -->
<!-- 	  </screen> -->
<!-- 	  next you can 'make  install'.  -->
<!-- 	  Make sure that the following RTAI kernel modules are loaded -->
<!-- 	  <itemizedlist> -->
<!-- 	    <listitem><para>rtai_cpp</para></listitem> -->
<!-- 	    <listitem><para>rtai_sched_ext</para></listitem> -->
<!-- 	    <listitem><para>rtai_bits</para></listitem> -->
<!-- 	    <listitem><para>rtai_up</para></listitem> -->
<!-- 	    <listitem><para>rtai_pthread</para></listitem> -->
<!-- 	    <listitem><para>rtai_sem</para></listitem> -->
<!-- 	    <listitem><para>rtai_fifos</para></listitem> -->
<!-- 	    <listitem><para>rtai_hal</para></listitem> -->
<!-- 	    <listitem><para>adeos</para></listitem> -->
<!-- 	  </itemizedlist> -->
<!-- 	  For example, by executing as root: -->
<!-- 	  <command>modprobe rtai_cpp; modprobe rtai_pthread; modprobe rtai_fifos</command>. -->
<!--         </para> -->
<!--       </sect3> -->
      <sect3>
	<title> Loading RTAI with LXRT</title>
	<para>
	  LXRT is a all-in-one scheduler that works for kernel and userspace.
	  So if you use this, you can still run kernel programs but have the ability
	  to run realtime programs in userspace. Orocos provides you the libraries
	  to build these programs.
	  Make sure that the following RTAI kernel modules are loaded
	  <itemizedlist>
	    <listitem><para>rtai_sem</para></listitem>
	    <listitem><para>rtai_lxrt</para></listitem>
	    <listitem><para>rtai_hal</para></listitem>
	    <listitem><para>adeos</para></listitem>
	  </itemizedlist>
	  For example, by executing as root:
	  <command>modprobe rtai_lxrt; modprobe rtai_sem</command>.
	</para>
	<para>For a more detailed description of what LXRT really is,
	  you can read the LXRT HOWTO 
	  <ulink url="http://people.mech.kuleuven.ac.be/~psoetens/lxrt/portingtolxrt.html">here</ulink>
	</para>
      </sect3>
      <sect3>
	<title>Compiling Applications with LXRT</title>
<!-- 	<important><title>Fedora Core (RedHat) and other distributions</title> -->
<!-- 	  <para> -->
<!-- 	    Because the RTAI/LXRT headers (which Orocos needs) include kernel-specific headers, you -->
<!-- 	    need to enable the 'LXRT with Kernel Headers Workaround' option in the -->
<!-- 	    configuration tool. You need to set the path to your Linux source tree (on which the -->
<!-- 	    patch was applied ) in the <command>make configure_packages</command> step. -->
<!-- 	  </para>	 -->
<!-- 	</important> -->
	<para>
	  Application which use LXRT as a target need special flags when being
	  compiled and linked. Especially :
	  <itemizedlist>
	    <listitem>
	      <para>
		Compiling : <option>-I/usr/realtime/include</option>
	      </para>
	      <para>
		This is the RTAI headers installation directory. This option is not needed
		if you configured Orocos with the 'Agnostic headers' option.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Linking : <option>-L/usr/realtime/lib -llxrt</option> for dynamic (.so) linking OR add
		<option> /usr/realtime/liblxrt.a </option> for static (.a) linking.
	      </para>
	      <important>
		<para>
		  You might also need to add
		  <filename>/usr/realtime/lib</filename> to the
		  <filename>/etc/ld.so.conf</filename> file and rerun
		  <command>ldconfig</command>, such that liblxrt.so
		  can be found.  This option is not needed if you
		  configured RTAI with LXRT-static-inlining.
		</para>
	      </important>
	    </listitem>
	  </itemizedlist>
	</para>
      </sect3>
    </sect2>
    <sect2>
      <title>Configuring for RTLinux</title>
      <para>
	The latest free release of RTLinux was 3.2. RTLinux is no longer supported
	since no users of Orocos are using it.
      </para>
<!--       <para> -->
<!-- 	For a recent kernel patch, look at <ulink -->
<!-- 	  url="http://bernia.disca.upv.es/rtportal/apps/upgrades/">RTlinux patches to -->
<!-- 	  newer Linux kernels</ulink> webpage. The RTLinux  -->
<!-- 	<ulink url="http://www.fsmlabs.com/">Homepage</ulink> contains more -->
<!-- 	information. -->
<!--       </para> -->
<!--       <sect3> -->
<!-- 	<title>Loading RTLinux</title> -->
<!-- 	<para> -->
<!-- 	  The following RTLinux kernel modules should be loaded in the specified order: -->
<!-- 	    <orderedlist> -->
<!-- 	    <listitem><para>rtl</para></listitem> -->
<!-- 	    <listitem><para>rtl_time</para></listitem> -->
<!-- 	    <listitem><para>rtl_posixio</para></listitem> -->
<!-- 	    <listitem><para>rtl_fifo</para></listitem> -->
<!-- 	    <listitem><para>rtl_sched</para></listitem> -->
<!-- 	  </orderedlist> -->
<!-- 	  You can use the <command>modprobe</command> or <command>insmod</command> as root -->
<!--  	  to load these needed kernel modules. -->
<!-- 	</para> -->
<!--       </sect3>  -->
    </sect2>
    <sect2>
      <title>Upgrading Your Configuration</title>
      <para>
	In between Orocos versions, configuration options may be added
	or removed to reflect feature additions or removal. In that
	case, your current <filename>orocos.ecc</filename> file will
	not be properly parsed by the tools. To solve this, you need
	to run <screen>  make upgrade_packages</screen> such that your
	old configuration is imported in the new one. After an
	upgrade, your selected template, added packages and so on will
	remain as before.
      </para>
      <note>
	<para>You can manually save your configuration using
	  <command>ecosconfig export /tmp/savefile.ecc</command> in
	  your old build tree, followed by <command>make
	    new_packages</command> and <command>ecosconfig import
	    /tmp/savefile.ecc</command> in your new build tree.
	  ( manually invoking ecosconfig requires setting ECOS_REPOSITORY, 
	   <xref linkend="technical-install" /> ).
	</para>
      </note>
    </sect2>
  </sect1>

  <sect1 id="started">
    <title>Getting Started with the Code</title>
    <para>
      This Section provides a short overview of how to proceed next using the
      &orocos; Packages.
    </para>
    <sect2>
      <title>A quick test</title>
      <para>
	You can issue a <command>make check</command> in the Orocos
	build dir, but this stresses your system heavily, so it might crash
	not fully stable RTAI installations. make check for the gnulinux
	target should successfully complete.
      </para>
      <para>
	To quickly test an &orocos; application, you can download the kernel_samples
	tar.gz package, untar it  and type make all (
	or make all-lxrt for lxrt). The kernel_samples/README file contains
	complete instructions.
      </para>
    </sect2>
    <sect2>
      <title>What about main() ?</title>
      <para>
	The first question asked by many users is : How do I write a
	test program to see how it works? 
      </para>
      <para>
	  Building a sample application with &orocos; is quite simple,
	  but some care must be taken in initialising the realtime
	  environment. First of all, you need to provide a function
	  <function>int ORO_main(int argc, char** argv)
	    {...}</function>, defined in &lt;os/main.h&gt; which contains your program :
	    <programlisting>  #include &lt;os/main.h&gt;
	      
  int ORO_main(int argc, char** argv)
  {
     // Your code, do not use 'exit()', use 'return' to 
     // allow Orocos to cleanup system resources.
  } </programlisting>
          If you link
	  with the liborocos-&lt;target&gt;.a library, this function will
	  be called after the run-time environment is set up. To put in
	  other words, the Orocos library already contains a
	  main() function which will call the user-defined ORO_main()
	  function.
	</para>
	<example>
	  <title>A Makefile for an Orocos Application</title>
	  <para>
	    You can then simply compile your program with a Makefile
	    resembling this one : 
	    <programlisting>  CXXFLAGS=-O2 -I/usr/local/orocos/include -D_REENTRANT
  LDFLAGS=-L/usr/local/orocos/lib -lorocos-<emphasis>&lt;target></emphasis> -lstdc++ -lpthread -lreadline -lncurses

  all: myprogram.cpp
        g++ myprogram.cpp ${CXXFLAGS} ${LDFLAGS} -o myprogram  </programlisting>
	    As you can see, your application does not have to be
	    inside the packages directory at all. Applications can
	    be developped fully out of the Orocos (build) directory.
	  </para>
	<para>
	  <important>
	    <para>The <option>LDFLAGS</option> option must be placed after
	    the <filename>.cpp</filename> or <filename>.o</filename>
	    files in the gcc command. Furthermore, the <option>-D_REENTRANT</option>
	    option is necessary if Orocos is also compiled with this flag
	    ( which is the default ).</para>
	  </important>
	  <note>
	    <para>Make sure you have read <xref linkend="install-configure" />
	      for your target if you application has compilation or link errors
	      ( for example when using LXRT ).
	    </para>
	  </note>
	</para>
	</example>
<!--         The short answer is: modify a program in the -->
<!--         <filename class="directory">tests</filename> directory.  The even -->
<!--         shorter answer is: <emphasis>There is no main (Neo realized that -->
<!--         too!). </emphasis>  -->
<!--         In the current implementation, realtime execution in the kernel -->
<!--         of your program is provided by inserting kernel modules into the -->
<!--         kernel using the commands <command>insmod</command> and -->
<!--         <command>rmmod</command> as the root user. <command>insmod</command> -->
<!--         will call a function <function>init_module()</function> and -->
<!--         <command>rmmod</command> will call a function -->
<!--         <function>cleanup_module()</function>. You must -->
<!--         provide them, so that when they are called, they start your realtime -->
<!--         program. You can see an example in <filename>src/module.c</filename>. -->
<!--         As you will see, <filename>module.c</filename> calls our real C++ -->
<!--         function which then starts or stops our program. -->
<!--         <filename>src/moduleStartStop.c</filename> is another example we use -->
<!--         for starting and stopping the framework in kernel space. -->
      </sect2>
    <sect2>
      <title>Header Files Overview</title>
      <para>
	People new to the eCos build system might be unfamiliar with locating
	the headers they need. Especially if you want to develop your own package
	or have more control on what is happening inside Orocos, these files will
	be needed.
	<table>
	  <title>Header Files</title>
	  <tgroup cols="2">
	    <thead>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>Header</entry>
		<entry>Summary</entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>pkgconf/*.h</entry>
		<entry>All these headers contain every configured item
		  of the configuration tool, collected per package.
		  If you need inside information
		  on how an Orocos package is configured, these files contain all the
		  defines, which were used when the libtarget.a was compiled.
		  The macros are documented in the .cdl files and displayed by the
		  configuration tool.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>pkgconf/system.h</entry>
		<entry>
		  This header contains the definition of each installed
		  package. The syntax is always of the type OROPKG_* and
		  quite straightforward. This file also contains the version
		  numbers of each installed package.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>pkgconf/os.h</entry>
		<entry>This file, which is created by the os package,
		  contains all the interfaces the current OS implements.
		  They are defined as OROINT_OS_* to denote the capability
		  of the OS. They are documented in the os.cdl file.
		  For example, OROINT_OS_STDVECTOR denotes that the standard
		  C++ vector implementation is available for the selected OS.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>corelib/*.hpp</entry>
		<entry>The corelib headers are documented by Doxygen and
		  the CoreLib manual. Most Orocos applications will
		  use events, tasks and timing from the CoreLib.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>os/*.h, os/*.hpp</entry>
		<entry>The os headers describe a limited set of
		  OS primitives, like locking a mutex or creating
		  a thread. Read the OS manual carefully before
		  using these headers, they are mostly used internally
		  in the corelib's implementation.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>execution/*.hpp</entry>
		<entry>The program and command execution headers enable
		parsing and execution of script programs and state machines.
		It provides a framework for setting up logical tasks which
		can communicate in a peer-to-peer way.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>control_kernel/*.hpp</entry>
		<entry>The Feedback Control Kernel and Components Headers.
		The Open Robot Control Software framework, a framework for
		implementing configurable, interactive control loops. Uses
		much of the fucntionality of the execution package.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>device_drivers/*.h[pp]</entry>
		<entry>Headers of any device drivers you enabled and some
		common headers.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>device_interface/*.hpp</entry>
		<entry>Headers of the C++ device interfaces for Orocos,
		such as encoders, IO, and Sensors.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>geometry/*.h[pp]</entry>
		<entry>The Orocos Geometry library defines Frames, Vectors,
		Twists, Paths, VelocityProfiles,... for 2D and 3D path planning.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>kindyn/*.hpp</entry>
		<entry>An implementation of a stateful and stateless Kinematics
		Component for 6DOF robots.
		</entry>
	      </row>
	      <row>
		<!-- one of (entrytbl entry) -->
		<entry>can/*.hpp, comedi/*.hpp</entry>
		<entry>Headers for Comedi and CANOpen device communication.
		</entry>
	      </row>
	    </tbody>
	  </tgroup>
	  <!-- one of (graphic mediaobject tgroup) -->
	</table>
      </para>
    </sect2>
  </sect1>
  <sect1 id="technical-install">
    <title>Installation Technical Details</title>
    <para>
      This section groups some technical installation instructions
      for Orocos developers.
    </para>
    <sect2>
      <title>Introduction to the eCos toolset</title>
      <para>
	This section goes into more detail how package management
	is done behind the scenes and is optional literature for
	the average user.
      </para>
      <para>
	The above make commands are optional. Take a
	look at the Makefile to see what they really do. A
	standard eCos configuration goes as follows :
	  <orderedlist>
	    <listitem>
	      <para>Set the environment variable :
		<screen>export ECOS_REPOSITORY=/path/to/orocos-&oversion;/packages/</screen>
		All The ecos tools need this variable to be able to work
		on the packages. The make targets did this automatically,
		but if you want to invoke the tools yourself, you need to
		set it once.
	      </para>
	    </listitem>
	    <listitem>
	      <para>Install any new .epk packages using
		<screen><command>ecosadmin.tcl add filename.epk</command></screen> in the 
		packages directory.
	      </para>
	      <para>
		This only adds a package to the repository, it does not mean it is
		automatically compiled ! Adding a package to a configuration in
		the next steps will assure that it is compiled.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Go to the eCos build directory. In Orocos this is :
		<screen><filename>orocos-&oversion;/build/packages</filename></screen>
	      But technically, it can be any directory
		where you create an orocos.ecc configuration file.
	      </para>
	    </listitem>
	    <listitem>
	      <para>Start a new build using the
		<screen><command>ecosconfig new gnulinux  corelib-os</command></screen>
	      command. Where
		<option>gnulinux</option> or <option>lxrt</option> is
		the target name and <option>corelib-os</option> is the
		template name. A template selects a number of packages
		which belong together. You are allowed to put your own
		template in
		<filename>orocos-&oversion;/packages/templates</filename>.
		All this information (with default options)
		is written in the <filename>orocos.ecc</filename> file
		<warning>
		  <para>This will overwrite any previous orocos.ecc
		    configuration file in that directory !</para>
		</warning>
	      </para>
	    </listitem>
	    <listitem>
	      <para>Add all detected support packages. The make target
		new_packages does this by running :
		<screen><command>  for i in $(find $ECOS_REPOSITORY/support -name "*.cdl"); do \
  ecosconfig add support_$(basename $i .cdl); done </command></screen>
		They will all be added to the orocos.ecc file.
		Fortunately, you can also add the support (or any other) packages
		in the graphical configtool menu->Build->Packages.
	      </para>
	    </listitem>
	    <listitem>
	      <para>
		Select additional packages for your build with the graphical
		configtool or with
	      <screen><command>ecosconfig add package_name</command></screen>
	      Configtool will give you a list
		of all available packages in the repository if you go to
		menu->Build->Packages and
		<screen><command>ecosconfig list</command></screen> does the same.
		This will add the package and its options to the orocos.ecc
		file (which contains configuration info of each selected package).
		Now the packages will show up when you run configtool or
		run <command>ecosconfig check</command>.
	      </para>
	    </listitem>
	    <listitem>
	      <para>Configure the selected packages with the graphical
		program <screen><command>configtool orocos.ecc</command></screen>
	      Save and exit.</para>
	    </listitem>
	    <listitem>
	      <para>Create the makefiles using
		<screen><command>ecosconfig tree</command></screen>
	      The build tree is setup now. You need to run this command
	      each time you change the configuration in the above step !</para>
	    </listitem>
	    <listitem>
	      <para>Compile using
		<screen><command>make</command></screen>
	      </para>
	    </listitem>
	    <listitem>
	      <para>The results (headers and libtarget.a)
		are in the install directory.</para>
	    </listitem>
	  </orderedlist>
	</para>
    </sect2>
    <sect2>
      <title>Installing Orocos from Subversion (similar to CVS)</title>
      <para>
	This section will do its best to help you through the
	Subversion ( svn ) installation process.
	Installing &orocos; from &svn; is optional and requires
	some familiarity with the tools we use. It is only advised for
	Orocos developers.
      </para>
      <para>
	The commands below show how to obtain the <emphasis>orocos-trunk</emphasis>
	Package Tree from the Subversion tree (read-only)
	<screen width="60">  svn co http://svn.mech.kuleuven.be/repos/orocos/orocos-trunk 
  cd orocos-trunk </screen>
	So, make sure you have
	the Subversion program installed, i.e., the command "svn" works on your
	 system. The repository is web-browsable through a
	 <ulink url="http://svn.mech.kuleuven.be/browse/orocos">ViewCVS frontend
	 </ulink>.
      </para>
      <para>
	The next step requires that you use
	<ulink url="http://www.gnu.org/software/automake/">automake</ulink>
	version 1.7.3 and
	<ulink url="http://www.gnu.org/software/autoconf/">autconf</ulink>
	version 2.54 or later. You can check your
	versions with the <parameter>--version</parameter> option:
	<screen>  $ automake --version
  automake (GNU automake) 1.7.3
   ...
  $ autoconf --version
  autoconf (GNU Autoconf) 2.54	</screen>
	<note>
	  <para> You need these programs if you intend to modify the makefiles</para>
	</note>
	When you get something similar, proceed with calling the <command>
	  ./autogen.sh </command> command in the base directory
	, in order to initialize the <filename>autoconf</filename> 
	and <filename>automake</filename> files:
	<screen>  ./autogen.sh</screen>
	The configure script will detect the installed software on your
	system and generate the appropriate scripts.
      </para>
      <para>
	The next steps are exactly the same as when you install the system
	starting from a so-called &ldquo;epk&rdquo; package, as explained in the
	next section. Of course, you don't have to apply the
	<command>ecosadmin.tcl</command> command when installing from &svn;.
      </para>
    </sect2>
  </sect1>
</article>
